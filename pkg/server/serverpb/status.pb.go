// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/serverpb/status.proto

package serverpb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	build "github.com/cockroachdb/cockroach/pkg/build"
	gossip "github.com/cockroachdb/cockroach/pkg/gossip"
	jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	kvserverpb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/kvserverpb"
	livenesspb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/liveness/livenesspb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	diagnosticspb "github.com/cockroachdb/cockroach/pkg/server/diagnostics/diagnosticspb"
	statuspb "github.com/cockroachdb/cockroach/pkg/server/status/statuspb"
	contentionpb "github.com/cockroachdb/cockroach/pkg/sql/contentionpb"
	_ "github.com/cockroachdb/cockroach/pkg/sql/execinfrapb"
	github_com_cockroachdb_cockroach_pkg_sql_execinfrapb "github.com/cockroachdb/cockroach/pkg/sql/execinfrapb"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	util "github.com/cockroachdb/cockroach/pkg/util"
	_ "github.com/cockroachdb/cockroach/pkg/util/hlc"
	logpb "github.com/cockroachdb/cockroach/pkg/util/log/logpb"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	raftpb "go.etcd.io/etcd/raft/v3/raftpb"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StacksType int32

const (
	StacksType_GOROUTINE_STACKS StacksType = 0
)

var StacksType_name = map[int32]string{
	0: "GOROUTINE_STACKS",
}

var StacksType_value = map[string]int32{
	"GOROUTINE_STACKS": 0,
}

func (x StacksType) String() string {
	return proto.EnumName(StacksType_name, int32(x))
}

func (StacksType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{0}
}

// Represents the type of file.
// TODO(ridwanmsharif): Add support for log files. They're currently served
// by an endpoint that parses the log messages, which is not what the
// debug zip client wants.
type FileType int32

const (
	FileType_HEAP       FileType = 0
	FileType_GOROUTINES FileType = 1
)

var FileType_name = map[int32]string{
	0: "HEAP",
	1: "GOROUTINES",
}

var FileType_value = map[string]int32{
	"HEAP":       0,
	"GOROUTINES": 1,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}

func (FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{1}
}

// We use an enum to allow reporting of client certs and potential others (eg:
// UI).
type CertificateDetails_CertificateType int32

const (
	CertificateDetails_CA        CertificateDetails_CertificateType = 0
	CertificateDetails_NODE      CertificateDetails_CertificateType = 1
	CertificateDetails_CLIENT_CA CertificateDetails_CertificateType = 2
	CertificateDetails_CLIENT    CertificateDetails_CertificateType = 3
	CertificateDetails_UI_CA     CertificateDetails_CertificateType = 4
	CertificateDetails_UI        CertificateDetails_CertificateType = 5
)

var CertificateDetails_CertificateType_name = map[int32]string{
	0: "CA",
	1: "NODE",
	2: "CLIENT_CA",
	3: "CLIENT",
	4: "UI_CA",
	5: "UI",
}

var CertificateDetails_CertificateType_value = map[string]int32{
	"CA":        0,
	"NODE":      1,
	"CLIENT_CA": 2,
	"CLIENT":    3,
	"UI_CA":     4,
	"UI":        5,
}

func (x CertificateDetails_CertificateType) String() string {
	return proto.EnumName(CertificateDetails_CertificateType_name, int32(x))
}

func (CertificateDetails_CertificateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{1, 0}
}

type ProfileRequest_Type int32

const (
	ProfileRequest_HEAP         ProfileRequest_Type = 0
	ProfileRequest_CPU          ProfileRequest_Type = 1
	ProfileRequest_GOROUTINE    ProfileRequest_Type = 2
	ProfileRequest_THREADCREATE ProfileRequest_Type = 3
	ProfileRequest_ALLOCS       ProfileRequest_Type = 4
	ProfileRequest_BLOCK        ProfileRequest_Type = 5
	ProfileRequest_MUTEX        ProfileRequest_Type = 6
)

var ProfileRequest_Type_name = map[int32]string{
	0: "HEAP",
	1: "CPU",
	2: "GOROUTINE",
	3: "THREADCREATE",
	4: "ALLOCS",
	5: "BLOCK",
	6: "MUTEX",
}

var ProfileRequest_Type_value = map[string]int32{
	"HEAP":         0,
	"CPU":          1,
	"GOROUTINE":    2,
	"THREADCREATE": 3,
	"ALLOCS":       4,
	"BLOCK":        5,
	"MUTEX":        6,
}

func (x ProfileRequest_Type) String() string {
	return proto.EnumName(ProfileRequest_Type_name, int32(x))
}

func (ProfileRequest_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{48, 0}
}

// Enum for phase of execution.
type ActiveQuery_Phase int32

const (
	ActiveQuery_PREPARING ActiveQuery_Phase = 0
	ActiveQuery_EXECUTING ActiveQuery_Phase = 1
)

var ActiveQuery_Phase_name = map[int32]string{
	0: "PREPARING",
	1: "EXECUTING",
}

var ActiveQuery_Phase_value = map[string]int32{
	"PREPARING": 0,
	"EXECUTING": 1,
}

func (x ActiveQuery_Phase) String() string {
	return proto.EnumName(ActiveQuery_Phase_name, int32(x))
}

func (ActiveQuery_Phase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{56, 0}
}

type DistSQLRemoteFlows_Status int32

const (
	DistSQLRemoteFlows_RUNNING DistSQLRemoteFlows_Status = 0
	DistSQLRemoteFlows_QUEUED  DistSQLRemoteFlows_Status = 1
)

var DistSQLRemoteFlows_Status_name = map[int32]string{
	0: "RUNNING",
	1: "QUEUED",
}

var DistSQLRemoteFlows_Status_value = map[string]int32{
	"RUNNING": 0,
	"QUEUED":  1,
}

func (x DistSQLRemoteFlows_Status) String() string {
	return proto.EnumName(DistSQLRemoteFlows_Status_name, int32(x))
}

func (DistSQLRemoteFlows_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{69, 0}
}

type StatementsRequest_FetchMode int32

const (
	StatementsRequest_StmtAndTxnStats StatementsRequest_FetchMode = 0
	StatementsRequest_StmtStatsOnly   StatementsRequest_FetchMode = 1
	StatementsRequest_TxnStatsOnly    StatementsRequest_FetchMode = 2
)

var StatementsRequest_FetchMode_name = map[int32]string{
	0: "StmtAndTxnStats",
	1: "StmtStatsOnly",
	2: "TxnStatsOnly",
}

var StatementsRequest_FetchMode_value = map[string]int32{
	"StmtAndTxnStats": 0,
	"StmtStatsOnly":   1,
	"TxnStatsOnly":    2,
}

func (x StatementsRequest_FetchMode) String() string {
	return proto.EnumName(StatementsRequest_FetchMode_name, int32(x))
}

func (StatementsRequest_FetchMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{84, 0}
}

type CertificatesRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *CertificatesRequest) Reset()         { *m = CertificatesRequest{} }
func (m *CertificatesRequest) String() string { return proto.CompactTextString(m) }
func (*CertificatesRequest) ProtoMessage()    {}
func (*CertificatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{0}
}
func (m *CertificatesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CertificatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificatesRequest.Merge(m, src)
}
func (m *CertificatesRequest) XXX_Size() int {
	return m.Size()
}
func (m *CertificatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CertificatesRequest proto.InternalMessageInfo

type CertificateDetails struct {
	Type CertificateDetails_CertificateType `protobuf:"varint,1,opt,name=type,proto3,enum=cockroach.server.serverpb.CertificateDetails_CertificateType" json:"type,omitempty"`
	// "error_message" and "data" are mutually exclusive.
	ErrorMessage string                      `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	Fields       []CertificateDetails_Fields `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields"`
}

func (m *CertificateDetails) Reset()         { *m = CertificateDetails{} }
func (m *CertificateDetails) String() string { return proto.CompactTextString(m) }
func (*CertificateDetails) ProtoMessage()    {}
func (*CertificateDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{1}
}
func (m *CertificateDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CertificateDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateDetails.Merge(m, src)
}
func (m *CertificateDetails) XXX_Size() int {
	return m.Size()
}
func (m *CertificateDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateDetails.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateDetails proto.InternalMessageInfo

type CertificateDetails_Fields struct {
	Issuer             string   `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	Subject            string   `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	ValidFrom          int64    `protobuf:"varint,3,opt,name=valid_from,json=validFrom,proto3" json:"valid_from,omitempty"`
	ValidUntil         int64    `protobuf:"varint,4,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
	Addresses          []string `protobuf:"bytes,5,rep,name=addresses,proto3" json:"addresses,omitempty"`
	SignatureAlgorithm string   `protobuf:"bytes,6,opt,name=signature_algorithm,json=signatureAlgorithm,proto3" json:"signature_algorithm,omitempty"`
	PublicKey          string   `protobuf:"bytes,7,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	KeyUsage           []string `protobuf:"bytes,8,rep,name=key_usage,json=keyUsage,proto3" json:"key_usage,omitempty"`
	ExtendedKeyUsage   []string `protobuf:"bytes,9,rep,name=extended_key_usage,json=extendedKeyUsage,proto3" json:"extended_key_usage,omitempty"`
}

func (m *CertificateDetails_Fields) Reset()         { *m = CertificateDetails_Fields{} }
func (m *CertificateDetails_Fields) String() string { return proto.CompactTextString(m) }
func (*CertificateDetails_Fields) ProtoMessage()    {}
func (*CertificateDetails_Fields) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{1, 0}
}
func (m *CertificateDetails_Fields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateDetails_Fields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CertificateDetails_Fields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateDetails_Fields.Merge(m, src)
}
func (m *CertificateDetails_Fields) XXX_Size() int {
	return m.Size()
}
func (m *CertificateDetails_Fields) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateDetails_Fields.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateDetails_Fields proto.InternalMessageInfo

type CertificatesResponse struct {
	Certificates []CertificateDetails `protobuf:"bytes,1,rep,name=certificates,proto3" json:"certificates"`
}

func (m *CertificatesResponse) Reset()         { *m = CertificatesResponse{} }
func (m *CertificatesResponse) String() string { return proto.CompactTextString(m) }
func (*CertificatesResponse) ProtoMessage()    {}
func (*CertificatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{2}
}
func (m *CertificatesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CertificatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificatesResponse.Merge(m, src)
}
func (m *CertificatesResponse) XXX_Size() int {
	return m.Size()
}
func (m *CertificatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CertificatesResponse proto.InternalMessageInfo

// DetailsRequest requests a nodes details.
// Note: this does *not* check readiness. Use the Health RPC for that purpose.
type DetailsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *DetailsRequest) Reset()         { *m = DetailsRequest{} }
func (m *DetailsRequest) String() string { return proto.CompactTextString(m) }
func (*DetailsRequest) ProtoMessage()    {}
func (*DetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{3}
}
func (m *DetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetailsRequest.Merge(m, src)
}
func (m *DetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetailsRequest proto.InternalMessageInfo

// SystemInfo contains information about the host system.
type SystemInfo struct {
	// system_info is the output from `uname -a`
	SystemInfo string `protobuf:"bytes,1,opt,name=system_info,json=systemInfo,proto3" json:"system_info,omitempty"`
	// kernel_info is the output from `uname -r`.
	KernelInfo string `protobuf:"bytes,2,opt,name=kernel_info,json=kernelInfo,proto3" json:"kernel_info,omitempty"`
}

func (m *SystemInfo) Reset()         { *m = SystemInfo{} }
func (m *SystemInfo) String() string { return proto.CompactTextString(m) }
func (*SystemInfo) ProtoMessage()    {}
func (*SystemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{4}
}
func (m *SystemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemInfo.Merge(m, src)
}
func (m *SystemInfo) XXX_Size() int {
	return m.Size()
}
func (m *SystemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SystemInfo proto.InternalMessageInfo

type DetailsResponse struct {
	NodeID     github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	Address    util.UnresolvedAddr                                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address"`
	BuildInfo  build.Info                                          `protobuf:"bytes,3,opt,name=build_info,json=buildInfo,proto3" json:"build_info"`
	SystemInfo SystemInfo                                          `protobuf:"bytes,4,opt,name=system_info,json=systemInfo,proto3" json:"system_info"`
	SQLAddress util.UnresolvedAddr                                 `protobuf:"bytes,5,opt,name=sql_address,json=sqlAddress,proto3" json:"sql_address"`
}

func (m *DetailsResponse) Reset()         { *m = DetailsResponse{} }
func (m *DetailsResponse) String() string { return proto.CompactTextString(m) }
func (*DetailsResponse) ProtoMessage()    {}
func (*DetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{5}
}
func (m *DetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetailsResponse.Merge(m, src)
}
func (m *DetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DetailsResponse proto.InternalMessageInfo

// NodesRequest requests a copy of the node information as known to gossip
// and the KV layer.
// API: PUBLIC ALPHA
type NodesRequest struct {
}

func (m *NodesRequest) Reset()         { *m = NodesRequest{} }
func (m *NodesRequest) String() string { return proto.CompactTextString(m) }
func (*NodesRequest) ProtoMessage()    {}
func (*NodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{6}
}
func (m *NodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodesRequest.Merge(m, src)
}
func (m *NodesRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodesRequest proto.InternalMessageInfo

// NodesResponse describe the nodes in the cluster.
// API: PUBLIC ALPHA
type NodesResponse struct {
	// nodes carries the status payloads for all nodes in the cluster.
	// API: PUBLIC ALPHA
	Nodes []statuspb.NodeStatus `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes"`
	// liveness_by_node_id maps each node ID to a liveness status.
	LivenessByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus `protobuf:"bytes,2,rep,name=liveness_by_node_id,json=livenessByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"liveness_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=cockroach.kv.kvserver.liveness.livenesspb.NodeLivenessStatus"`
}

func (m *NodesResponse) Reset()         { *m = NodesResponse{} }
func (m *NodesResponse) String() string { return proto.CompactTextString(m) }
func (*NodesResponse) ProtoMessage()    {}
func (*NodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{7}
}
func (m *NodesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodesResponse.Merge(m, src)
}
func (m *NodesResponse) XXX_Size() int {
	return m.Size()
}
func (m *NodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NodesResponse proto.InternalMessageInfo

// NodesResponse describe the nodes in the cluster.
// API: PUBLIC ALPHA
type NodesResponseExternal struct {
	// nodes carries the status payloads for all nodes in the cluster.
	// API: PUBLIC ALPHA
	Nodes []NodeResponse `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes"`
	// liveness_by_node_id maps each node ID to a liveness status.
	LivenessByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus `protobuf:"bytes,2,rep,name=liveness_by_node_id,json=livenessByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"liveness_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=cockroach.kv.kvserver.liveness.livenesspb.NodeLivenessStatus"`
}

func (m *NodesResponseExternal) Reset()         { *m = NodesResponseExternal{} }
func (m *NodesResponseExternal) String() string { return proto.CompactTextString(m) }
func (*NodesResponseExternal) ProtoMessage()    {}
func (*NodesResponseExternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{8}
}
func (m *NodesResponseExternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodesResponseExternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodesResponseExternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodesResponseExternal.Merge(m, src)
}
func (m *NodesResponseExternal) XXX_Size() int {
	return m.Size()
}
func (m *NodesResponseExternal) XXX_DiscardUnknown() {
	xxx_messageInfo_NodesResponseExternal.DiscardUnknown(m)
}

var xxx_messageInfo_NodesResponseExternal proto.InternalMessageInfo

// Locality is an ordered set of key value Tiers that describe a node's
// location. The tier keys should be the same across all nodes.
type Locality struct {
	Tiers []Tier `protobuf:"bytes,1,rep,name=tiers,proto3" json:"tiers"`
}

func (m *Locality) Reset()         { *m = Locality{} }
func (m *Locality) String() string { return proto.CompactTextString(m) }
func (*Locality) ProtoMessage()    {}
func (*Locality) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{9}
}
func (m *Locality) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Locality) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Locality) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Locality.Merge(m, src)
}
func (m *Locality) XXX_Size() int {
	return m.Size()
}
func (m *Locality) XXX_DiscardUnknown() {
	xxx_messageInfo_Locality.DiscardUnknown(m)
}

var xxx_messageInfo_Locality proto.InternalMessageInfo

// Tier represents one level of the locality hierarchy.
type Tier struct {
	// Key is the name of tier and should match all other nodes.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Value is node specific value corresponding to the key.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Tier) Reset()         { *m = Tier{} }
func (m *Tier) String() string { return proto.CompactTextString(m) }
func (*Tier) ProtoMessage()    {}
func (*Tier) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{10}
}
func (m *Tier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Tier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tier.Merge(m, src)
}
func (m *Tier) XXX_Size() int {
	return m.Size()
}
func (m *Tier) XXX_DiscardUnknown() {
	xxx_messageInfo_Tier.DiscardUnknown(m)
}

var xxx_messageInfo_Tier proto.InternalMessageInfo

type Version struct {
	// The names "major" and "minor" are reserved in C in
	// some platforms (e.g. FreeBSD).
	Major int32 `protobuf:"varint,1,opt,name=major_val,json=majorVal,proto3" json:"major_val,omitempty"`
	Minor int32 `protobuf:"varint,2,opt,name=minor_val,json=minorVal,proto3" json:"minor_val,omitempty"`
	// Note that patch is a placeholder and will always be zero.
	Patch int32 `protobuf:"varint,3,opt,name=patch,proto3" json:"patch,omitempty"`
	// The internal version is used to introduce migrations during the development
	// cycle. They are subversions that are never the end versions of a release,
	// i.e. users of stable, public release will only use binaries with the
	// internal version set to 0.
	Internal int32 `protobuf:"varint,4,opt,name=internal,proto3" json:"internal,omitempty"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{11}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

// NodeDescriptor holds details on node physical/network topology.
type NodeDescriptor struct {
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// address should only be visible by the Admin role.
	Address util.UnresolvedAddr `protobuf:"bytes,2,opt,name=address,proto3" json:"address"`
	// attrs should only be visible by the Admin role.
	Attrs         roachpb.Attributes `protobuf:"bytes,3,opt,name=attrs,proto3" json:"attrs"`
	Locality      Locality           `protobuf:"bytes,4,opt,name=locality,proto3" json:"locality"`
	ServerVersion Version            `protobuf:"bytes,5,opt,name=ServerVersion,proto3" json:"ServerVersion"`
	BuildTag      string             `protobuf:"bytes,6,opt,name=build_tag,json=buildTag,proto3" json:"build_tag,omitempty"`
	StartedAt     int64              `protobuf:"varint,7,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// locality_address should only be visible by the Admin role.
	LocalityAddress []roachpb.LocalityAddress `protobuf:"bytes,8,rep,name=locality_address,json=localityAddress,proto3" json:"locality_address"`
	ClusterName     string                    `protobuf:"bytes,9,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	// The SQL address. If empty, indicates that the base address field
	// is also used to accept SQL connections.
	// sql_address should only be visible by the Admin role.
	SQLAddress util.UnresolvedAddr `protobuf:"bytes,10,opt,name=sql_address,json=sqlAddress,proto3" json:"sql_address"`
}

func (m *NodeDescriptor) Reset()         { *m = NodeDescriptor{} }
func (m *NodeDescriptor) String() string { return proto.CompactTextString(m) }
func (*NodeDescriptor) ProtoMessage()    {}
func (*NodeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{12}
}
func (m *NodeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeDescriptor.Merge(m, src)
}
func (m *NodeDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *NodeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_NodeDescriptor proto.InternalMessageInfo

// Percentiles contains a handful of hard-coded percentiles meant to summarize
// a distribution.
type Percentiles struct {
	P10  float64 `protobuf:"fixed64,1,opt,name=p10,proto3" json:"p10,omitempty"`
	P25  float64 `protobuf:"fixed64,2,opt,name=p25,proto3" json:"p25,omitempty"`
	P50  float64 `protobuf:"fixed64,3,opt,name=p50,proto3" json:"p50,omitempty"`
	P75  float64 `protobuf:"fixed64,4,opt,name=p75,proto3" json:"p75,omitempty"`
	P90  float64 `protobuf:"fixed64,5,opt,name=p90,proto3" json:"p90,omitempty"`
	PMax float64 `protobuf:"fixed64,6,opt,name=pMax,proto3" json:"pMax,omitempty"`
}

func (m *Percentiles) Reset()         { *m = Percentiles{} }
func (m *Percentiles) String() string { return proto.CompactTextString(m) }
func (*Percentiles) ProtoMessage()    {}
func (*Percentiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{13}
}
func (m *Percentiles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Percentiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Percentiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Percentiles.Merge(m, src)
}
func (m *Percentiles) XXX_Size() int {
	return m.Size()
}
func (m *Percentiles) XXX_DiscardUnknown() {
	xxx_messageInfo_Percentiles.DiscardUnknown(m)
}

var xxx_messageInfo_Percentiles proto.InternalMessageInfo

// StoreDescriptor holds store information including store attributes, node
// descriptor and store capacity.
type StoreDescriptor struct {
	StoreID  github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	Attrs    roachpb.Attributes                                   `protobuf:"bytes,2,opt,name=attrs,proto3" json:"attrs"`
	Node     NodeDescriptor                                       `protobuf:"bytes,3,opt,name=node,proto3" json:"node"`
	Capacity roachpb.StoreCapacity                                `protobuf:"bytes,4,opt,name=capacity,proto3" json:"capacity"`
}

func (m *StoreDescriptor) Reset()         { *m = StoreDescriptor{} }
func (m *StoreDescriptor) String() string { return proto.CompactTextString(m) }
func (*StoreDescriptor) ProtoMessage()    {}
func (*StoreDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{14}
}
func (m *StoreDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoreDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreDescriptor.Merge(m, src)
}
func (m *StoreDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *StoreDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StoreDescriptor proto.InternalMessageInfo

// StoreStatus records the most recent values of metrics for a store.
type StoreStatus struct {
	// desc is the store descriptor.
	Desc StoreDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc"`
	// metrics contains the last sampled values for the node metrics.
	Metrics map[string]float64 `protobuf:"bytes,2,rep,name=metrics,proto3" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
}

func (m *StoreStatus) Reset()         { *m = StoreStatus{} }
func (m *StoreStatus) String() string { return proto.CompactTextString(m) }
func (*StoreStatus) ProtoMessage()    {}
func (*StoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{15}
}
func (m *StoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreStatus.Merge(m, src)
}
func (m *StoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *StoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_StoreStatus proto.InternalMessageInfo

// NodeStatus records the most recent values of metrics for a node.
// API: PUBLIC ALPHA
type NodeResponse struct {
	// desc is the node descriptor.
	Desc NodeDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc"`
	// build_info describes the `cockroach` executable file.
	// API: PUBLIC ALPHA
	BuildInfo build.Info `protobuf:"bytes,2,opt,name=build_info,json=buildInfo,proto3" json:"build_info"`
	// started_at is the unix timestamp at which the node process was
	// last started.
	// API: PUBLIC ALPHA
	StartedAt int64 `protobuf:"varint,3,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// updated_at is the unix timestamp at which the node status record
	// was last updated.
	// API: PUBLIC ALPHA
	UpdatedAt int64 `protobuf:"varint,4,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// metrics contains the last sampled values for the node metrics.
	Metrics map[string]float64 `protobuf:"bytes,5,rep,name=metrics,proto3" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// store_statuses provides the store status payloads for all
	// the stores on that node.
	StoreStatuses []StoreStatus `protobuf:"bytes,6,rep,name=store_statuses,json=storeStatuses,proto3" json:"store_statuses"`
	// args is the list of command-line arguments used to last start the node.
	// args should only be visible by the Admin role.
	Args []string `protobuf:"bytes,7,rep,name=args,proto3" json:"args,omitempty"`
	// env is the list of environment variables that influenced
	// the node's configuration.
	// env should only be visible by the Admin role.
	Env []string `protobuf:"bytes,8,rep,name=env,proto3" json:"env,omitempty"`
	// latencies is a map of nodeIDs to nanoseconds which is the latency
	// between this node and the other node.
	//
	// NOTE: this is deprecated and is only set if the min supported
	//       cluster version is >= VersionRPCNetworkStats.
	Latencies map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64 `protobuf:"bytes,9,rep,name=latencies,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"latencies" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// activity is a map of nodeIDs to network statistics from this node
	// to other nodes.
	Activity map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]NodeResponse_NetworkActivity `protobuf:"bytes,10,rep,name=activity,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"activity" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// total_system_memory is the total RAM available to the system
	// (or, if detected, the memory available to the cgroup this process is in)
	// in bytes.
	// API: PUBLIC ALPHA
	TotalSystemMemory int64 `protobuf:"varint,11,opt,name=total_system_memory,json=totalSystemMemory,proto3" json:"total_system_memory,omitempty"`
	// num_cpus is the number of logical CPUs as reported by the operating system
	// on the host where the `cockroach` process is running. Note that
	// this does not report the number of CPUs actually used by `cockroach`;
	// this parameter is controlled separately.
	// API: PUBLIC ALPHA
	NumCpus int32 `protobuf:"varint,12,opt,name=num_cpus,json=numCpus,proto3" json:"num_cpus,omitempty"`
}

func (m *NodeResponse) Reset()         { *m = NodeResponse{} }
func (m *NodeResponse) String() string { return proto.CompactTextString(m) }
func (*NodeResponse) ProtoMessage()    {}
func (*NodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{16}
}
func (m *NodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeResponse.Merge(m, src)
}
func (m *NodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *NodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NodeResponse proto.InternalMessageInfo

type NodeResponse_NetworkActivity struct {
	Incoming int64 `protobuf:"varint,1,opt,name=incoming,proto3" json:"incoming,omitempty"`
	Outgoing int64 `protobuf:"varint,2,opt,name=outgoing,proto3" json:"outgoing,omitempty"`
	Latency  int64 `protobuf:"varint,3,opt,name=latency,proto3" json:"latency,omitempty"`
}

func (m *NodeResponse_NetworkActivity) Reset()         { *m = NodeResponse_NetworkActivity{} }
func (m *NodeResponse_NetworkActivity) String() string { return proto.CompactTextString(m) }
func (*NodeResponse_NetworkActivity) ProtoMessage()    {}
func (*NodeResponse_NetworkActivity) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{16, 2}
}
func (m *NodeResponse_NetworkActivity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeResponse_NetworkActivity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeResponse_NetworkActivity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeResponse_NetworkActivity.Merge(m, src)
}
func (m *NodeResponse_NetworkActivity) XXX_Size() int {
	return m.Size()
}
func (m *NodeResponse_NetworkActivity) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeResponse_NetworkActivity.DiscardUnknown(m)
}

var xxx_messageInfo_NodeResponse_NetworkActivity proto.InternalMessageInfo

// RegionsRequest requests all available regions.
type RegionsRequest struct {
}

func (m *RegionsRequest) Reset()         { *m = RegionsRequest{} }
func (m *RegionsRequest) String() string { return proto.CompactTextString(m) }
func (*RegionsRequest) ProtoMessage()    {}
func (*RegionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{17}
}
func (m *RegionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RegionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionsRequest.Merge(m, src)
}
func (m *RegionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegionsRequest proto.InternalMessageInfo

// RegionsResponse describes the available regions.
type RegionsResponse struct {
	Regions map[string]*RegionsResponse_Region `protobuf:"bytes,1,rep,name=regions,proto3" json:"regions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RegionsResponse) Reset()         { *m = RegionsResponse{} }
func (m *RegionsResponse) String() string { return proto.CompactTextString(m) }
func (*RegionsResponse) ProtoMessage()    {}
func (*RegionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{18}
}
func (m *RegionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RegionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionsResponse.Merge(m, src)
}
func (m *RegionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegionsResponse proto.InternalMessageInfo

type RegionsResponse_Region struct {
	Zones []string `protobuf:"bytes,1,rep,name=zones,proto3" json:"zones,omitempty"`
}

func (m *RegionsResponse_Region) Reset()         { *m = RegionsResponse_Region{} }
func (m *RegionsResponse_Region) String() string { return proto.CompactTextString(m) }
func (*RegionsResponse_Region) ProtoMessage()    {}
func (*RegionsResponse_Region) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{18, 0}
}
func (m *RegionsResponse_Region) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionsResponse_Region) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RegionsResponse_Region) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionsResponse_Region.Merge(m, src)
}
func (m *RegionsResponse_Region) XXX_Size() int {
	return m.Size()
}
func (m *RegionsResponse_Region) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionsResponse_Region.DiscardUnknown(m)
}

var xxx_messageInfo_RegionsResponse_Region proto.InternalMessageInfo

type NodeRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *NodeRequest) Reset()         { *m = NodeRequest{} }
func (m *NodeRequest) String() string { return proto.CompactTextString(m) }
func (*NodeRequest) ProtoMessage()    {}
func (*NodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{19}
}
func (m *NodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRequest.Merge(m, src)
}
func (m *NodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRequest proto.InternalMessageInfo

// RaftState gives internal details about a Raft group's state.
// Closely mirrors the upstream definitions in github.com/etcd-io/etcd/raft.
type RaftState struct {
	ReplicaID uint64           `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	HardState raftpb.HardState `protobuf:"bytes,2,opt,name=hard_state,json=hardState,proto3" json:"hard_state"`
	// Lead is part of Raft's SoftState.
	Lead uint64 `protobuf:"varint,3,opt,name=lead,proto3" json:"lead,omitempty"`
	// State is part of Raft's SoftState.
	// It's not an enum because this is primarily for ui consumption and there
	// are issues associated with them.
	State          string                        `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	Applied        uint64                        `protobuf:"varint,5,opt,name=applied,proto3" json:"applied,omitempty"`
	Progress       map[uint64]RaftState_Progress `protobuf:"bytes,6,rep,name=progress,proto3" json:"progress" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LeadTransferee uint64                        `protobuf:"varint,7,opt,name=lead_transferee,json=leadTransferee,proto3" json:"lead_transferee,omitempty"`
}

func (m *RaftState) Reset()         { *m = RaftState{} }
func (m *RaftState) String() string { return proto.CompactTextString(m) }
func (*RaftState) ProtoMessage()    {}
func (*RaftState) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{20}
}
func (m *RaftState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftState.Merge(m, src)
}
func (m *RaftState) XXX_Size() int {
	return m.Size()
}
func (m *RaftState) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftState.DiscardUnknown(m)
}

var xxx_messageInfo_RaftState proto.InternalMessageInfo

type RaftState_Progress struct {
	Match           uint64 `protobuf:"varint,1,opt,name=match,proto3" json:"match,omitempty"`
	Next            uint64 `protobuf:"varint,2,opt,name=next,proto3" json:"next,omitempty"`
	State           string `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	Paused          bool   `protobuf:"varint,4,opt,name=paused,proto3" json:"paused,omitempty"`
	PendingSnapshot uint64 `protobuf:"varint,5,opt,name=pending_snapshot,json=pendingSnapshot,proto3" json:"pending_snapshot,omitempty"`
}

func (m *RaftState_Progress) Reset()         { *m = RaftState_Progress{} }
func (m *RaftState_Progress) String() string { return proto.CompactTextString(m) }
func (*RaftState_Progress) ProtoMessage()    {}
func (*RaftState_Progress) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{20, 0}
}
func (m *RaftState_Progress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftState_Progress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftState_Progress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftState_Progress.Merge(m, src)
}
func (m *RaftState_Progress) XXX_Size() int {
	return m.Size()
}
func (m *RaftState_Progress) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftState_Progress.DiscardUnknown(m)
}

var xxx_messageInfo_RaftState_Progress proto.InternalMessageInfo

// RangeProblems describes issues reported by a range. For internal use only.
type RangeProblems struct {
	Unavailable          bool `protobuf:"varint,1,opt,name=unavailable,proto3" json:"unavailable,omitempty"`
	LeaderNotLeaseHolder bool `protobuf:"varint,2,opt,name=leader_not_lease_holder,json=leaderNotLeaseHolder,proto3" json:"leader_not_lease_holder,omitempty"`
	NoRaftLeader         bool `protobuf:"varint,3,opt,name=no_raft_leader,json=noRaftLeader,proto3" json:"no_raft_leader,omitempty"`
	Underreplicated      bool `protobuf:"varint,4,opt,name=underreplicated,proto3" json:"underreplicated,omitempty"`
	Overreplicated       bool `protobuf:"varint,8,opt,name=overreplicated,proto3" json:"overreplicated,omitempty"`
	NoLease              bool `protobuf:"varint,5,opt,name=no_lease,json=noLease,proto3" json:"no_lease,omitempty"`
	// Quiescent ranges do not tick by definition, but we track this in
	// two different ways and suspect that they're getting out of sync.
	// If the replica's quiescent flag doesn't agree with the store's
	// list of replicas that are ticking, warn about it.
	QuiescentEqualsTicking bool `protobuf:"varint,6,opt,name=quiescent_equals_ticking,json=quiescentEqualsTicking,proto3" json:"quiescent_equals_ticking,omitempty"`
	// When the raft log is too large, it can be a symptom of other issues.
	RaftLogTooLarge bool `protobuf:"varint,7,opt,name=raft_log_too_large,json=raftLogTooLarge,proto3" json:"raft_log_too_large,omitempty"`
}

func (m *RangeProblems) Reset()         { *m = RangeProblems{} }
func (m *RangeProblems) String() string { return proto.CompactTextString(m) }
func (*RangeProblems) ProtoMessage()    {}
func (*RangeProblems) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{21}
}
func (m *RangeProblems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeProblems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeProblems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeProblems.Merge(m, src)
}
func (m *RangeProblems) XXX_Size() int {
	return m.Size()
}
func (m *RangeProblems) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeProblems.DiscardUnknown(m)
}

var xxx_messageInfo_RangeProblems proto.InternalMessageInfo

// RangeStatistics describes statistics reported by a range. For internal use
// only.
type RangeStatistics struct {
	// Queries per second served by this range.
	//
	// Note that queries per second will only be known by the leaseholder.
	// All other replicas will report it as 0.
	QueriesPerSecond float64 `protobuf:"fixed64,1,opt,name=queries_per_second,json=queriesPerSecond,proto3" json:"queries_per_second,omitempty"`
	// Writes per second served by this range.
	WritesPerSecond float64 `protobuf:"fixed64,2,opt,name=writes_per_second,json=writesPerSecond,proto3" json:"writes_per_second,omitempty"`
}

func (m *RangeStatistics) Reset()         { *m = RangeStatistics{} }
func (m *RangeStatistics) String() string { return proto.CompactTextString(m) }
func (*RangeStatistics) ProtoMessage()    {}
func (*RangeStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{22}
}
func (m *RangeStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeStatistics.Merge(m, src)
}
func (m *RangeStatistics) XXX_Size() int {
	return m.Size()
}
func (m *RangeStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_RangeStatistics proto.InternalMessageInfo

type PrettySpan struct {
	StartKey string `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   string `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *PrettySpan) Reset()         { *m = PrettySpan{} }
func (m *PrettySpan) String() string { return proto.CompactTextString(m) }
func (*PrettySpan) ProtoMessage()    {}
func (*PrettySpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{23}
}
func (m *PrettySpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrettySpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrettySpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrettySpan.Merge(m, src)
}
func (m *PrettySpan) XXX_Size() int {
	return m.Size()
}
func (m *PrettySpan) XXX_DiscardUnknown() {
	xxx_messageInfo_PrettySpan.DiscardUnknown(m)
}

var xxx_messageInfo_PrettySpan proto.InternalMessageInfo

type RangeInfo struct {
	Span                        PrettySpan                                           `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	RaftState                   RaftState                                            `protobuf:"bytes,2,opt,name=raft_state,json=raftState,proto3" json:"raft_state"`
	State                       kvserverpb.RangeInfo                                 `protobuf:"bytes,4,opt,name=state,proto3" json:"state"`
	SourceNodeID                github_com_cockroachdb_cockroach_pkg_roachpb.NodeID  `protobuf:"varint,5,opt,name=source_node_id,json=sourceNodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"source_node_id,omitempty"`
	SourceStoreID               github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,6,opt,name=source_store_id,json=sourceStoreId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"source_store_id,omitempty"`
	ErrorMessage                string                                               `protobuf:"bytes,7,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	LeaseHistory                []roachpb.Lease                                      `protobuf:"bytes,8,rep,name=lease_history,json=leaseHistory,proto3" json:"lease_history"`
	Problems                    RangeProblems                                        `protobuf:"bytes,9,opt,name=problems,proto3" json:"problems"`
	Stats                       RangeStatistics                                      `protobuf:"bytes,10,opt,name=stats,proto3" json:"stats"`
	LeaseStatus                 kvserverpb.LeaseStatus                               `protobuf:"bytes,13,opt,name=lease_status,json=leaseStatus,proto3" json:"lease_status"`
	Quiescent                   bool                                                 `protobuf:"varint,14,opt,name=quiescent,proto3" json:"quiescent,omitempty"`
	Ticking                     bool                                                 `protobuf:"varint,15,opt,name=ticking,proto3" json:"ticking,omitempty"`
	ReadLatches                 int64                                                `protobuf:"varint,16,opt,name=read_latches,json=readLatches,proto3" json:"read_latches,omitempty"`
	WriteLatches                int64                                                `protobuf:"varint,17,opt,name=write_latches,json=writeLatches,proto3" json:"write_latches,omitempty"`
	Locks                       int64                                                `protobuf:"varint,18,opt,name=locks,proto3" json:"locks,omitempty"`
	LocksWithWaitQueues         int64                                                `protobuf:"varint,19,opt,name=locks_with_wait_queues,json=locksWithWaitQueues,proto3" json:"locks_with_wait_queues,omitempty"`
	LockWaitQueueWaiters        int64                                                `protobuf:"varint,20,opt,name=lock_wait_queue_waiters,json=lockWaitQueueWaiters,proto3" json:"lock_wait_queue_waiters,omitempty"`
	TopKLocksByWaitQueueWaiters []RangeInfo_LockInfo                                 `protobuf:"bytes,21,rep,name=top_k_locks_by_wait_queue_waiters,json=topKLocksByWaitQueueWaiters,proto3" json:"top_k_locks_by_wait_queue_waiters"`
}

func (m *RangeInfo) Reset()         { *m = RangeInfo{} }
func (m *RangeInfo) String() string { return proto.CompactTextString(m) }
func (*RangeInfo) ProtoMessage()    {}
func (*RangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{24}
}
func (m *RangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeInfo.Merge(m, src)
}
func (m *RangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *RangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RangeInfo proto.InternalMessageInfo

type RangeInfo_LockInfo struct {
	PrettyKey      string                                           `protobuf:"bytes,1,opt,name=pretty_key,json=prettyKey,proto3" json:"pretty_key,omitempty"`
	Key            github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,opt,name=key,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"key,omitempty"`
	Held           bool                                             `protobuf:"varint,3,opt,name=held,proto3" json:"held,omitempty"`
	Waiters        int64                                            `protobuf:"varint,4,opt,name=waiters,proto3" json:"waiters,omitempty"`
	WaitingReaders int64                                            `protobuf:"varint,5,opt,name=waiting_readers,json=waitingReaders,proto3" json:"waiting_readers,omitempty"`
	WaitingWriters int64                                            `protobuf:"varint,6,opt,name=waiting_writers,json=waitingWriters,proto3" json:"waiting_writers,omitempty"`
}

func (m *RangeInfo_LockInfo) Reset()         { *m = RangeInfo_LockInfo{} }
func (m *RangeInfo_LockInfo) String() string { return proto.CompactTextString(m) }
func (*RangeInfo_LockInfo) ProtoMessage()    {}
func (*RangeInfo_LockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{24, 0}
}
func (m *RangeInfo_LockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeInfo_LockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeInfo_LockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeInfo_LockInfo.Merge(m, src)
}
func (m *RangeInfo_LockInfo) XXX_Size() int {
	return m.Size()
}
func (m *RangeInfo_LockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeInfo_LockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RangeInfo_LockInfo proto.InternalMessageInfo

type RangesRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId   string                                                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RangeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,2,rep,packed,name=range_ids,json=rangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_ids,omitempty"`
}

func (m *RangesRequest) Reset()         { *m = RangesRequest{} }
func (m *RangesRequest) String() string { return proto.CompactTextString(m) }
func (*RangesRequest) ProtoMessage()    {}
func (*RangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{25}
}
func (m *RangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangesRequest.Merge(m, src)
}
func (m *RangesRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangesRequest proto.InternalMessageInfo

type RangesResponse struct {
	Ranges []RangeInfo `protobuf:"bytes,1,rep,name=ranges,proto3" json:"ranges"`
}

func (m *RangesResponse) Reset()         { *m = RangesResponse{} }
func (m *RangesResponse) String() string { return proto.CompactTextString(m) }
func (*RangesResponse) ProtoMessage()    {}
func (*RangesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{26}
}
func (m *RangesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangesResponse.Merge(m, src)
}
func (m *RangesResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangesResponse proto.InternalMessageInfo

type GossipRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *GossipRequest) Reset()         { *m = GossipRequest{} }
func (m *GossipRequest) String() string { return proto.CompactTextString(m) }
func (*GossipRequest) ProtoMessage()    {}
func (*GossipRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{27}
}
func (m *GossipRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GossipRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipRequest.Merge(m, src)
}
func (m *GossipRequest) XXX_Size() int {
	return m.Size()
}
func (m *GossipRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GossipRequest proto.InternalMessageInfo

type EngineStatsInfo struct {
	StoreID              github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	TickersAndHistograms *enginepb.TickersAndHistograms                       `protobuf:"bytes,2,opt,name=tickers_and_histograms,json=tickersAndHistograms,proto3" json:"tickers_and_histograms,omitempty"`
	EngineType           enginepb.EngineType                                  `protobuf:"varint,3,opt,name=engine_type,json=engineType,proto3,enum=cockroach.storage.enginepb.EngineType" json:"engine_type,omitempty"`
}

func (m *EngineStatsInfo) Reset()         { *m = EngineStatsInfo{} }
func (m *EngineStatsInfo) String() string { return proto.CompactTextString(m) }
func (*EngineStatsInfo) ProtoMessage()    {}
func (*EngineStatsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{28}
}
func (m *EngineStatsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineStatsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EngineStatsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineStatsInfo.Merge(m, src)
}
func (m *EngineStatsInfo) XXX_Size() int {
	return m.Size()
}
func (m *EngineStatsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineStatsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EngineStatsInfo proto.InternalMessageInfo

type EngineStatsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *EngineStatsRequest) Reset()         { *m = EngineStatsRequest{} }
func (m *EngineStatsRequest) String() string { return proto.CompactTextString(m) }
func (*EngineStatsRequest) ProtoMessage()    {}
func (*EngineStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{29}
}
func (m *EngineStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EngineStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineStatsRequest.Merge(m, src)
}
func (m *EngineStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *EngineStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EngineStatsRequest proto.InternalMessageInfo

type EngineStatsResponse struct {
	Stats []EngineStatsInfo `protobuf:"bytes,1,rep,name=stats,proto3" json:"stats"`
}

func (m *EngineStatsResponse) Reset()         { *m = EngineStatsResponse{} }
func (m *EngineStatsResponse) String() string { return proto.CompactTextString(m) }
func (*EngineStatsResponse) ProtoMessage()    {}
func (*EngineStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{30}
}
func (m *EngineStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EngineStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineStatsResponse.Merge(m, src)
}
func (m *EngineStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *EngineStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EngineStatsResponse proto.InternalMessageInfo

type TraceEvent struct {
	Time    time.Time `protobuf:"bytes,1,opt,name=time,proto3,stdtime" json:"time"`
	Message string    `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TraceEvent) Reset()         { *m = TraceEvent{} }
func (m *TraceEvent) String() string { return proto.CompactTextString(m) }
func (*TraceEvent) ProtoMessage()    {}
func (*TraceEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{31}
}
func (m *TraceEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TraceEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceEvent.Merge(m, src)
}
func (m *TraceEvent) XXX_Size() int {
	return m.Size()
}
func (m *TraceEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceEvent.DiscardUnknown(m)
}

var xxx_messageInfo_TraceEvent proto.InternalMessageInfo

type AllocatorDryRun struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	Events  []*TraceEvent                                        `protobuf:"bytes,2,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *AllocatorDryRun) Reset()         { *m = AllocatorDryRun{} }
func (m *AllocatorDryRun) String() string { return proto.CompactTextString(m) }
func (*AllocatorDryRun) ProtoMessage()    {}
func (*AllocatorDryRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{32}
}
func (m *AllocatorDryRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorDryRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllocatorDryRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorDryRun.Merge(m, src)
}
func (m *AllocatorDryRun) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorDryRun) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorDryRun.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorDryRun proto.InternalMessageInfo

type AllocatorRangeRequest struct {
	RangeId int64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
}

func (m *AllocatorRangeRequest) Reset()         { *m = AllocatorRangeRequest{} }
func (m *AllocatorRangeRequest) String() string { return proto.CompactTextString(m) }
func (*AllocatorRangeRequest) ProtoMessage()    {}
func (*AllocatorRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{33}
}
func (m *AllocatorRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllocatorRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorRangeRequest.Merge(m, src)
}
func (m *AllocatorRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorRangeRequest proto.InternalMessageInfo

type AllocatorRangeResponse struct {
	// The NodeID of the store whose dry run is returned. Only the leaseholder
	// for a given range will do an allocator dry run for it.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	DryRun *AllocatorDryRun                                    `protobuf:"bytes,2,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (m *AllocatorRangeResponse) Reset()         { *m = AllocatorRangeResponse{} }
func (m *AllocatorRangeResponse) String() string { return proto.CompactTextString(m) }
func (*AllocatorRangeResponse) ProtoMessage()    {}
func (*AllocatorRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{34}
}
func (m *AllocatorRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllocatorRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorRangeResponse.Merge(m, src)
}
func (m *AllocatorRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorRangeResponse proto.InternalMessageInfo

type AllocatorRequest struct {
	NodeId   string                                                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RangeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,2,rep,packed,name=range_ids,json=rangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_ids,omitempty"`
}

func (m *AllocatorRequest) Reset()         { *m = AllocatorRequest{} }
func (m *AllocatorRequest) String() string { return proto.CompactTextString(m) }
func (*AllocatorRequest) ProtoMessage()    {}
func (*AllocatorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{35}
}
func (m *AllocatorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllocatorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorRequest.Merge(m, src)
}
func (m *AllocatorRequest) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorRequest proto.InternalMessageInfo

type AllocatorResponse struct {
	DryRuns []*AllocatorDryRun `protobuf:"bytes,1,rep,name=dry_runs,json=dryRuns,proto3" json:"dry_runs,omitempty"`
}

func (m *AllocatorResponse) Reset()         { *m = AllocatorResponse{} }
func (m *AllocatorResponse) String() string { return proto.CompactTextString(m) }
func (*AllocatorResponse) ProtoMessage()    {}
func (*AllocatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{36}
}
func (m *AllocatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllocatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorResponse.Merge(m, src)
}
func (m *AllocatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorResponse proto.InternalMessageInfo

type JSONResponse struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *JSONResponse) Reset()         { *m = JSONResponse{} }
func (m *JSONResponse) String() string { return proto.CompactTextString(m) }
func (*JSONResponse) ProtoMessage()    {}
func (*JSONResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{37}
}
func (m *JSONResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JSONResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JSONResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JSONResponse.Merge(m, src)
}
func (m *JSONResponse) XXX_Size() int {
	return m.Size()
}
func (m *JSONResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JSONResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JSONResponse proto.InternalMessageInfo

type ResponseError struct {
	Error   string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Code    int32    `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Message string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Details []string `protobuf:"bytes,4,rep,name=details,proto3" json:"details,omitempty"`
}

func (m *ResponseError) Reset()         { *m = ResponseError{} }
func (m *ResponseError) String() string { return proto.CompactTextString(m) }
func (*ResponseError) ProtoMessage()    {}
func (*ResponseError) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{38}
}
func (m *ResponseError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResponseError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseError.Merge(m, src)
}
func (m *ResponseError) XXX_Size() int {
	return m.Size()
}
func (m *ResponseError) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseError.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseError proto.InternalMessageInfo

type LogsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId    string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Level     string `protobuf:"bytes,2,opt,name=level,proto3" json:"level,omitempty"`
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	Max       string `protobuf:"bytes,5,opt,name=max,proto3" json:"max,omitempty"`
	Pattern   string `protobuf:"bytes,6,opt,name=pattern,proto3" json:"pattern,omitempty"`
	// redact, if true, requests redaction of sensitive data away
	// from the retrieved log entries.
	// Only admin users can send a request with redact = false.
	Redact bool `protobuf:"varint,7,opt,name=redact,proto3" json:"redact,omitempty"`
}

func (m *LogsRequest) Reset()         { *m = LogsRequest{} }
func (m *LogsRequest) String() string { return proto.CompactTextString(m) }
func (*LogsRequest) ProtoMessage()    {}
func (*LogsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{39}
}
func (m *LogsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsRequest.Merge(m, src)
}
func (m *LogsRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogsRequest proto.InternalMessageInfo

type LogEntriesResponse struct {
	Entries []logpb.Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries"`
}

func (m *LogEntriesResponse) Reset()         { *m = LogEntriesResponse{} }
func (m *LogEntriesResponse) String() string { return proto.CompactTextString(m) }
func (*LogEntriesResponse) ProtoMessage()    {}
func (*LogEntriesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{40}
}
func (m *LogEntriesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEntriesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogEntriesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntriesResponse.Merge(m, src)
}
func (m *LogEntriesResponse) XXX_Size() int {
	return m.Size()
}
func (m *LogEntriesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntriesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntriesResponse proto.InternalMessageInfo

type LogFilesListRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *LogFilesListRequest) Reset()         { *m = LogFilesListRequest{} }
func (m *LogFilesListRequest) String() string { return proto.CompactTextString(m) }
func (*LogFilesListRequest) ProtoMessage()    {}
func (*LogFilesListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{41}
}
func (m *LogFilesListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFilesListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogFilesListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFilesListRequest.Merge(m, src)
}
func (m *LogFilesListRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogFilesListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFilesListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogFilesListRequest proto.InternalMessageInfo

type LogFilesListResponse struct {
	// files is the list of log files under this node's configured logging
	// directories. Note that the response does not contain detail about
	// which directory contains which file. The location of each file
	// is known to the server based on its name and the logging configuration.
	Files []logpb.FileInfo `protobuf:"bytes,1,rep,name=files,proto3" json:"files"`
}

func (m *LogFilesListResponse) Reset()         { *m = LogFilesListResponse{} }
func (m *LogFilesListResponse) String() string { return proto.CompactTextString(m) }
func (*LogFilesListResponse) ProtoMessage()    {}
func (*LogFilesListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{42}
}
func (m *LogFilesListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFilesListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogFilesListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFilesListResponse.Merge(m, src)
}
func (m *LogFilesListResponse) XXX_Size() int {
	return m.Size()
}
func (m *LogFilesListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFilesListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogFilesListResponse proto.InternalMessageInfo

type LogFileRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// file is the name of the log file to retrieve. Note that it
	// must not be prefixed by a directory name. The full path to
	// the file is computed by the server based on the base name
	// and the logging configuration.
	File string `protobuf:"bytes,2,opt,name=file,proto3" json:"file,omitempty"`
	// redact, if true, requests redaction of sensitive data away
	// from the retrieved log entries.
	// Only admin users can send a request with redact = false.
	Redact bool `protobuf:"varint,3,opt,name=redact,proto3" json:"redact,omitempty"`
}

func (m *LogFileRequest) Reset()         { *m = LogFileRequest{} }
func (m *LogFileRequest) String() string { return proto.CompactTextString(m) }
func (*LogFileRequest) ProtoMessage()    {}
func (*LogFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{43}
}
func (m *LogFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFileRequest.Merge(m, src)
}
func (m *LogFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogFileRequest proto.InternalMessageInfo

type StacksRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string     `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Type   StacksType `protobuf:"varint,2,opt,name=type,proto3,enum=cockroach.server.serverpb.StacksType" json:"type,omitempty"`
}

func (m *StacksRequest) Reset()         { *m = StacksRequest{} }
func (m *StacksRequest) String() string { return proto.CompactTextString(m) }
func (*StacksRequest) ProtoMessage()    {}
func (*StacksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{44}
}
func (m *StacksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StacksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StacksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StacksRequest.Merge(m, src)
}
func (m *StacksRequest) XXX_Size() int {
	return m.Size()
}
func (m *StacksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StacksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StacksRequest proto.InternalMessageInfo

type File struct {
	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	FileSize int64  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	// Contents may not be populated if only a list of Files are requested.
	Contents []byte `protobuf:"bytes,3,opt,name=contents,proto3" json:"contents,omitempty"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{45}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

type GetFilesRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// If list_only is true then the contents of the files will not be populated
	// in the response. Only filenames and sizes will be returned.
	ListOnly bool     `protobuf:"varint,2,opt,name=list_only,json=listOnly,proto3" json:"list_only,omitempty"`
	Type     FileType `protobuf:"varint,5,opt,name=type,proto3,enum=cockroach.server.serverpb.FileType" json:"type,omitempty"`
	// Each pattern given is matched with Files of the above type in the node
	// using filepath.Glob(). The patterns only match to filenames and so path
	// separators cannot be used.
	// Example: * will match all files of requested type.
	Patterns []string `protobuf:"bytes,6,rep,name=patterns,proto3" json:"patterns,omitempty"`
}

func (m *GetFilesRequest) Reset()         { *m = GetFilesRequest{} }
func (m *GetFilesRequest) String() string { return proto.CompactTextString(m) }
func (*GetFilesRequest) ProtoMessage()    {}
func (*GetFilesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{46}
}
func (m *GetFilesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFilesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetFilesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFilesRequest.Merge(m, src)
}
func (m *GetFilesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFilesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFilesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFilesRequest proto.InternalMessageInfo

type GetFilesResponse struct {
	Files []*File `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
}

func (m *GetFilesResponse) Reset()         { *m = GetFilesResponse{} }
func (m *GetFilesResponse) String() string { return proto.CompactTextString(m) }
func (*GetFilesResponse) ProtoMessage()    {}
func (*GetFilesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{47}
}
func (m *GetFilesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFilesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetFilesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFilesResponse.Merge(m, src)
}
func (m *GetFilesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetFilesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFilesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetFilesResponse proto.InternalMessageInfo

type ProfileRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The type of profile to retrieve.
	Type    ProfileRequest_Type `protobuf:"varint,5,opt,name=type,proto3,enum=cockroach.server.serverpb.ProfileRequest_Type" json:"type,omitempty"`
	Seconds int32               `protobuf:"varint,6,opt,name=seconds,proto3" json:"seconds,omitempty"`
	Labels  bool                `protobuf:"varint,7,opt,name=labels,proto3" json:"labels,omitempty"`
}

func (m *ProfileRequest) Reset()         { *m = ProfileRequest{} }
func (m *ProfileRequest) String() string { return proto.CompactTextString(m) }
func (*ProfileRequest) ProtoMessage()    {}
func (*ProfileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{48}
}
func (m *ProfileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProfileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfileRequest.Merge(m, src)
}
func (m *ProfileRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProfileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProfileRequest proto.InternalMessageInfo

type MetricsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *MetricsRequest) Reset()         { *m = MetricsRequest{} }
func (m *MetricsRequest) String() string { return proto.CompactTextString(m) }
func (*MetricsRequest) ProtoMessage()    {}
func (*MetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{49}
}
func (m *MetricsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsRequest.Merge(m, src)
}
func (m *MetricsRequest) XXX_Size() int {
	return m.Size()
}
func (m *MetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsRequest proto.InternalMessageInfo

type RaftRangeNode struct {
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	Range  RangeInfo                                           `protobuf:"bytes,2,opt,name=range,proto3" json:"range"`
}

func (m *RaftRangeNode) Reset()         { *m = RaftRangeNode{} }
func (m *RaftRangeNode) String() string { return proto.CompactTextString(m) }
func (*RaftRangeNode) ProtoMessage()    {}
func (*RaftRangeNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{50}
}
func (m *RaftRangeNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRangeNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftRangeNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRangeNode.Merge(m, src)
}
func (m *RaftRangeNode) XXX_Size() int {
	return m.Size()
}
func (m *RaftRangeNode) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRangeNode.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRangeNode proto.InternalMessageInfo

type RaftRangeError struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RaftRangeError) Reset()         { *m = RaftRangeError{} }
func (m *RaftRangeError) String() string { return proto.CompactTextString(m) }
func (*RaftRangeError) ProtoMessage()    {}
func (*RaftRangeError) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{51}
}
func (m *RaftRangeError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRangeError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftRangeError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRangeError.Merge(m, src)
}
func (m *RaftRangeError) XXX_Size() int {
	return m.Size()
}
func (m *RaftRangeError) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRangeError.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRangeError proto.InternalMessageInfo

type RaftRangeStatus struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	Errors  []RaftRangeError                                     `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors"`
	Nodes   []RaftRangeNode                                      `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes"`
}

func (m *RaftRangeStatus) Reset()         { *m = RaftRangeStatus{} }
func (m *RaftRangeStatus) String() string { return proto.CompactTextString(m) }
func (*RaftRangeStatus) ProtoMessage()    {}
func (*RaftRangeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{52}
}
func (m *RaftRangeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRangeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftRangeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRangeStatus.Merge(m, src)
}
func (m *RaftRangeStatus) XXX_Size() int {
	return m.Size()
}
func (m *RaftRangeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRangeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRangeStatus proto.InternalMessageInfo

type RaftDebugRequest struct {
	RangeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,rep,packed,name=range_ids,json=rangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_ids,omitempty"`
}

func (m *RaftDebugRequest) Reset()         { *m = RaftDebugRequest{} }
func (m *RaftDebugRequest) String() string { return proto.CompactTextString(m) }
func (*RaftDebugRequest) ProtoMessage()    {}
func (*RaftDebugRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{53}
}
func (m *RaftDebugRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftDebugRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftDebugRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftDebugRequest.Merge(m, src)
}
func (m *RaftDebugRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftDebugRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftDebugRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftDebugRequest proto.InternalMessageInfo

type RaftDebugResponse struct {
	Ranges map[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID]RaftRangeStatus `protobuf:"bytes,1,rep,name=ranges,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"ranges" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Errors []RaftRangeError                                                         `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors"`
}

func (m *RaftDebugResponse) Reset()         { *m = RaftDebugResponse{} }
func (m *RaftDebugResponse) String() string { return proto.CompactTextString(m) }
func (*RaftDebugResponse) ProtoMessage()    {}
func (*RaftDebugResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{54}
}
func (m *RaftDebugResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftDebugResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftDebugResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftDebugResponse.Merge(m, src)
}
func (m *RaftDebugResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftDebugResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftDebugResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftDebugResponse proto.InternalMessageInfo

// TxnInfo represents an in flight user transaction on some Session.
type TxnInfo struct {
	ID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"id"`
	// The start timestamp of the transaction.
	Start time.Time `protobuf:"bytes,2,opt,name=start,proto3,stdtime" json:"start"`
	// txn_description is a text description of the underlying kv.Txn, intended
	// for troubleshooting purposes.
	TxnDescription string `protobuf:"bytes,3,opt,name=txn_description,json=txnDescription,proto3" json:"txn_description,omitempty"`
	// num_statements_executed is the number of statements that were executed so
	// far on this transaction.
	NumStatementsExecuted int32 `protobuf:"varint,4,opt,name=num_statements_executed,json=numStatementsExecuted,proto3" json:"num_statements_executed,omitempty"`
	// num_retries is the number of times that this transaction was retried.
	NumRetries int32 `protobuf:"varint,5,opt,name=num_retries,json=numRetries,proto3" json:"num_retries,omitempty"`
	// num_retries is the number of times that this transaction was automatically
	// retried by the SQL executor.
	NumAutoRetries int32 `protobuf:"varint,6,opt,name=num_auto_retries,json=numAutoRetries,proto3" json:"num_auto_retries,omitempty"`
	// The deadline by which the transaction must be committed.
	Deadline time.Time `protobuf:"bytes,7,opt,name=deadline,proto3,stdtime" json:"deadline"`
	// implicit is true if this transaction was an implicit SQL transaction.
	Implicit bool `protobuf:"varint,8,opt,name=implicit,proto3" json:"implicit,omitempty"`
	// Number of currently allocated bytes in the txn memory monitor.
	AllocBytes int64 `protobuf:"varint,9,opt,name=alloc_bytes,json=allocBytes,proto3" json:"alloc_bytes,omitempty"`
	// High water mark of allocated bytes in the txn memory monitor.
	MaxAllocBytes int64  `protobuf:"varint,10,opt,name=max_alloc_bytes,json=maxAllocBytes,proto3" json:"max_alloc_bytes,omitempty"`
	ReadOnly      bool   `protobuf:"varint,11,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	IsHistorical  bool   `protobuf:"varint,12,opt,name=is_historical,json=isHistorical,proto3" json:"is_historical,omitempty"`
	Priority      string `protobuf:"bytes,13,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *TxnInfo) Reset()         { *m = TxnInfo{} }
func (m *TxnInfo) String() string { return proto.CompactTextString(m) }
func (*TxnInfo) ProtoMessage()    {}
func (*TxnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{55}
}
func (m *TxnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TxnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnInfo.Merge(m, src)
}
func (m *TxnInfo) XXX_Size() int {
	return m.Size()
}
func (m *TxnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TxnInfo proto.InternalMessageInfo

// ActiveQuery represents a query in flight on some Session.
type ActiveQuery struct {
	// ID of the query (uint128 presented as a hexadecimal string).
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The UUID of the transaction this query is running in.
	TxnID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,7,opt,name=txn_id,json=txnId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"txn_id"`
	// SQL query string specified by the user.
	Sql string `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
	// Start timestamp of this query.
	Start time.Time `protobuf:"bytes,3,opt,name=start,proto3,stdtime" json:"start"`
	// True if this query is distributed.
	IsDistributed bool `protobuf:"varint,4,opt,name=is_distributed,json=isDistributed,proto3" json:"is_distributed,omitempty"`
	// phase stores the current phase of execution for this query.
	Phase ActiveQuery_Phase `protobuf:"varint,5,opt,name=phase,proto3,enum=cockroach.server.serverpb.ActiveQuery_Phase" json:"phase,omitempty"`
	// progress is an estimate of the fraction of this query that has been
	// processed.
	Progress float32 `protobuf:"fixed32,6,opt,name=progress,proto3" json:"progress,omitempty"`
	// The SQL statement fingerprint, compatible with StatementStatisticsKey.
	SqlNoConstants string `protobuf:"bytes,8,opt,name=sql_no_constants,json=sqlNoConstants,proto3" json:"sql_no_constants,omitempty"`
	// A summarized version of the sql query.
	SqlSummary string `protobuf:"bytes,9,opt,name=sql_summary,json=sqlSummary,proto3" json:"sql_summary,omitempty"`
}

func (m *ActiveQuery) Reset()         { *m = ActiveQuery{} }
func (m *ActiveQuery) String() string { return proto.CompactTextString(m) }
func (*ActiveQuery) ProtoMessage()    {}
func (*ActiveQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{56}
}
func (m *ActiveQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ActiveQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveQuery.Merge(m, src)
}
func (m *ActiveQuery) XXX_Size() int {
	return m.Size()
}
func (m *ActiveQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveQuery proto.InternalMessageInfo

// Request object for ListSessions and ListLocalSessions.
type ListSessionsRequest struct {
	// Username of the user making this request.
	// The caller is responsible to normalize the username
	// (= case fold and perform unicode NFC normalization).
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *ListSessionsRequest) Reset()         { *m = ListSessionsRequest{} }
func (m *ListSessionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListSessionsRequest) ProtoMessage()    {}
func (*ListSessionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{57}
}
func (m *ListSessionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSessionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListSessionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSessionsRequest.Merge(m, src)
}
func (m *ListSessionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListSessionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSessionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSessionsRequest proto.InternalMessageInfo

// Session represents one SQL session.
type Session struct {
	// ID of node where this session exists.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// Username of the user for this session.
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// Connected client's IP address and port.
	ClientAddress string `protobuf:"bytes,3,opt,name=client_address,json=clientAddress,proto3" json:"client_address,omitempty"`
	// Application name specified by the client.
	ApplicationName string `protobuf:"bytes,4,opt,name=application_name,json=applicationName,proto3" json:"application_name,omitempty"`
	// Queries in progress on this session.
	ActiveQueries []ActiveQuery `protobuf:"bytes,5,rep,name=active_queries,json=activeQueries,proto3" json:"active_queries"`
	// Timestamp of session's start.
	Start time.Time `protobuf:"bytes,6,opt,name=start,proto3,stdtime" json:"start"`
	// SQL string of the last query executed on this session.
	LastActiveQuery string `protobuf:"bytes,8,opt,name=last_active_query,json=lastActiveQuery,proto3" json:"last_active_query,omitempty"`
	// ID of the session (uint128 represented as raw bytes).
	ID []byte `protobuf:"bytes,9,opt,name=id,proto3" json:"id,omitempty"`
	// Number of currently allocated bytes in the session memory monitor.
	AllocBytes int64 `protobuf:"varint,10,opt,name=alloc_bytes,json=allocBytes,proto3" json:"alloc_bytes,omitempty"`
	// High water mark of allocated bytes in the session memory monitor.
	MaxAllocBytes int64 `protobuf:"varint,11,opt,name=max_alloc_bytes,json=maxAllocBytes,proto3" json:"max_alloc_bytes,omitempty"`
	// Information about the txn in progress on this session. Nil if the
	// session doesn't currently have a transaction.
	ActiveTxn *TxnInfo `protobuf:"bytes,12,opt,name=active_txn,json=activeTxn,proto3" json:"active_txn,omitempty"`
	// The SQL statement fingerprint of the last query executed on this session,
	// compatible with StatementStatisticsKey.
	LastActiveQueryNoConstants string `protobuf:"bytes,13,opt,name=last_active_query_no_constants,json=lastActiveQueryNoConstants,proto3" json:"last_active_query_no_constants,omitempty"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{58}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

// An error wrapper object for ListSessionsResponse.
type ListSessionsError struct {
	// ID of node that was being contacted when this error occurred
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// Error message.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ListSessionsError) Reset()         { *m = ListSessionsError{} }
func (m *ListSessionsError) String() string { return proto.CompactTextString(m) }
func (*ListSessionsError) ProtoMessage()    {}
func (*ListSessionsError) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{59}
}
func (m *ListSessionsError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSessionsError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListSessionsError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSessionsError.Merge(m, src)
}
func (m *ListSessionsError) XXX_Size() int {
	return m.Size()
}
func (m *ListSessionsError) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSessionsError.DiscardUnknown(m)
}

var xxx_messageInfo_ListSessionsError proto.InternalMessageInfo

// Response object for ListSessions and ListLocalSessions.
type ListSessionsResponse struct {
	// A list of sessions on this node or cluster.
	Sessions []Session `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions"`
	// Any errors that occurred during fan-out calls to other nodes.
	Errors []ListSessionsError `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors"`
}

func (m *ListSessionsResponse) Reset()         { *m = ListSessionsResponse{} }
func (m *ListSessionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListSessionsResponse) ProtoMessage()    {}
func (*ListSessionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{60}
}
func (m *ListSessionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSessionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListSessionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSessionsResponse.Merge(m, src)
}
func (m *ListSessionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListSessionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSessionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSessionsResponse proto.InternalMessageInfo

// Request object for issuing a query cancel request.
type CancelQueryRequest struct {
	// ID of gateway node for the query to be canceled.
	//
	// TODO(itsbilal): use [(gogoproto.customname) = "NodeID"] below. Need to
	// figure out how to teach grpc-gateway about custom names.
	//
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// ID of query to be canceled (converted to string).
	QueryID string `protobuf:"bytes,2,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	// Username of the user making this cancellation request. This may be omitted
	// if the user is the same as the one issuing the CancelQueryRequest.
	// The caller is responsible for case-folding and NFC normalization.
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *CancelQueryRequest) Reset()         { *m = CancelQueryRequest{} }
func (m *CancelQueryRequest) String() string { return proto.CompactTextString(m) }
func (*CancelQueryRequest) ProtoMessage()    {}
func (*CancelQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{61}
}
func (m *CancelQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CancelQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelQueryRequest.Merge(m, src)
}
func (m *CancelQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *CancelQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelQueryRequest proto.InternalMessageInfo

// Response returned by target query's gateway node.
type CancelQueryResponse struct {
	// Whether the cancellation request succeeded and the query was canceled.
	Canceled bool `protobuf:"varint,1,opt,name=canceled,proto3" json:"canceled,omitempty"`
	// Error message (accompanied with canceled = false).
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *CancelQueryResponse) Reset()         { *m = CancelQueryResponse{} }
func (m *CancelQueryResponse) String() string { return proto.CompactTextString(m) }
func (*CancelQueryResponse) ProtoMessage()    {}
func (*CancelQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{62}
}
func (m *CancelQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CancelQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelQueryResponse.Merge(m, src)
}
func (m *CancelQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *CancelQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelQueryResponse proto.InternalMessageInfo

type CancelSessionRequest struct {
	// TODO(abhimadan): use [(gogoproto.customname) = "NodeID"] below. Need to
	// figure out how to teach grpc-gateway about custom names.
	//
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId    string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	SessionID []byte `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Username of the user making this cancellation request. This may be omitted
	// if the user is the same as the one issuing the CancelSessionRequest.
	// The caller is responsiblef or case-folding and NFC normalization.
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *CancelSessionRequest) Reset()         { *m = CancelSessionRequest{} }
func (m *CancelSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CancelSessionRequest) ProtoMessage()    {}
func (*CancelSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{63}
}
func (m *CancelSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CancelSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelSessionRequest.Merge(m, src)
}
func (m *CancelSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CancelSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelSessionRequest proto.InternalMessageInfo

type CancelSessionResponse struct {
	Canceled bool   `protobuf:"varint,1,opt,name=canceled,proto3" json:"canceled,omitempty"`
	Error    string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *CancelSessionResponse) Reset()         { *m = CancelSessionResponse{} }
func (m *CancelSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CancelSessionResponse) ProtoMessage()    {}
func (*CancelSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{64}
}
func (m *CancelSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CancelSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelSessionResponse.Merge(m, src)
}
func (m *CancelSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CancelSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelSessionResponse proto.InternalMessageInfo

// Request object for ListContentionEvents and ListLocalContentionEvents.
type ListContentionEventsRequest struct {
}

func (m *ListContentionEventsRequest) Reset()         { *m = ListContentionEventsRequest{} }
func (m *ListContentionEventsRequest) String() string { return proto.CompactTextString(m) }
func (*ListContentionEventsRequest) ProtoMessage()    {}
func (*ListContentionEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{65}
}
func (m *ListContentionEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListContentionEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListContentionEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListContentionEventsRequest.Merge(m, src)
}
func (m *ListContentionEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListContentionEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListContentionEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListContentionEventsRequest proto.InternalMessageInfo

// An error wrapper object for ListContentionEventsResponse and
// ListDistSQLFlowsResponse. Similar to the Statements endpoint, when
// implemented on a tenant, the `node_id` field refers to the instanceIDs that
// identify individual tenant pods.
type ListActivityError struct {
	// ID of node that was being contacted when this error occurred.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// Error message.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ListActivityError) Reset()         { *m = ListActivityError{} }
func (m *ListActivityError) String() string { return proto.CompactTextString(m) }
func (*ListActivityError) ProtoMessage()    {}
func (*ListActivityError) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{66}
}
func (m *ListActivityError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListActivityError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListActivityError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListActivityError.Merge(m, src)
}
func (m *ListActivityError) XXX_Size() int {
	return m.Size()
}
func (m *ListActivityError) XXX_DiscardUnknown() {
	xxx_messageInfo_ListActivityError.DiscardUnknown(m)
}

var xxx_messageInfo_ListActivityError proto.InternalMessageInfo

// Response object for ListContentionEvents and ListLocalContentionEvents.
type ListContentionEventsResponse struct {
	// All available contention information on this node or cluster.
	Events contentionpb.SerializedRegistry `protobuf:"bytes,1,opt,name=events,proto3" json:"events"`
	// Any errors that occurred during fan-out calls to other nodes.
	Errors []ListActivityError `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors"`
}

func (m *ListContentionEventsResponse) Reset()         { *m = ListContentionEventsResponse{} }
func (m *ListContentionEventsResponse) String() string { return proto.CompactTextString(m) }
func (*ListContentionEventsResponse) ProtoMessage()    {}
func (*ListContentionEventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{67}
}
func (m *ListContentionEventsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListContentionEventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListContentionEventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListContentionEventsResponse.Merge(m, src)
}
func (m *ListContentionEventsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListContentionEventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListContentionEventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListContentionEventsResponse proto.InternalMessageInfo

// Request object for ListDistSQLFlows and ListLocalDistSQLFlows.
type ListDistSQLFlowsRequest struct {
}

func (m *ListDistSQLFlowsRequest) Reset()         { *m = ListDistSQLFlowsRequest{} }
func (m *ListDistSQLFlowsRequest) String() string { return proto.CompactTextString(m) }
func (*ListDistSQLFlowsRequest) ProtoMessage()    {}
func (*ListDistSQLFlowsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{68}
}
func (m *ListDistSQLFlowsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDistSQLFlowsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListDistSQLFlowsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDistSQLFlowsRequest.Merge(m, src)
}
func (m *ListDistSQLFlowsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListDistSQLFlowsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDistSQLFlowsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDistSQLFlowsRequest proto.InternalMessageInfo

// DistSQLRemoteFlows describes all DistSQL remote flows that are part of the
// same physical plan. The gateway node that initiated the execution of the plan
// isn't included.
type DistSQLRemoteFlows struct {
	// FlowID is the unique identifier of the physical plan shared by all remote
	// flows.
	FlowID github_com_cockroachdb_cockroach_pkg_sql_execinfrapb.FlowID `protobuf:"bytes,1,opt,name=flow_id,json=flowId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/sql/execinfrapb.FlowID" json:"flow_id"`
	// Infos contains the information about all remote flows that are part of this
	// DistSQL physical plan and that haven't finished yet.
	//
	// The slice doesn't contain duplicate NodeIDs and is sorted by NodeID in ASC
	// order.
	Infos []DistSQLRemoteFlows_Info `protobuf:"bytes,2,rep,name=infos,proto3" json:"infos"`
}

func (m *DistSQLRemoteFlows) Reset()         { *m = DistSQLRemoteFlows{} }
func (m *DistSQLRemoteFlows) String() string { return proto.CompactTextString(m) }
func (*DistSQLRemoteFlows) ProtoMessage()    {}
func (*DistSQLRemoteFlows) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{69}
}
func (m *DistSQLRemoteFlows) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistSQLRemoteFlows) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DistSQLRemoteFlows) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistSQLRemoteFlows.Merge(m, src)
}
func (m *DistSQLRemoteFlows) XXX_Size() int {
	return m.Size()
}
func (m *DistSQLRemoteFlows) XXX_DiscardUnknown() {
	xxx_messageInfo_DistSQLRemoteFlows.DiscardUnknown(m)
}

var xxx_messageInfo_DistSQLRemoteFlows proto.InternalMessageInfo

// Info contains an information about a single DistSQL remote flow.
type DistSQLRemoteFlows_Info struct {
	// NodeID is the node on which this remote flow is either running or queued.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// Timestamp must be in the UTC timezone.
	Timestamp time.Time `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Status is the current status of this remote flow.
	Status DistSQLRemoteFlows_Status `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.server.serverpb.DistSQLRemoteFlows_Status" json:"status,omitempty"`
	// Stmt is the SQL statement for which this flow is executing.
	Stmt string `protobuf:"bytes,4,opt,name=stmt,proto3" json:"stmt,omitempty"`
}

func (m *DistSQLRemoteFlows_Info) Reset()         { *m = DistSQLRemoteFlows_Info{} }
func (m *DistSQLRemoteFlows_Info) String() string { return proto.CompactTextString(m) }
func (*DistSQLRemoteFlows_Info) ProtoMessage()    {}
func (*DistSQLRemoteFlows_Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{69, 0}
}
func (m *DistSQLRemoteFlows_Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistSQLRemoteFlows_Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DistSQLRemoteFlows_Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistSQLRemoteFlows_Info.Merge(m, src)
}
func (m *DistSQLRemoteFlows_Info) XXX_Size() int {
	return m.Size()
}
func (m *DistSQLRemoteFlows_Info) XXX_DiscardUnknown() {
	xxx_messageInfo_DistSQLRemoteFlows_Info.DiscardUnknown(m)
}

var xxx_messageInfo_DistSQLRemoteFlows_Info proto.InternalMessageInfo

// Response object for ListDistSQLFlows and ListLocalDistSQLFlows.
type ListDistSQLFlowsResponse struct {
	// Flows are ordered by FlowID lexicographically and do not contain
	// duplicates.
	Flows []DistSQLRemoteFlows `protobuf:"bytes,1,rep,name=flows,proto3" json:"flows"`
	// Any errors that occurred during fan-out calls to other nodes.
	Errors []ListActivityError `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors"`
}

func (m *ListDistSQLFlowsResponse) Reset()         { *m = ListDistSQLFlowsResponse{} }
func (m *ListDistSQLFlowsResponse) String() string { return proto.CompactTextString(m) }
func (*ListDistSQLFlowsResponse) ProtoMessage()    {}
func (*ListDistSQLFlowsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{70}
}
func (m *ListDistSQLFlowsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDistSQLFlowsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListDistSQLFlowsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDistSQLFlowsResponse.Merge(m, src)
}
func (m *ListDistSQLFlowsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListDistSQLFlowsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDistSQLFlowsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListDistSQLFlowsResponse proto.InternalMessageInfo

type SpanStatsRequest struct {
	NodeID   string                                            `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	StartKey github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"start_key,omitempty"`
	EndKey   github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"end_key,omitempty"`
}

func (m *SpanStatsRequest) Reset()         { *m = SpanStatsRequest{} }
func (m *SpanStatsRequest) String() string { return proto.CompactTextString(m) }
func (*SpanStatsRequest) ProtoMessage()    {}
func (*SpanStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{71}
}
func (m *SpanStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanStatsRequest.Merge(m, src)
}
func (m *SpanStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanStatsRequest proto.InternalMessageInfo

type SpanStatsResponse struct {
	RangeCount           int32              `protobuf:"varint,2,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
	ApproximateDiskBytes uint64             `protobuf:"varint,3,opt,name=approximate_disk_bytes,json=approximateDiskBytes,proto3" json:"approximate_disk_bytes,omitempty"`
	TotalStats           enginepb.MVCCStats `protobuf:"bytes,1,opt,name=total_stats,json=totalStats,proto3" json:"total_stats"`
}

func (m *SpanStatsResponse) Reset()         { *m = SpanStatsResponse{} }
func (m *SpanStatsResponse) String() string { return proto.CompactTextString(m) }
func (*SpanStatsResponse) ProtoMessage()    {}
func (*SpanStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{72}
}
func (m *SpanStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanStatsResponse.Merge(m, src)
}
func (m *SpanStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanStatsResponse proto.InternalMessageInfo

type ProblemRangesRequest struct {
	// If left empty, problem ranges for all nodes/stores will be returned.
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *ProblemRangesRequest) Reset()         { *m = ProblemRangesRequest{} }
func (m *ProblemRangesRequest) String() string { return proto.CompactTextString(m) }
func (*ProblemRangesRequest) ProtoMessage()    {}
func (*ProblemRangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{73}
}
func (m *ProblemRangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProblemRangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProblemRangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProblemRangesRequest.Merge(m, src)
}
func (m *ProblemRangesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProblemRangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProblemRangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProblemRangesRequest proto.InternalMessageInfo

type ProblemRangesResponse struct {
	// NodeID is the node that submitted all the requests.
	NodeID           github_com_cockroachdb_cockroach_pkg_roachpb.NodeID                                        `protobuf:"varint,8,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	ProblemsByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]ProblemRangesResponse_NodeProblems `protobuf:"bytes,9,rep,name=problems_by_node_id,json=problemsByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"problems_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ProblemRangesResponse) Reset()         { *m = ProblemRangesResponse{} }
func (m *ProblemRangesResponse) String() string { return proto.CompactTextString(m) }
func (*ProblemRangesResponse) ProtoMessage()    {}
func (*ProblemRangesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{74}
}
func (m *ProblemRangesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProblemRangesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProblemRangesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProblemRangesResponse.Merge(m, src)
}
func (m *ProblemRangesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProblemRangesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProblemRangesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProblemRangesResponse proto.InternalMessageInfo

type ProblemRangesResponse_NodeProblems struct {
	ErrorMessage                     string                                                 `protobuf:"bytes,1,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	UnavailableRangeIDs              []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,2,rep,packed,name=unavailable_range_ids,json=unavailableRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"unavailable_range_ids,omitempty"`
	RaftLeaderNotLeaseHolderRangeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,3,rep,packed,name=raft_leader_not_lease_holder_range_ids,json=raftLeaderNotLeaseHolderRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"raft_leader_not_lease_holder_range_ids,omitempty"`
	NoRaftLeaderRangeIDs             []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,4,rep,packed,name=no_raft_leader_range_ids,json=noRaftLeaderRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"no_raft_leader_range_ids,omitempty"`
	NoLeaseRangeIDs                  []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,5,rep,packed,name=no_lease_range_ids,json=noLeaseRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"no_lease_range_ids,omitempty"`
	UnderreplicatedRangeIDs          []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,6,rep,packed,name=underreplicated_range_ids,json=underreplicatedRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"underreplicated_range_ids,omitempty"`
	OverreplicatedRangeIDs           []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,9,rep,packed,name=overreplicated_range_ids,json=overreplicatedRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"overreplicated_range_ids,omitempty"`
	QuiescentEqualsTickingRangeIDs   []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,7,rep,packed,name=quiescent_equals_ticking_range_ids,json=quiescentEqualsTickingRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"quiescent_equals_ticking_range_ids,omitempty"`
	RaftLogTooLargeRangeIDs          []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,8,rep,packed,name=raft_log_too_large_range_ids,json=raftLogTooLargeRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"raft_log_too_large_range_ids,omitempty"`
}

func (m *ProblemRangesResponse_NodeProblems) Reset()         { *m = ProblemRangesResponse_NodeProblems{} }
func (m *ProblemRangesResponse_NodeProblems) String() string { return proto.CompactTextString(m) }
func (*ProblemRangesResponse_NodeProblems) ProtoMessage()    {}
func (*ProblemRangesResponse_NodeProblems) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{74, 0}
}
func (m *ProblemRangesResponse_NodeProblems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProblemRangesResponse_NodeProblems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProblemRangesResponse_NodeProblems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProblemRangesResponse_NodeProblems.Merge(m, src)
}
func (m *ProblemRangesResponse_NodeProblems) XXX_Size() int {
	return m.Size()
}
func (m *ProblemRangesResponse_NodeProblems) XXX_DiscardUnknown() {
	xxx_messageInfo_ProblemRangesResponse_NodeProblems.DiscardUnknown(m)
}

var xxx_messageInfo_ProblemRangesResponse_NodeProblems proto.InternalMessageInfo

// HotRangesRequest queries one or more cluster nodes for a list
// of ranges currently considered hot by the node(s).
// API: PUBLIC ALPHA
type HotRangesRequest struct {
	// NodeID indicates which node to query for a hot range report.
	// It is possible to populate any node ID; if the node receiving
	// the request is not the target node, it will forward the
	// request to the target node.
	//
	// If left empty, the request is forwarded to every node
	// in the cluster.
	// API: PUBLIC ALPHA
	NodeID    string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	PageSize  int32  `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (m *HotRangesRequest) Reset()         { *m = HotRangesRequest{} }
func (m *HotRangesRequest) String() string { return proto.CompactTextString(m) }
func (*HotRangesRequest) ProtoMessage()    {}
func (*HotRangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{75}
}
func (m *HotRangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HotRangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesRequest.Merge(m, src)
}
func (m *HotRangesRequest) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesRequest proto.InternalMessageInfo

// HotRangesResponse is the payload produced in response
// to a HotRangesRequest.
// API: PUBLIC ALPHA
type HotRangesResponse struct {
	// NodeID is the node that received the HotRangesRequest and
	// forwarded requests to the selected target node(s).
	// API: PUBLIC ALPHA
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// HotRangesByNodeID contains a hot range report for each selected
	// target node ID in the HotRangesRequest.
	// API: PUBLIC ALPHA
	HotRangesByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]HotRangesResponse_NodeResponse `protobuf:"bytes,2,rep,name=hot_ranges_by_node_id,json=hotRangesByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"hot_ranges_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *HotRangesResponse) Reset()         { *m = HotRangesResponse{} }
func (m *HotRangesResponse) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponse) ProtoMessage()    {}
func (*HotRangesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{76}
}
func (m *HotRangesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HotRangesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponse.Merge(m, src)
}
func (m *HotRangesResponse) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponse proto.InternalMessageInfo

// HotRange is a hot range report for a single store on one of the
// target node(s) selected in a HotRangesRequest.
// API: PUBLIC ALPHA
type HotRangesResponse_HotRange struct {
	// Desc is the descriptor of the range for which the report
	// was produced.
	//
	// TODO(knz): This field should be removed.
	// See: https://github.com/cockroachdb/cockroach/issues/53212
	Desc roachpb.RangeDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc"`
	// QueriesPerSecond is the recent number of queries per second
	// on this range.
	// API: PUBLIC ALPHA
	QueriesPerSecond float64 `protobuf:"fixed64,2,opt,name=queries_per_second,json=queriesPerSecond,proto3" json:"queries_per_second,omitempty"`
	// LeaseholderNodeID indicates the Node ID that is the current leaseholder for the given range.
	LeaseholderNodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,3,opt,name=leaseholder_node_id,json=leaseholderNodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"leaseholder_node_id,omitempty"`
}

func (m *HotRangesResponse_HotRange) Reset()         { *m = HotRangesResponse_HotRange{} }
func (m *HotRangesResponse_HotRange) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponse_HotRange) ProtoMessage()    {}
func (*HotRangesResponse_HotRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{76, 0}
}
func (m *HotRangesResponse_HotRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponse_HotRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HotRangesResponse_HotRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponse_HotRange.Merge(m, src)
}
func (m *HotRangesResponse_HotRange) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponse_HotRange) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponse_HotRange.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponse_HotRange proto.InternalMessageInfo

// StoreResponse contains the part of a hot ranges report that
// pertains to a single store on a target node.
// API: PUBLIC ALPHA
type HotRangesResponse_StoreResponse struct {
	// StoreID identifies the store for which the report was
	// produced.
	// API: PUBLIC ALPHA
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	// HotRanges is the hot ranges report for this store
	// on the target node.
	// API: PUBLIC ALPHA
	HotRanges []HotRangesResponse_HotRange `protobuf:"bytes,2,rep,name=hot_ranges,json=hotRanges,proto3" json:"hot_ranges"`
}

func (m *HotRangesResponse_StoreResponse) Reset()         { *m = HotRangesResponse_StoreResponse{} }
func (m *HotRangesResponse_StoreResponse) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponse_StoreResponse) ProtoMessage()    {}
func (*HotRangesResponse_StoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{76, 1}
}
func (m *HotRangesResponse_StoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponse_StoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HotRangesResponse_StoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponse_StoreResponse.Merge(m, src)
}
func (m *HotRangesResponse_StoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponse_StoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponse_StoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponse_StoreResponse proto.InternalMessageInfo

// NodeResponse is a hot range report for a single target node.
// API: PUBLIC ALPHA
type HotRangesResponse_NodeResponse struct {
	// ErrorMessage is set to a non-empty string if this target
	// node was unable to produce a hot range report.
	//
	// The contents of this string indicates the cause of the failure.
	// API: PUBLIC ALPHA
	ErrorMessage string `protobuf:"bytes,1,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Stores contains the hot ranges report if no error was encountered.
	// There is one part to the report for each store in the
	// target node.
	// API: PUBLIC ALPHA
	Stores []*HotRangesResponse_StoreResponse `protobuf:"bytes,2,rep,name=stores,proto3" json:"stores,omitempty"`
}

func (m *HotRangesResponse_NodeResponse) Reset()         { *m = HotRangesResponse_NodeResponse{} }
func (m *HotRangesResponse_NodeResponse) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponse_NodeResponse) ProtoMessage()    {}
func (*HotRangesResponse_NodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{76, 2}
}
func (m *HotRangesResponse_NodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponse_NodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HotRangesResponse_NodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponse_NodeResponse.Merge(m, src)
}
func (m *HotRangesResponse_NodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponse_NodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponse_NodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponse_NodeResponse proto.InternalMessageInfo

// HotRangesResponseV2 is a response payload returned by `HotRangesV2` service.
type HotRangesResponseV2 struct {
	// Ranges contain list of hot ranges info that has highest number of QPS.
	Ranges []*HotRangesResponseV2_HotRange `protobuf:"bytes,1,rep,name=ranges,proto3" json:"ranges,omitempty"`
	// errors contains any errors that occurred during fan-out calls to other nodes.
	ErrorsByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]string `protobuf:"bytes,2,rep,name=errors_by_node_id,json=errorsByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"errors_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// NextPageToken represents next pagination token to request next slice of data.
	NextPageToken string `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *HotRangesResponseV2) Reset()         { *m = HotRangesResponseV2{} }
func (m *HotRangesResponseV2) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponseV2) ProtoMessage()    {}
func (*HotRangesResponseV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{77}
}
func (m *HotRangesResponseV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponseV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HotRangesResponseV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponseV2.Merge(m, src)
}
func (m *HotRangesResponseV2) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponseV2) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponseV2.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponseV2 proto.InternalMessageInfo

// HotRange message describes a single hot range, ie its QPS, node ID it belongs to, etc.
type HotRangesResponseV2_HotRange struct {
	// range_id indicates Range ID that's identified as hot range.
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// node_id indicates the node that contains the current hot range.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// qps (queries per second) shows the amount of queries that interact with current range.
	QPS float64 `protobuf:"fixed64,3,opt,name=qps,proto3" json:"qps,omitempty"`
	// table_name indicates the SQL table that the range belongs to.
	TableName string `protobuf:"bytes,4,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// database_name indicates on database that has current hot range.
	DatabaseName string `protobuf:"bytes,5,opt,name=database_name,json=databaseName,proto3" json:"database_name,omitempty"`
	// index_name indicates the index name for current range.
	IndexName string `protobuf:"bytes,6,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	// replica_node_ids specifies the list of node ids that contain replicas with current hot range.
	ReplicaNodeIds []github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,7,rep,packed,name=replica_node_ids,json=replicaNodeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"replica_node_ids,omitempty"`
	// leaseholder_node_id indicates the Node ID that is the current leaseholder for the given range.
	LeaseholderNodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,8,opt,name=leaseholder_node_id,json=leaseholderNodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"leaseholder_node_id,omitempty"`
	// schema_name provides the name of schema (if exists) for table in current range.
	SchemaName string `protobuf:"bytes,9,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	// store_id indicates the Store ID where range is stored.
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,10,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
}

func (m *HotRangesResponseV2_HotRange) Reset()         { *m = HotRangesResponseV2_HotRange{} }
func (m *HotRangesResponseV2_HotRange) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponseV2_HotRange) ProtoMessage()    {}
func (*HotRangesResponseV2_HotRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{77, 0}
}
func (m *HotRangesResponseV2_HotRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponseV2_HotRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HotRangesResponseV2_HotRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponseV2_HotRange.Merge(m, src)
}
func (m *HotRangesResponseV2_HotRange) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponseV2_HotRange) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponseV2_HotRange.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponseV2_HotRange proto.InternalMessageInfo

type RangeRequest struct {
	RangeId int64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
}

func (m *RangeRequest) Reset()         { *m = RangeRequest{} }
func (m *RangeRequest) String() string { return proto.CompactTextString(m) }
func (*RangeRequest) ProtoMessage()    {}
func (*RangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{78}
}
func (m *RangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeRequest.Merge(m, src)
}
func (m *RangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeRequest proto.InternalMessageInfo

type RangeResponse struct {
	// NodeID is the node that submitted all the requests.
	NodeID            github_com_cockroachdb_cockroach_pkg_roachpb.NodeID                                `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	RangeID           github_com_cockroachdb_cockroach_pkg_roachpb.RangeID                               `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	ResponsesByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]RangeResponse_NodeResponse `protobuf:"bytes,3,rep,name=responses_by_node_id,json=responsesByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"responses_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RangeResponse) Reset()         { *m = RangeResponse{} }
func (m *RangeResponse) String() string { return proto.CompactTextString(m) }
func (*RangeResponse) ProtoMessage()    {}
func (*RangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{79}
}
func (m *RangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeResponse.Merge(m, src)
}
func (m *RangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeResponse proto.InternalMessageInfo

type RangeResponse_NodeResponse struct {
	Response     bool        `protobuf:"varint,1,opt,name=response,proto3" json:"response,omitempty"`
	ErrorMessage string      `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	Infos        []RangeInfo `protobuf:"bytes,3,rep,name=infos,proto3" json:"infos"`
}

func (m *RangeResponse_NodeResponse) Reset()         { *m = RangeResponse_NodeResponse{} }
func (m *RangeResponse_NodeResponse) String() string { return proto.CompactTextString(m) }
func (*RangeResponse_NodeResponse) ProtoMessage()    {}
func (*RangeResponse_NodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{79, 0}
}
func (m *RangeResponse_NodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeResponse_NodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeResponse_NodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeResponse_NodeResponse.Merge(m, src)
}
func (m *RangeResponse_NodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeResponse_NodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeResponse_NodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeResponse_NodeResponse proto.InternalMessageInfo

// DiagnosticsRequest requests a diagnostics report.
type DiagnosticsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *DiagnosticsRequest) Reset()         { *m = DiagnosticsRequest{} }
func (m *DiagnosticsRequest) String() string { return proto.CompactTextString(m) }
func (*DiagnosticsRequest) ProtoMessage()    {}
func (*DiagnosticsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{80}
}
func (m *DiagnosticsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiagnosticsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DiagnosticsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiagnosticsRequest.Merge(m, src)
}
func (m *DiagnosticsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DiagnosticsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiagnosticsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiagnosticsRequest proto.InternalMessageInfo

type StoresRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *StoresRequest) Reset()         { *m = StoresRequest{} }
func (m *StoresRequest) String() string { return proto.CompactTextString(m) }
func (*StoresRequest) ProtoMessage()    {}
func (*StoresRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{81}
}
func (m *StoresRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoresRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoresRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoresRequest.Merge(m, src)
}
func (m *StoresRequest) XXX_Size() int {
	return m.Size()
}
func (m *StoresRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StoresRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StoresRequest proto.InternalMessageInfo

type StoreDetails struct {
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	// encryption_status is a serialized
	// ccl/storageccl/engineccl/enginepbccl/stats.go::EncryptionStatus protobuf.
	EncryptionStatus []byte `protobuf:"bytes,2,opt,name=encryption_status,json=encryptionStatus,proto3" json:"encryption_status,omitempty"`
	// Basic file stats when encryption is enabled.
	// Total files/bytes.
	TotalFiles uint64 `protobuf:"varint,3,opt,name=total_files,json=totalFiles,proto3" json:"total_files,omitempty"`
	TotalBytes uint64 `protobuf:"varint,4,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// Files/bytes using the active data key.
	ActiveKeyFiles uint64 `protobuf:"varint,5,opt,name=active_key_files,json=activeKeyFiles,proto3" json:"active_key_files,omitempty"`
	ActiveKeyBytes uint64 `protobuf:"varint,6,opt,name=active_key_bytes,json=activeKeyBytes,proto3" json:"active_key_bytes,omitempty"`
}

func (m *StoreDetails) Reset()         { *m = StoreDetails{} }
func (m *StoreDetails) String() string { return proto.CompactTextString(m) }
func (*StoreDetails) ProtoMessage()    {}
func (*StoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{82}
}
func (m *StoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreDetails.Merge(m, src)
}
func (m *StoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *StoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_StoreDetails proto.InternalMessageInfo

type StoresResponse struct {
	Stores []StoreDetails `protobuf:"bytes,1,rep,name=stores,proto3" json:"stores"`
}

func (m *StoresResponse) Reset()         { *m = StoresResponse{} }
func (m *StoresResponse) String() string { return proto.CompactTextString(m) }
func (*StoresResponse) ProtoMessage()    {}
func (*StoresResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{83}
}
func (m *StoresResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoresResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoresResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoresResponse.Merge(m, src)
}
func (m *StoresResponse) XXX_Size() int {
	return m.Size()
}
func (m *StoresResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StoresResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StoresResponse proto.InternalMessageInfo

// StatementsRequest is used by both tenant and node-level
// implementations to serve fan-out requests across multiple nodes or
// instances. When implemented on a node, the `node_id` field refers to
// the cluster nodes by their nodeID. When implemented on a tenant, the
// `node_id` field refers to the instanceIDs that identify individual
// tenant pods.
type StatementsRequest struct {
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// If this field is set we will use the combined statements API instead.
	Combined bool `protobuf:"varint,2,opt,name=combined,proto3" json:"combined,omitempty"`
	// These fields are used for the combined statements API.
	Start     int64                       `protobuf:"varint,3,opt,name=start,proto3" json:"start,omitempty"`
	End       int64                       `protobuf:"varint,4,opt,name=end,proto3" json:"end,omitempty"`
	FetchMode StatementsRequest_FetchMode `protobuf:"varint,5,opt,name=fetch_mode,json=fetchMode,proto3,enum=cockroach.server.serverpb.StatementsRequest_FetchMode" json:"fetch_mode,omitempty"`
}

func (m *StatementsRequest) Reset()         { *m = StatementsRequest{} }
func (m *StatementsRequest) String() string { return proto.CompactTextString(m) }
func (*StatementsRequest) ProtoMessage()    {}
func (*StatementsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{84}
}
func (m *StatementsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsRequest.Merge(m, src)
}
func (m *StatementsRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatementsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsRequest proto.InternalMessageInfo

type StatementsResponse struct {
	Statements []StatementsResponse_CollectedStatementStatistics `protobuf:"bytes,1,rep,name=statements,proto3" json:"statements"`
	// Timestamp of the last stats reset.
	LastReset time.Time `protobuf:"bytes,3,opt,name=last_reset,json=lastReset,proto3,stdtime" json:"last_reset"`
	// If set and non-empty, indicates the prefix to application_name
	// used for statements/queries issued internally by CockroachDB.
	InternalAppNamePrefix string `protobuf:"bytes,4,opt,name=internal_app_name_prefix,json=internalAppNamePrefix,proto3" json:"internal_app_name_prefix,omitempty"`
	// Transactions is transaction-level statistics for the collection of
	// statements in this response.
	Transactions []StatementsResponse_ExtendedCollectedTransactionStatistics `protobuf:"bytes,5,rep,name=transactions,proto3" json:"transactions"`
}

func (m *StatementsResponse) Reset()         { *m = StatementsResponse{} }
func (m *StatementsResponse) String() string { return proto.CompactTextString(m) }
func (*StatementsResponse) ProtoMessage()    {}
func (*StatementsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{85}
}
func (m *StatementsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsResponse.Merge(m, src)
}
func (m *StatementsResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatementsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsResponse proto.InternalMessageInfo

type StatementsResponse_ExtendedStatementStatisticsKey struct {
	KeyData      roachpb.StatementStatisticsKey                      `protobuf:"bytes,1,opt,name=key_data,json=keyData,proto3" json:"key_data"`
	NodeID       github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	AggregatedTs time.Time                                           `protobuf:"bytes,3,opt,name=aggregated_ts,json=aggregatedTs,proto3,stdtime" json:"aggregated_ts"`
	// The aggregation duration.
	AggregationInterval time.Duration `protobuf:"bytes,4,opt,name=aggregation_interval,json=aggregationInterval,proto3,stdduration" json:"aggregation_interval"`
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) Reset() {
	*m = StatementsResponse_ExtendedStatementStatisticsKey{}
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) String() string {
	return proto.CompactTextString(m)
}
func (*StatementsResponse_ExtendedStatementStatisticsKey) ProtoMessage() {}
func (*StatementsResponse_ExtendedStatementStatisticsKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{85, 0}
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsResponse_ExtendedStatementStatisticsKey.Merge(m, src)
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_Size() int {
	return m.Size()
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsResponse_ExtendedStatementStatisticsKey.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsResponse_ExtendedStatementStatisticsKey proto.InternalMessageInfo

type StatementsResponse_CollectedStatementStatistics struct {
	Key   StatementsResponse_ExtendedStatementStatisticsKey              `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	ID    github_com_cockroachdb_cockroach_pkg_roachpb.StmtFingerprintID `protobuf:"varint,3,opt,name=id,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StmtFingerprintID" json:"id,omitempty"`
	Stats roachpb.StatementStatistics                                    `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats"`
}

func (m *StatementsResponse_CollectedStatementStatistics) Reset() {
	*m = StatementsResponse_CollectedStatementStatistics{}
}
func (m *StatementsResponse_CollectedStatementStatistics) String() string {
	return proto.CompactTextString(m)
}
func (*StatementsResponse_CollectedStatementStatistics) ProtoMessage() {}
func (*StatementsResponse_CollectedStatementStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{85, 1}
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsResponse_CollectedStatementStatistics.Merge(m, src)
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_Size() int {
	return m.Size()
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsResponse_CollectedStatementStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsResponse_CollectedStatementStatistics proto.InternalMessageInfo

type StatementsResponse_ExtendedCollectedTransactionStatistics struct {
	StatsData roachpb.CollectedTransactionStatistics              `protobuf:"bytes,1,opt,name=stats_data,json=statsData,proto3" json:"stats_data"`
	NodeID    github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) Reset() {
	*m = StatementsResponse_ExtendedCollectedTransactionStatistics{}
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) String() string {
	return proto.CompactTextString(m)
}
func (*StatementsResponse_ExtendedCollectedTransactionStatistics) ProtoMessage() {}
func (*StatementsResponse_ExtendedCollectedTransactionStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{85, 2}
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsResponse_ExtendedCollectedTransactionStatistics.Merge(m, src)
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_Size() int {
	return m.Size()
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsResponse_ExtendedCollectedTransactionStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsResponse_ExtendedCollectedTransactionStatistics proto.InternalMessageInfo

type CombinedStatementsStatsRequest struct {
	// Unix time range for aggregated statements.
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *CombinedStatementsStatsRequest) Reset()         { *m = CombinedStatementsStatsRequest{} }
func (m *CombinedStatementsStatsRequest) String() string { return proto.CompactTextString(m) }
func (*CombinedStatementsStatsRequest) ProtoMessage()    {}
func (*CombinedStatementsStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{86}
}
func (m *CombinedStatementsStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombinedStatementsStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CombinedStatementsStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombinedStatementsStatsRequest.Merge(m, src)
}
func (m *CombinedStatementsStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *CombinedStatementsStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CombinedStatementsStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CombinedStatementsStatsRequest proto.InternalMessageInfo

type StatementDiagnosticsReport struct {
	Id                     int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Completed              bool      `protobuf:"varint,2,opt,name=completed,proto3" json:"completed,omitempty"`
	StatementFingerprint   string    `protobuf:"bytes,3,opt,name=statement_fingerprint,json=statementFingerprint,proto3" json:"statement_fingerprint,omitempty"`
	StatementDiagnosticsId int64     `protobuf:"varint,4,opt,name=statement_diagnostics_id,json=statementDiagnosticsId,proto3" json:"statement_diagnostics_id,omitempty"`
	RequestedAt            time.Time `protobuf:"bytes,5,opt,name=requested_at,json=requestedAt,proto3,stdtime" json:"requested_at"`
}

func (m *StatementDiagnosticsReport) Reset()         { *m = StatementDiagnosticsReport{} }
func (m *StatementDiagnosticsReport) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsReport) ProtoMessage()    {}
func (*StatementDiagnosticsReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{87}
}
func (m *StatementDiagnosticsReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementDiagnosticsReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsReport.Merge(m, src)
}
func (m *StatementDiagnosticsReport) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsReport) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsReport.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsReport proto.InternalMessageInfo

type CreateStatementDiagnosticsReportRequest struct {
	StatementFingerprint string `protobuf:"bytes,1,opt,name=statement_fingerprint,json=statementFingerprint,proto3" json:"statement_fingerprint,omitempty"`
}

func (m *CreateStatementDiagnosticsReportRequest) Reset() {
	*m = CreateStatementDiagnosticsReportRequest{}
}
func (m *CreateStatementDiagnosticsReportRequest) String() string { return proto.CompactTextString(m) }
func (*CreateStatementDiagnosticsReportRequest) ProtoMessage()    {}
func (*CreateStatementDiagnosticsReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{88}
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatementDiagnosticsReportRequest.Merge(m, src)
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatementDiagnosticsReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatementDiagnosticsReportRequest proto.InternalMessageInfo

type CreateStatementDiagnosticsReportResponse struct {
	Report *StatementDiagnosticsReport `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
}

func (m *CreateStatementDiagnosticsReportResponse) Reset() {
	*m = CreateStatementDiagnosticsReportResponse{}
}
func (m *CreateStatementDiagnosticsReportResponse) String() string { return proto.CompactTextString(m) }
func (*CreateStatementDiagnosticsReportResponse) ProtoMessage()    {}
func (*CreateStatementDiagnosticsReportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{89}
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatementDiagnosticsReportResponse.Merge(m, src)
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatementDiagnosticsReportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatementDiagnosticsReportResponse proto.InternalMessageInfo

type StatementDiagnosticsReportsRequest struct {
}

func (m *StatementDiagnosticsReportsRequest) Reset()         { *m = StatementDiagnosticsReportsRequest{} }
func (m *StatementDiagnosticsReportsRequest) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsReportsRequest) ProtoMessage()    {}
func (*StatementDiagnosticsReportsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{90}
}
func (m *StatementDiagnosticsReportsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsReportsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementDiagnosticsReportsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsReportsRequest.Merge(m, src)
}
func (m *StatementDiagnosticsReportsRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsReportsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsReportsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsReportsRequest proto.InternalMessageInfo

type StatementDiagnosticsReportsResponse struct {
	Reports []StatementDiagnosticsReport `protobuf:"bytes,1,rep,name=reports,proto3" json:"reports"`
}

func (m *StatementDiagnosticsReportsResponse) Reset()         { *m = StatementDiagnosticsReportsResponse{} }
func (m *StatementDiagnosticsReportsResponse) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsReportsResponse) ProtoMessage()    {}
func (*StatementDiagnosticsReportsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{91}
}
func (m *StatementDiagnosticsReportsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsReportsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementDiagnosticsReportsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsReportsResponse.Merge(m, src)
}
func (m *StatementDiagnosticsReportsResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsReportsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsReportsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsReportsResponse proto.InternalMessageInfo

type StatementDiagnostics struct {
	Id                   int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StatementFingerprint string    `protobuf:"bytes,2,opt,name=statement_fingerprint,json=statementFingerprint,proto3" json:"statement_fingerprint,omitempty"`
	CollectedAt          time.Time `protobuf:"bytes,3,opt,name=collected_at,json=collectedAt,proto3,stdtime" json:"collected_at"`
}

func (m *StatementDiagnostics) Reset()         { *m = StatementDiagnostics{} }
func (m *StatementDiagnostics) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnostics) ProtoMessage()    {}
func (*StatementDiagnostics) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{92}
}
func (m *StatementDiagnostics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnostics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementDiagnostics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnostics.Merge(m, src)
}
func (m *StatementDiagnostics) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnostics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnostics.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnostics proto.InternalMessageInfo

type StatementDiagnosticsRequest struct {
	StatementDiagnosticsId int64 `protobuf:"varint,1,opt,name=statement_diagnostics_id,json=statementDiagnosticsId,proto3" json:"statement_diagnostics_id,omitempty"`
}

func (m *StatementDiagnosticsRequest) Reset()         { *m = StatementDiagnosticsRequest{} }
func (m *StatementDiagnosticsRequest) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsRequest) ProtoMessage()    {}
func (*StatementDiagnosticsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{93}
}
func (m *StatementDiagnosticsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementDiagnosticsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsRequest.Merge(m, src)
}
func (m *StatementDiagnosticsRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsRequest proto.InternalMessageInfo

type StatementDiagnosticsResponse struct {
	Diagnostics *StatementDiagnostics `protobuf:"bytes,2,opt,name=diagnostics,proto3" json:"diagnostics,omitempty"`
}

func (m *StatementDiagnosticsResponse) Reset()         { *m = StatementDiagnosticsResponse{} }
func (m *StatementDiagnosticsResponse) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsResponse) ProtoMessage()    {}
func (*StatementDiagnosticsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{94}
}
func (m *StatementDiagnosticsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementDiagnosticsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsResponse.Merge(m, src)
}
func (m *StatementDiagnosticsResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsResponse proto.InternalMessageInfo

type JobRegistryStatusRequest struct {
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *JobRegistryStatusRequest) Reset()         { *m = JobRegistryStatusRequest{} }
func (m *JobRegistryStatusRequest) String() string { return proto.CompactTextString(m) }
func (*JobRegistryStatusRequest) ProtoMessage()    {}
func (*JobRegistryStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{95}
}
func (m *JobRegistryStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRegistryStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobRegistryStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRegistryStatusRequest.Merge(m, src)
}
func (m *JobRegistryStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobRegistryStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRegistryStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobRegistryStatusRequest proto.InternalMessageInfo

type JobRegistryStatusResponse struct {
	NodeID      github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	RunningJobs []*JobRegistryStatusResponse_Job                    `protobuf:"bytes,2,rep,name=running_jobs,json=runningJobs,proto3" json:"running_jobs,omitempty"`
}

func (m *JobRegistryStatusResponse) Reset()         { *m = JobRegistryStatusResponse{} }
func (m *JobRegistryStatusResponse) String() string { return proto.CompactTextString(m) }
func (*JobRegistryStatusResponse) ProtoMessage()    {}
func (*JobRegistryStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{96}
}
func (m *JobRegistryStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRegistryStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobRegistryStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRegistryStatusResponse.Merge(m, src)
}
func (m *JobRegistryStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobRegistryStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRegistryStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobRegistryStatusResponse proto.InternalMessageInfo

type JobRegistryStatusResponse_Job struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *JobRegistryStatusResponse_Job) Reset()         { *m = JobRegistryStatusResponse_Job{} }
func (m *JobRegistryStatusResponse_Job) String() string { return proto.CompactTextString(m) }
func (*JobRegistryStatusResponse_Job) ProtoMessage()    {}
func (*JobRegistryStatusResponse_Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{96, 0}
}
func (m *JobRegistryStatusResponse_Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRegistryStatusResponse_Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobRegistryStatusResponse_Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRegistryStatusResponse_Job.Merge(m, src)
}
func (m *JobRegistryStatusResponse_Job) XXX_Size() int {
	return m.Size()
}
func (m *JobRegistryStatusResponse_Job) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRegistryStatusResponse_Job.DiscardUnknown(m)
}

var xxx_messageInfo_JobRegistryStatusResponse_Job proto.InternalMessageInfo

type JobStatusRequest struct {
	JobId int64 `protobuf:"varint,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (m *JobStatusRequest) Reset()         { *m = JobStatusRequest{} }
func (m *JobStatusRequest) String() string { return proto.CompactTextString(m) }
func (*JobStatusRequest) ProtoMessage()    {}
func (*JobStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{97}
}
func (m *JobStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatusRequest.Merge(m, src)
}
func (m *JobStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatusRequest proto.InternalMessageInfo

type JobStatusResponse struct {
	Job *jobspb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
}

func (m *JobStatusResponse) Reset()         { *m = JobStatusResponse{} }
func (m *JobStatusResponse) String() string { return proto.CompactTextString(m) }
func (*JobStatusResponse) ProtoMessage()    {}
func (*JobStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{98}
}
func (m *JobStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatusResponse.Merge(m, src)
}
func (m *JobStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatusResponse proto.InternalMessageInfo

// Request object for issuing a SQL stats reset request.
type ResetSQLStatsRequest struct {
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// reset_persisted_stats specifies if the persisted SQL Stats will be reset
	// along with the in-memory SQL stats.
	ResetPersistedStats bool `protobuf:"varint,2,opt,name=reset_persisted_stats,json=resetPersistedStats,proto3" json:"reset_persisted_stats,omitempty"`
}

func (m *ResetSQLStatsRequest) Reset()         { *m = ResetSQLStatsRequest{} }
func (m *ResetSQLStatsRequest) String() string { return proto.CompactTextString(m) }
func (*ResetSQLStatsRequest) ProtoMessage()    {}
func (*ResetSQLStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{99}
}
func (m *ResetSQLStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetSQLStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetSQLStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetSQLStatsRequest.Merge(m, src)
}
func (m *ResetSQLStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResetSQLStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetSQLStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetSQLStatsRequest proto.InternalMessageInfo

// Response object returned by ResetSQLStats.
type ResetSQLStatsResponse struct {
}

func (m *ResetSQLStatsResponse) Reset()         { *m = ResetSQLStatsResponse{} }
func (m *ResetSQLStatsResponse) String() string { return proto.CompactTextString(m) }
func (*ResetSQLStatsResponse) ProtoMessage()    {}
func (*ResetSQLStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{100}
}
func (m *ResetSQLStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetSQLStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetSQLStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetSQLStatsResponse.Merge(m, src)
}
func (m *ResetSQLStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResetSQLStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetSQLStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetSQLStatsResponse proto.InternalMessageInfo

// Request object for issuing IndexUsageStatistics request.
type IndexUsageStatisticsRequest struct {
	// node_id is the ID of the node where the stats data shall be retrieved from.
	// If this is left empty, the cluster-wide aggregated result will be returned.
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *IndexUsageStatisticsRequest) Reset()         { *m = IndexUsageStatisticsRequest{} }
func (m *IndexUsageStatisticsRequest) String() string { return proto.CompactTextString(m) }
func (*IndexUsageStatisticsRequest) ProtoMessage()    {}
func (*IndexUsageStatisticsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{101}
}
func (m *IndexUsageStatisticsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexUsageStatisticsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexUsageStatisticsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexUsageStatisticsRequest.Merge(m, src)
}
func (m *IndexUsageStatisticsRequest) XXX_Size() int {
	return m.Size()
}
func (m *IndexUsageStatisticsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexUsageStatisticsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IndexUsageStatisticsRequest proto.InternalMessageInfo

// Response object returned by IndexUsageStatistics.
type IndexUsageStatisticsResponse struct {
	Statistics []roachpb.CollectedIndexUsageStatistics `protobuf:"bytes,1,rep,name=statistics,proto3" json:"statistics"`
	// Timestamp of the last index usage stats reset.
	LastReset time.Time `protobuf:"bytes,3,opt,name=last_reset,json=lastReset,proto3,stdtime" json:"last_reset"`
}

func (m *IndexUsageStatisticsResponse) Reset()         { *m = IndexUsageStatisticsResponse{} }
func (m *IndexUsageStatisticsResponse) String() string { return proto.CompactTextString(m) }
func (*IndexUsageStatisticsResponse) ProtoMessage()    {}
func (*IndexUsageStatisticsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{102}
}
func (m *IndexUsageStatisticsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexUsageStatisticsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexUsageStatisticsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexUsageStatisticsResponse.Merge(m, src)
}
func (m *IndexUsageStatisticsResponse) XXX_Size() int {
	return m.Size()
}
func (m *IndexUsageStatisticsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexUsageStatisticsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IndexUsageStatisticsResponse proto.InternalMessageInfo

// Request object for issuing a index usage stats reset request.
type ResetIndexUsageStatsRequest struct {
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *ResetIndexUsageStatsRequest) Reset()         { *m = ResetIndexUsageStatsRequest{} }
func (m *ResetIndexUsageStatsRequest) String() string { return proto.CompactTextString(m) }
func (*ResetIndexUsageStatsRequest) ProtoMessage()    {}
func (*ResetIndexUsageStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{103}
}
func (m *ResetIndexUsageStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetIndexUsageStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetIndexUsageStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetIndexUsageStatsRequest.Merge(m, src)
}
func (m *ResetIndexUsageStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResetIndexUsageStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetIndexUsageStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetIndexUsageStatsRequest proto.InternalMessageInfo

// Response object returned by ResetIndexUsageStatsRequest.
type ResetIndexUsageStatsResponse struct {
}

func (m *ResetIndexUsageStatsResponse) Reset()         { *m = ResetIndexUsageStatsResponse{} }
func (m *ResetIndexUsageStatsResponse) String() string { return proto.CompactTextString(m) }
func (*ResetIndexUsageStatsResponse) ProtoMessage()    {}
func (*ResetIndexUsageStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{104}
}
func (m *ResetIndexUsageStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetIndexUsageStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetIndexUsageStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetIndexUsageStatsResponse.Merge(m, src)
}
func (m *ResetIndexUsageStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResetIndexUsageStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetIndexUsageStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetIndexUsageStatsResponse proto.InternalMessageInfo

// UserSQLRolesRequest requests a list of roles of the logged in SQL user.
type UserSQLRolesRequest struct {
}

func (m *UserSQLRolesRequest) Reset()         { *m = UserSQLRolesRequest{} }
func (m *UserSQLRolesRequest) String() string { return proto.CompactTextString(m) }
func (*UserSQLRolesRequest) ProtoMessage()    {}
func (*UserSQLRolesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{105}
}
func (m *UserSQLRolesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSQLRolesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserSQLRolesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSQLRolesRequest.Merge(m, src)
}
func (m *UserSQLRolesRequest) XXX_Size() int {
	return m.Size()
}
func (m *UserSQLRolesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSQLRolesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserSQLRolesRequest proto.InternalMessageInfo

// UserSQLRolesResponse returns a list of roles for the logged SQL user.
type UserSQLRolesResponse struct {
	// roles is a list of roles for the SQL user.
	Roles []string `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *UserSQLRolesResponse) Reset()         { *m = UserSQLRolesResponse{} }
func (m *UserSQLRolesResponse) String() string { return proto.CompactTextString(m) }
func (*UserSQLRolesResponse) ProtoMessage()    {}
func (*UserSQLRolesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_07f09f8b91174efc, []int{106}
}
func (m *UserSQLRolesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSQLRolesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserSQLRolesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSQLRolesResponse.Merge(m, src)
}
func (m *UserSQLRolesResponse) XXX_Size() int {
	return m.Size()
}
func (m *UserSQLRolesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSQLRolesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserSQLRolesResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.server.serverpb.StacksType", StacksType_name, StacksType_value)
	proto.RegisterEnum("cockroach.server.serverpb.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("cockroach.server.serverpb.CertificateDetails_CertificateType", CertificateDetails_CertificateType_name, CertificateDetails_CertificateType_value)
	proto.RegisterEnum("cockroach.server.serverpb.ProfileRequest_Type", ProfileRequest_Type_name, ProfileRequest_Type_value)
	proto.RegisterEnum("cockroach.server.serverpb.ActiveQuery_Phase", ActiveQuery_Phase_name, ActiveQuery_Phase_value)
	proto.RegisterEnum("cockroach.server.serverpb.DistSQLRemoteFlows_Status", DistSQLRemoteFlows_Status_name, DistSQLRemoteFlows_Status_value)
	proto.RegisterEnum("cockroach.server.serverpb.StatementsRequest_FetchMode", StatementsRequest_FetchMode_name, StatementsRequest_FetchMode_value)
	proto.RegisterType((*CertificatesRequest)(nil), "cockroach.server.serverpb.CertificatesRequest")
	proto.RegisterType((*CertificateDetails)(nil), "cockroach.server.serverpb.CertificateDetails")
	proto.RegisterType((*CertificateDetails_Fields)(nil), "cockroach.server.serverpb.CertificateDetails.Fields")
	proto.RegisterType((*CertificatesResponse)(nil), "cockroach.server.serverpb.CertificatesResponse")
	proto.RegisterType((*DetailsRequest)(nil), "cockroach.server.serverpb.DetailsRequest")
	proto.RegisterType((*SystemInfo)(nil), "cockroach.server.serverpb.SystemInfo")
	proto.RegisterType((*DetailsResponse)(nil), "cockroach.server.serverpb.DetailsResponse")
	proto.RegisterType((*NodesRequest)(nil), "cockroach.server.serverpb.NodesRequest")
	proto.RegisterType((*NodesResponse)(nil), "cockroach.server.serverpb.NodesResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus)(nil), "cockroach.server.serverpb.NodesResponse.LivenessByNodeIdEntry")
	proto.RegisterType((*NodesResponseExternal)(nil), "cockroach.server.serverpb.NodesResponseExternal")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus)(nil), "cockroach.server.serverpb.NodesResponseExternal.LivenessByNodeIdEntry")
	proto.RegisterType((*Locality)(nil), "cockroach.server.serverpb.Locality")
	proto.RegisterType((*Tier)(nil), "cockroach.server.serverpb.Tier")
	proto.RegisterType((*Version)(nil), "cockroach.server.serverpb.Version")
	proto.RegisterType((*NodeDescriptor)(nil), "cockroach.server.serverpb.NodeDescriptor")
	proto.RegisterType((*Percentiles)(nil), "cockroach.server.serverpb.Percentiles")
	proto.RegisterType((*StoreDescriptor)(nil), "cockroach.server.serverpb.StoreDescriptor")
	proto.RegisterType((*StoreStatus)(nil), "cockroach.server.serverpb.StoreStatus")
	proto.RegisterMapType((map[string]float64)(nil), "cockroach.server.serverpb.StoreStatus.MetricsEntry")
	proto.RegisterType((*NodeResponse)(nil), "cockroach.server.serverpb.NodeResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]NodeResponse_NetworkActivity)(nil), "cockroach.server.serverpb.NodeResponse.ActivityEntry")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64)(nil), "cockroach.server.serverpb.NodeResponse.LatenciesEntry")
	proto.RegisterMapType((map[string]float64)(nil), "cockroach.server.serverpb.NodeResponse.MetricsEntry")
	proto.RegisterType((*NodeResponse_NetworkActivity)(nil), "cockroach.server.serverpb.NodeResponse.NetworkActivity")
	proto.RegisterType((*RegionsRequest)(nil), "cockroach.server.serverpb.RegionsRequest")
	proto.RegisterType((*RegionsResponse)(nil), "cockroach.server.serverpb.RegionsResponse")
	proto.RegisterMapType((map[string]*RegionsResponse_Region)(nil), "cockroach.server.serverpb.RegionsResponse.RegionsEntry")
	proto.RegisterType((*RegionsResponse_Region)(nil), "cockroach.server.serverpb.RegionsResponse.Region")
	proto.RegisterType((*NodeRequest)(nil), "cockroach.server.serverpb.NodeRequest")
	proto.RegisterType((*RaftState)(nil), "cockroach.server.serverpb.RaftState")
	proto.RegisterMapType((map[uint64]RaftState_Progress)(nil), "cockroach.server.serverpb.RaftState.ProgressEntry")
	proto.RegisterType((*RaftState_Progress)(nil), "cockroach.server.serverpb.RaftState.Progress")
	proto.RegisterType((*RangeProblems)(nil), "cockroach.server.serverpb.RangeProblems")
	proto.RegisterType((*RangeStatistics)(nil), "cockroach.server.serverpb.RangeStatistics")
	proto.RegisterType((*PrettySpan)(nil), "cockroach.server.serverpb.PrettySpan")
	proto.RegisterType((*RangeInfo)(nil), "cockroach.server.serverpb.RangeInfo")
	proto.RegisterType((*RangeInfo_LockInfo)(nil), "cockroach.server.serverpb.RangeInfo.LockInfo")
	proto.RegisterType((*RangesRequest)(nil), "cockroach.server.serverpb.RangesRequest")
	proto.RegisterType((*RangesResponse)(nil), "cockroach.server.serverpb.RangesResponse")
	proto.RegisterType((*GossipRequest)(nil), "cockroach.server.serverpb.GossipRequest")
	proto.RegisterType((*EngineStatsInfo)(nil), "cockroach.server.serverpb.EngineStatsInfo")
	proto.RegisterType((*EngineStatsRequest)(nil), "cockroach.server.serverpb.EngineStatsRequest")
	proto.RegisterType((*EngineStatsResponse)(nil), "cockroach.server.serverpb.EngineStatsResponse")
	proto.RegisterType((*TraceEvent)(nil), "cockroach.server.serverpb.TraceEvent")
	proto.RegisterType((*AllocatorDryRun)(nil), "cockroach.server.serverpb.AllocatorDryRun")
	proto.RegisterType((*AllocatorRangeRequest)(nil), "cockroach.server.serverpb.AllocatorRangeRequest")
	proto.RegisterType((*AllocatorRangeResponse)(nil), "cockroach.server.serverpb.AllocatorRangeResponse")
	proto.RegisterType((*AllocatorRequest)(nil), "cockroach.server.serverpb.AllocatorRequest")
	proto.RegisterType((*AllocatorResponse)(nil), "cockroach.server.serverpb.AllocatorResponse")
	proto.RegisterType((*JSONResponse)(nil), "cockroach.server.serverpb.JSONResponse")
	proto.RegisterType((*ResponseError)(nil), "cockroach.server.serverpb.ResponseError")
	proto.RegisterType((*LogsRequest)(nil), "cockroach.server.serverpb.LogsRequest")
	proto.RegisterType((*LogEntriesResponse)(nil), "cockroach.server.serverpb.LogEntriesResponse")
	proto.RegisterType((*LogFilesListRequest)(nil), "cockroach.server.serverpb.LogFilesListRequest")
	proto.RegisterType((*LogFilesListResponse)(nil), "cockroach.server.serverpb.LogFilesListResponse")
	proto.RegisterType((*LogFileRequest)(nil), "cockroach.server.serverpb.LogFileRequest")
	proto.RegisterType((*StacksRequest)(nil), "cockroach.server.serverpb.StacksRequest")
	proto.RegisterType((*File)(nil), "cockroach.server.serverpb.File")
	proto.RegisterType((*GetFilesRequest)(nil), "cockroach.server.serverpb.GetFilesRequest")
	proto.RegisterType((*GetFilesResponse)(nil), "cockroach.server.serverpb.GetFilesResponse")
	proto.RegisterType((*ProfileRequest)(nil), "cockroach.server.serverpb.ProfileRequest")
	proto.RegisterType((*MetricsRequest)(nil), "cockroach.server.serverpb.MetricsRequest")
	proto.RegisterType((*RaftRangeNode)(nil), "cockroach.server.serverpb.RaftRangeNode")
	proto.RegisterType((*RaftRangeError)(nil), "cockroach.server.serverpb.RaftRangeError")
	proto.RegisterType((*RaftRangeStatus)(nil), "cockroach.server.serverpb.RaftRangeStatus")
	proto.RegisterType((*RaftDebugRequest)(nil), "cockroach.server.serverpb.RaftDebugRequest")
	proto.RegisterType((*RaftDebugResponse)(nil), "cockroach.server.serverpb.RaftDebugResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID]RaftRangeStatus)(nil), "cockroach.server.serverpb.RaftDebugResponse.RangesEntry")
	proto.RegisterType((*TxnInfo)(nil), "cockroach.server.serverpb.TxnInfo")
	proto.RegisterType((*ActiveQuery)(nil), "cockroach.server.serverpb.ActiveQuery")
	proto.RegisterType((*ListSessionsRequest)(nil), "cockroach.server.serverpb.ListSessionsRequest")
	proto.RegisterType((*Session)(nil), "cockroach.server.serverpb.Session")
	proto.RegisterType((*ListSessionsError)(nil), "cockroach.server.serverpb.ListSessionsError")
	proto.RegisterType((*ListSessionsResponse)(nil), "cockroach.server.serverpb.ListSessionsResponse")
	proto.RegisterType((*CancelQueryRequest)(nil), "cockroach.server.serverpb.CancelQueryRequest")
	proto.RegisterType((*CancelQueryResponse)(nil), "cockroach.server.serverpb.CancelQueryResponse")
	proto.RegisterType((*CancelSessionRequest)(nil), "cockroach.server.serverpb.CancelSessionRequest")
	proto.RegisterType((*CancelSessionResponse)(nil), "cockroach.server.serverpb.CancelSessionResponse")
	proto.RegisterType((*ListContentionEventsRequest)(nil), "cockroach.server.serverpb.ListContentionEventsRequest")
	proto.RegisterType((*ListActivityError)(nil), "cockroach.server.serverpb.ListActivityError")
	proto.RegisterType((*ListContentionEventsResponse)(nil), "cockroach.server.serverpb.ListContentionEventsResponse")
	proto.RegisterType((*ListDistSQLFlowsRequest)(nil), "cockroach.server.serverpb.ListDistSQLFlowsRequest")
	proto.RegisterType((*DistSQLRemoteFlows)(nil), "cockroach.server.serverpb.DistSQLRemoteFlows")
	proto.RegisterType((*DistSQLRemoteFlows_Info)(nil), "cockroach.server.serverpb.DistSQLRemoteFlows.Info")
	proto.RegisterType((*ListDistSQLFlowsResponse)(nil), "cockroach.server.serverpb.ListDistSQLFlowsResponse")
	proto.RegisterType((*SpanStatsRequest)(nil), "cockroach.server.serverpb.SpanStatsRequest")
	proto.RegisterType((*SpanStatsResponse)(nil), "cockroach.server.serverpb.SpanStatsResponse")
	proto.RegisterType((*ProblemRangesRequest)(nil), "cockroach.server.serverpb.ProblemRangesRequest")
	proto.RegisterType((*ProblemRangesResponse)(nil), "cockroach.server.serverpb.ProblemRangesResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]ProblemRangesResponse_NodeProblems)(nil), "cockroach.server.serverpb.ProblemRangesResponse.ProblemsByNodeIdEntry")
	proto.RegisterType((*ProblemRangesResponse_NodeProblems)(nil), "cockroach.server.serverpb.ProblemRangesResponse.NodeProblems")
	proto.RegisterType((*HotRangesRequest)(nil), "cockroach.server.serverpb.HotRangesRequest")
	proto.RegisterType((*HotRangesResponse)(nil), "cockroach.server.serverpb.HotRangesResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]HotRangesResponse_NodeResponse)(nil), "cockroach.server.serverpb.HotRangesResponse.HotRangesByNodeIdEntry")
	proto.RegisterType((*HotRangesResponse_HotRange)(nil), "cockroach.server.serverpb.HotRangesResponse.HotRange")
	proto.RegisterType((*HotRangesResponse_StoreResponse)(nil), "cockroach.server.serverpb.HotRangesResponse.StoreResponse")
	proto.RegisterType((*HotRangesResponse_NodeResponse)(nil), "cockroach.server.serverpb.HotRangesResponse.NodeResponse")
	proto.RegisterType((*HotRangesResponseV2)(nil), "cockroach.server.serverpb.HotRangesResponseV2")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]string)(nil), "cockroach.server.serverpb.HotRangesResponseV2.ErrorsByNodeIdEntry")
	proto.RegisterType((*HotRangesResponseV2_HotRange)(nil), "cockroach.server.serverpb.HotRangesResponseV2.HotRange")
	proto.RegisterType((*RangeRequest)(nil), "cockroach.server.serverpb.RangeRequest")
	proto.RegisterType((*RangeResponse)(nil), "cockroach.server.serverpb.RangeResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]RangeResponse_NodeResponse)(nil), "cockroach.server.serverpb.RangeResponse.ResponsesByNodeIdEntry")
	proto.RegisterType((*RangeResponse_NodeResponse)(nil), "cockroach.server.serverpb.RangeResponse.NodeResponse")
	proto.RegisterType((*DiagnosticsRequest)(nil), "cockroach.server.serverpb.DiagnosticsRequest")
	proto.RegisterType((*StoresRequest)(nil), "cockroach.server.serverpb.StoresRequest")
	proto.RegisterType((*StoreDetails)(nil), "cockroach.server.serverpb.StoreDetails")
	proto.RegisterType((*StoresResponse)(nil), "cockroach.server.serverpb.StoresResponse")
	proto.RegisterType((*StatementsRequest)(nil), "cockroach.server.serverpb.StatementsRequest")
	proto.RegisterType((*StatementsResponse)(nil), "cockroach.server.serverpb.StatementsResponse")
	proto.RegisterType((*StatementsResponse_ExtendedStatementStatisticsKey)(nil), "cockroach.server.serverpb.StatementsResponse.ExtendedStatementStatisticsKey")
	proto.RegisterType((*StatementsResponse_CollectedStatementStatistics)(nil), "cockroach.server.serverpb.StatementsResponse.CollectedStatementStatistics")
	proto.RegisterType((*StatementsResponse_ExtendedCollectedTransactionStatistics)(nil), "cockroach.server.serverpb.StatementsResponse.ExtendedCollectedTransactionStatistics")
	proto.RegisterType((*CombinedStatementsStatsRequest)(nil), "cockroach.server.serverpb.CombinedStatementsStatsRequest")
	proto.RegisterType((*StatementDiagnosticsReport)(nil), "cockroach.server.serverpb.StatementDiagnosticsReport")
	proto.RegisterType((*CreateStatementDiagnosticsReportRequest)(nil), "cockroach.server.serverpb.CreateStatementDiagnosticsReportRequest")
	proto.RegisterType((*CreateStatementDiagnosticsReportResponse)(nil), "cockroach.server.serverpb.CreateStatementDiagnosticsReportResponse")
	proto.RegisterType((*StatementDiagnosticsReportsRequest)(nil), "cockroach.server.serverpb.StatementDiagnosticsReportsRequest")
	proto.RegisterType((*StatementDiagnosticsReportsResponse)(nil), "cockroach.server.serverpb.StatementDiagnosticsReportsResponse")
	proto.RegisterType((*StatementDiagnostics)(nil), "cockroach.server.serverpb.StatementDiagnostics")
	proto.RegisterType((*StatementDiagnosticsRequest)(nil), "cockroach.server.serverpb.StatementDiagnosticsRequest")
	proto.RegisterType((*StatementDiagnosticsResponse)(nil), "cockroach.server.serverpb.StatementDiagnosticsResponse")
	proto.RegisterType((*JobRegistryStatusRequest)(nil), "cockroach.server.serverpb.JobRegistryStatusRequest")
	proto.RegisterType((*JobRegistryStatusResponse)(nil), "cockroach.server.serverpb.JobRegistryStatusResponse")
	proto.RegisterType((*JobRegistryStatusResponse_Job)(nil), "cockroach.server.serverpb.JobRegistryStatusResponse.Job")
	proto.RegisterType((*JobStatusRequest)(nil), "cockroach.server.serverpb.JobStatusRequest")
	proto.RegisterType((*JobStatusResponse)(nil), "cockroach.server.serverpb.JobStatusResponse")
	proto.RegisterType((*ResetSQLStatsRequest)(nil), "cockroach.server.serverpb.ResetSQLStatsRequest")
	proto.RegisterType((*ResetSQLStatsResponse)(nil), "cockroach.server.serverpb.ResetSQLStatsResponse")
	proto.RegisterType((*IndexUsageStatisticsRequest)(nil), "cockroach.server.serverpb.IndexUsageStatisticsRequest")
	proto.RegisterType((*IndexUsageStatisticsResponse)(nil), "cockroach.server.serverpb.IndexUsageStatisticsResponse")
	proto.RegisterType((*ResetIndexUsageStatsRequest)(nil), "cockroach.server.serverpb.ResetIndexUsageStatsRequest")
	proto.RegisterType((*ResetIndexUsageStatsResponse)(nil), "cockroach.server.serverpb.ResetIndexUsageStatsResponse")
	proto.RegisterType((*UserSQLRolesRequest)(nil), "cockroach.server.serverpb.UserSQLRolesRequest")
	proto.RegisterType((*UserSQLRolesResponse)(nil), "cockroach.server.serverpb.UserSQLRolesResponse")
}

func init() { proto.RegisterFile("server/serverpb/status.proto", fileDescriptor_07f09f8b91174efc) }

var fileDescriptor_07f09f8b91174efc = []byte{
	// 8552 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x7d, 0x6d, 0x6c, 0x1c, 0xc9,
	0x95, 0x98, 0x9a, 0x33, 0x43, 0xce, 0xbc, 0xe1, 0xc7, 0xa8, 0x48, 0x4a, 0xd4, 0x48, 0x22, 0xa5,
	0xd6, 0x5a, 0x2b, 0x69, 0xb5, 0xc3, 0x5d, 0xee, 0x6a, 0xb5, 0xbb, 0xb6, 0xf7, 0xcc, 0xaf, 0x95,
	0x28, 0x51, 0x5f, 0x4d, 0x72, 0xd7, 0x58, 0x5f, 0x6e, 0xd2, 0x9c, 0x2e, 0x8e, 0x7a, 0xd9, 0xd3,
	0x3d, 0xec, 0xee, 0xe1, 0x72, 0xbc, 0xb7, 0xb6, 0xe3, 0x7c, 0x9c, 0xef, 0xce, 0xf1, 0x9d, 0x2f,
	0x31, 0xe0, 0x20, 0x41, 0x72, 0xf1, 0x0f, 0x5f, 0x70, 0x41, 0x0e, 0x67, 0x04, 0xf9, 0x02, 0x92,
	0x5c, 0x90, 0x1f, 0x17, 0x1f, 0x02, 0x04, 0x06, 0x92, 0x1f, 0x46, 0x82, 0xf0, 0x12, 0x3a, 0x48,
	0x82, 0xe4, 0x47, 0x10, 0x24, 0xbf, 0x16, 0x48, 0x10, 0xd4, 0xab, 0xaa, 0x9e, 0xea, 0x99, 0x61,
	0xcf, 0x8c, 0x3e, 0xd6, 0x07, 0xe4, 0xc7, 0xae, 0xa6, 0x5f, 0xbd, 0x7a, 0xf5, 0xea, 0xd5, 0xab,
	0x57, 0xaf, 0xea, 0xbd, 0x2a, 0xc2, 0xb9, 0x80, 0xfa, 0xfb, 0xd4, 0x9f, 0xe7, 0xff, 0xd4, 0xb7,
	0xe7, 0x83, 0xd0, 0x0c, 0x1b, 0x41, 0xa9, 0xee, 0x7b, 0xa1, 0x47, 0xce, 0x54, 0xbc, 0xca, 0xae,
	0xef, 0x99, 0x95, 0xc7, 0x25, 0x8e, 0x50, 0x92, 0x78, 0xc5, 0xc2, 0x76, 0xc3, 0x76, 0xac, 0x79,
	0xdb, 0xdd, 0xf1, 0x38, 0x72, 0x71, 0xb2, 0xea, 0x05, 0x81, 0x5d, 0x9f, 0xe7, 0xff, 0x08, 0xe0,
	0xa9, 0x0f, 0xbd, 0xed, 0x60, 0x9e, 0xfd, 0xaf, 0xbe, 0x8d, 0xff, 0x08, 0xf8, 0x69, 0xa4, 0x5a,
	0xdf, 0x9e, 0x37, 0xeb, 0xf5, 0x32, 0x6b, 0x53, 0x16, 0x10, 0x59, 0x60, 0x99, 0xa1, 0x29, 0x60,
	0x73, 0x12, 0x66, 0xbb, 0x16, 0x3d, 0x28, 0x37, 0x02, 0xb3, 0x4a, 0x63, 0x95, 0x4e, 0x49, 0x84,
	0x1a, 0x0d, 0x4d, 0xa5, 0xe2, 0x82, 0xe8, 0x9d, 0x65, 0x9b, 0x55, 0xd7, 0x0b, 0x42, 0xbb, 0x12,
	0xa8, 0xbf, 0x59, 0x2b, 0xad, 0x2f, 0x51, 0xe7, 0x92, 0x94, 0x08, 0x0a, 0x42, 0xfc, 0xd3, 0x26,
	0x98, 0xe2, 0xc5, 0x60, 0xcf, 0x99, 0xaf, 0x78, 0x6e, 0x48, 0xdd, 0xd0, 0xf6, 0xdc, 0xfa, 0xb6,
	0xf2, 0x21, 0x50, 0xce, 0x30, 0x14, 0x7a, 0x40, 0x2b, 0xb6, 0xbb, 0xe3, 0x9b, 0xd8, 0x53, 0x5b,
	0x14, 0x9d, 0x0f, 0x42, 0xcf, 0x37, 0xab, 0x74, 0x9e, 0xba, 0x55, 0xdb, 0xa5, 0xf5, 0x6d, 0xf1,
	0x43, 0x14, 0x9f, 0xed, 0x28, 0xae, 0xed, 0x57, 0x2a, 0xa2, 0x70, 0xb6, 0xa3, 0xd0, 0xf7, 0x2a,
	0xbb, 0x81, 0xb5, 0x2d, 0xca, 0xaf, 0xee, 0xee, 0xcf, 0xef, 0xee, 0x8b, 0x3e, 0xc8, 0x1f, 0xf5,
	0xed, 0x79, 0x87, 0x9a, 0x01, 0x17, 0x5a, 0xd4, 0x09, 0xfd, 0x18, 0x54, 0x86, 0x24, 0x79, 0x29,
	0xa9, 0x38, 0x8e, 0xbd, 0x4f, 0x5d, 0x1a, 0x04, 0xd1, 0x0f, 0x46, 0x57, 0xfc, 0x14, 0xf8, 0x33,
	0x8d, 0xd0, 0x76, 0xe6, 0x1d, 0xaf, 0xca, 0xfe, 0x63, 0xc5, 0x5e, 0x55, 0x94, 0x14, 0xb1, 0xa4,
	0xe1, 0xfa, 0x34, 0xf0, 0x9c, 0x7d, 0x6a, 0x95, 0x4d, 0xcb, 0xf2, 0x63, 0xb5, 0x1e, 0x3b, 0x95,
	0xf9, 0xd0, 0xae, 0xd1, 0x20, 0x34, 0x6b, 0x52, 0x7f, 0x66, 0x69, 0x58, 0xb1, 0xe6, 0x7d, 0x73,
	0x27, 0x9c, 0xdf, 0x7f, 0x0d, 0xff, 0x65, 0x3d, 0x36, 0x77, 0x42, 0x51, 0x3e, 0x55, 0xf5, 0xaa,
	0x1e, 0xfe, 0x9c, 0x67, 0xbf, 0x04, 0xf4, 0x5c, 0xd5, 0xf3, 0xaa, 0x0e, 0x65, 0x22, 0x9f, 0x37,
	0x5d, 0xd7, 0x0b, 0x4d, 0x36, 0x30, 0x92, 0xc7, 0x39, 0x51, 0x8a, 0x5f, 0xdb, 0x8d, 0x9d, 0xce,
	0x46, 0xdb, 0x11, 0xac, 0x86, 0x6f, 0xb6, 0x86, 0x56, 0x2f, 0xc1, 0xe4, 0x32, 0xf5, 0x43, 0x7b,
	0xc7, 0xae, 0x98, 0x21, 0x0d, 0x0c, 0xba, 0xd7, 0xa0, 0x41, 0x48, 0x4e, 0xc3, 0x88, 0xeb, 0x59,
	0xb4, 0x6c, 0x5b, 0x33, 0xda, 0x05, 0xed, 0x4a, 0xce, 0x18, 0x66, 0x9f, 0x6b, 0x96, 0xfe, 0x3f,
	0xd2, 0x40, 0x94, 0x0a, 0x2b, 0x34, 0x34, 0x6d, 0x27, 0x20, 0x8f, 0x20, 0x1d, 0x36, 0xeb, 0x14,
	0x91, 0xc7, 0x17, 0xbe, 0x58, 0x3a, 0x76, 0xb2, 0x95, 0x3a, 0x2b, 0xab, 0xa0, 0xcd, 0x66, 0x9d,
	0x1a, 0x48, 0x8a, 0x5c, 0x82, 0x31, 0xea, 0xfb, 0x9e, 0x5f, 0xae, 0xd1, 0x80, 0xcd, 0x92, 0x99,
	0x21, 0x64, 0x64, 0x14, 0x81, 0xf7, 0x38, 0x8c, 0x18, 0x30, 0xbc, 0x63, 0x53, 0xc7, 0x0a, 0x66,
	0xd2, 0x17, 0x52, 0x57, 0xf2, 0x0b, 0xaf, 0x0f, 0xd6, 0xf2, 0xbb, 0x58, 0x77, 0x29, 0xfd, 0xe3,
	0xc3, 0xb9, 0x13, 0x86, 0xa0, 0x54, 0xfc, 0xbb, 0x43, 0x30, 0xcc, 0x0b, 0xc8, 0x29, 0x18, 0xb6,
	0x83, 0xa0, 0x41, 0x7d, 0x29, 0x05, 0xfe, 0x45, 0x66, 0x60, 0x24, 0x68, 0x6c, 0x7f, 0x48, 0x2b,
	0xa1, 0xe0, 0x4a, 0x7e, 0x92, 0xf3, 0x00, 0xfb, 0xa6, 0x63, 0x5b, 0xe5, 0x1d, 0xdf, 0xab, 0xcd,
	0xa4, 0x2e, 0x68, 0x57, 0x52, 0x46, 0x0e, 0x21, 0xef, 0xfa, 0x5e, 0x8d, 0xcc, 0x41, 0x9e, 0x17,
	0x37, 0xdc, 0xd0, 0x76, 0x66, 0xd2, 0x58, 0xce, 0x6b, 0x6c, 0x31, 0x08, 0x39, 0x07, 0x39, 0xa6,
	0x4c, 0x34, 0x08, 0x68, 0x30, 0x93, 0xb9, 0x90, 0xba, 0x92, 0x33, 0x5a, 0x00, 0x32, 0x0f, 0x93,
	0x81, 0x5d, 0x75, 0xcd, 0xb0, 0xe1, 0xd3, 0xb2, 0xe9, 0x54, 0x3d, 0xdf, 0x0e, 0x1f, 0xd7, 0x66,
	0x86, 0x91, 0x07, 0x12, 0x15, 0x2d, 0xca, 0x12, 0xc6, 0x4e, 0xbd, 0xb1, 0xed, 0xd8, 0x95, 0xf2,
	0x2e, 0x6d, 0xce, 0x8c, 0x20, 0x5e, 0x8e, 0x43, 0xee, 0xd2, 0x26, 0x39, 0x0b, 0xb9, 0x5d, 0xda,
	0xe4, 0x56, 0x68, 0x26, 0x8b, 0xad, 0x65, 0x77, 0x69, 0x73, 0x0b, 0x65, 0x7b, 0x1d, 0x08, 0x3d,
	0x08, 0xa9, 0x6b, 0x51, 0xab, 0xdc, 0xc2, 0xca, 0x21, 0x56, 0x41, 0x96, 0xdc, 0x15, 0xd8, 0xfa,
	0x23, 0x98, 0x68, 0x1b, 0x47, 0x32, 0x0c, 0x43, 0xcb, 0x8b, 0x85, 0x13, 0x24, 0x0b, 0xe9, 0xfb,
	0x0f, 0x56, 0x56, 0x0b, 0x1a, 0x19, 0x83, 0xdc, 0xf2, 0xfa, 0xda, 0xea, 0xfd, 0xcd, 0xf2, 0xf2,
	0x62, 0x61, 0x88, 0x00, 0x0c, 0xf3, 0xcf, 0x42, 0x8a, 0xe4, 0x20, 0xb3, 0xb5, 0xc6, 0xc0, 0x69,
	0x56, 0x6f, 0x6b, 0xad, 0x90, 0xb9, 0x93, 0xce, 0xa6, 0x0a, 0x69, 0xdd, 0x83, 0xa9, 0xb8, 0x86,
	0x06, 0x75, 0xcf, 0x0d, 0x28, 0x79, 0x1f, 0x46, 0x2b, 0x0a, 0x7c, 0x46, 0x43, 0x05, 0x78, 0x79,
	0x20, 0x05, 0x10, 0x23, 0x1f, 0x23, 0xa4, 0xcf, 0xc3, 0xb8, 0x28, 0xee, 0x35, 0x1b, 0xee, 0xa4,
	0xb3, 0x43, 0x85, 0x94, 0x7e, 0x1f, 0x60, 0xa3, 0x19, 0x84, 0xb4, 0xb6, 0xe6, 0xee, 0x78, 0x6c,
	0x88, 0x03, 0xfc, 0x2a, 0xb3, 0x05, 0x45, 0x54, 0x80, 0x20, 0x86, 0xb0, 0x4b, 0x7d, 0x97, 0x3a,
	0x1c, 0x81, 0x2b, 0x10, 0x70, 0x10, 0x43, 0xd0, 0xbf, 0x9d, 0x82, 0x89, 0x88, 0x03, 0xd1, 0xdb,
	0x0f, 0xe2, 0x2c, 0x64, 0x96, 0x16, 0x8f, 0x0e, 0xe7, 0x86, 0xef, 0x33, 0x36, 0x56, 0x3e, 0x3d,
	0x9c, 0x7b, 0xad, 0x6a, 0x87, 0x8f, 0x1b, 0xdb, 0xa5, 0x8a, 0x57, 0x9b, 0x8f, 0x04, 0x60, 0x6d,
	0xb7, 0x7e, 0xcf, 0xd7, 0x77, 0xab, 0xf3, 0x62, 0x69, 0x29, 0xf1, 0x6a, 0xb2, 0x17, 0xe4, 0x1d,
	0x18, 0x11, 0x2a, 0x86, 0xcc, 0xe4, 0x17, 0x66, 0x15, 0x21, 0x32, 0x73, 0x56, 0xda, 0x8a, 0x4c,
	0xdd, 0xa2, 0x65, 0xf9, 0x42, 0x6a, 0xb2, 0x12, 0x79, 0x1b, 0x00, 0x57, 0x50, 0xde, 0x9f, 0x14,
	0x92, 0x98, 0x56, 0x48, 0x60, 0x61, 0x89, 0x75, 0x4d, 0xd4, 0xcc, 0x21, 0x04, 0x85, 0xb1, 0x1e,
	0x97, 0x56, 0x1a, 0x2b, 0x7f, 0x2e, 0x61, 0x10, 0x5b, 0x92, 0x16, 0xc4, 0x54, 0xd1, 0x6e, 0x40,
	0x3e, 0xd8, 0x73, 0xca, 0xb2, 0x37, 0x99, 0xbe, 0x7a, 0x43, 0x18, 0x99, 0xa3, 0xc3, 0x39, 0xd8,
	0x78, 0xb4, 0xbe, 0xc8, 0x6b, 0x1a, 0x10, 0xec, 0x39, 0xe2, 0xb7, 0x3e, 0x0e, 0xa3, 0x4c, 0x60,
	0x52, 0x1b, 0xf4, 0xbf, 0x91, 0x82, 0x31, 0x01, 0x10, 0x83, 0x73, 0x1b, 0x32, 0x4c, 0x94, 0x52,
	0x07, 0xaf, 0x77, 0x61, 0x9f, 0x2f, 0x56, 0x72, 0x05, 0xc6, 0x11, 0xd8, 0xc0, 0x0f, 0xd1, 0x0b,
	0x4e, 0x80, 0xfc, 0x53, 0x0d, 0x26, 0xe5, 0x32, 0x54, 0xde, 0x6e, 0x96, 0xe5, 0x98, 0x0f, 0x21,
	0xe1, 0x77, 0x12, 0xe4, 0x12, 0xe3, 0xa8, 0xb4, 0x2e, 0x68, 0x2c, 0x35, 0x71, 0xac, 0xad, 0x55,
	0x37, 0xf4, 0x9b, 0x4b, 0x0f, 0x44, 0x4f, 0x0b, 0x6d, 0xc5, 0x2b, 0xdf, 0xfc, 0xe3, 0x27, 0xd3,
	0xa0, 0x82, 0xd3, 0xd6, 0x4e, 0xf1, 0x9b, 0x1a, 0x4c, 0x77, 0x6d, 0x9c, 0x14, 0x20, 0xc5, 0x6c,
	0x10, 0x6a, 0xaf, 0xc1, 0x7e, 0x92, 0x0d, 0xc8, 0xec, 0x9b, 0x4e, 0x83, 0x5b, 0xf6, 0xf8, 0xaa,
	0xb1, 0xbb, 0x5f, 0x92, 0x4b, 0x75, 0x29, 0x5a, 0x96, 0x5b, 0x4b, 0x35, 0xb6, 0x2f, 0x9b, 0xe1,
	0x72, 0x34, 0x38, 0xad, 0xb7, 0x87, 0xde, 0xd4, 0xf4, 0xdf, 0x4d, 0xc1, 0x74, 0x4c, 0x1e, 0xab,
	0x07, 0x21, 0xf5, 0x5d, 0xd3, 0x21, 0xcb, 0xf1, 0x91, 0x7a, 0xb1, 0x87, 0x40, 0x65, 0xfd, 0xf8,
	0x20, 0xfd, 0x61, 0xe2, 0x20, 0xbd, 0xdb, 0xef, 0x20, 0x49, 0xa6, 0xfe, 0x3f, 0x1f, 0xac, 0x5b,
	0x90, 0x5d, 0xf7, 0x2a, 0xa6, 0x63, 0x87, 0x4d, 0xf2, 0x79, 0xc8, 0x84, 0x36, 0xf5, 0xe5, 0xf0,
	0xcc, 0x25, 0x88, 0x72, 0xd3, 0xa6, 0xd2, 0x10, 0xf1, 0x3a, 0x7a, 0x09, 0xd2, 0x0c, 0xa8, 0xf2,
	0x9e, 0xe3, 0xbc, 0x4f, 0xa9, 0xbc, 0xe7, 0x44, 0xe3, 0xfa, 0xaf, 0x6b, 0x30, 0xf2, 0x1e, 0xf5,
	0x03, 0xdb, 0x73, 0xc9, 0x65, 0xc8, 0xd5, 0xcc, 0x0f, 0x3d, 0xbf, 0xbc, 0x6f, 0x3a, 0xc2, 0xc0,
	0xe6, 0x8e, 0x0e, 0xe7, 0x32, 0xf7, 0x18, 0xd0, 0xc8, 0x62, 0xd9, 0x7b, 0xa6, 0x83, 0x78, 0xb6,
	0x2b, 0xf0, 0x86, 0x14, 0x3c, 0x06, 0x34, 0xb2, 0x58, 0xc6, 0xf0, 0xa6, 0x20, 0x53, 0x37, 0xc3,
	0xca, 0x63, 0xb4, 0x86, 0x19, 0x83, 0x7f, 0x90, 0x22, 0x64, 0x6d, 0x97, 0x0f, 0x3a, 0x5a, 0xba,
	0x8c, 0x11, 0x7d, 0xeb, 0xbf, 0x92, 0x81, 0x71, 0x26, 0xa8, 0x15, 0x1a, 0x54, 0x7c, 0xbb, 0x1e,
	0x7a, 0xfe, 0x9f, 0x68, 0x9b, 0xff, 0x16, 0x64, 0xcc, 0x30, 0xf4, 0x03, 0x61, 0xee, 0xcf, 0x2b,
	0xb5, 0x65, 0x8b, 0x8b, 0x61, 0xe8, 0xdb, 0xdb, 0x8d, 0x90, 0x46, 0x36, 0x0e, 0x6b, 0x90, 0x55,
	0xc8, 0x3a, 0x62, 0xc0, 0x85, 0xbd, 0xbf, 0x94, 0x30, 0xce, 0x52, 0x37, 0x04, 0x8d, 0xa8, 0x2a,
	0xb9, 0x0f, 0x63, 0x1b, 0x88, 0x24, 0xc6, 0x50, 0x58, 0x7b, 0x3d, 0x81, 0x96, 0xc0, 0x14, 0xa4,
	0xe2, 0xd5, 0x99, 0x2f, 0xc4, 0x57, 0xb1, 0xd0, 0xac, 0x0a, 0x8f, 0x2a, 0x8b, 0x80, 0x4d, 0xb3,
	0xca, 0xfc, 0xa8, 0x20, 0x34, 0xfd, 0x90, 0xf9, 0xfa, 0x21, 0xfa, 0x51, 0x29, 0x23, 0x27, 0x20,
	0x8b, 0x21, 0xd9, 0x80, 0x82, 0xe4, 0x2b, 0x5a, 0x7c, 0xb2, 0xa8, 0xc2, 0x7a, 0x17, 0xc1, 0xc8,
	0x2e, 0x89, 0x05, 0x46, 0xb0, 0x33, 0xe1, 0xc4, 0xc1, 0xe4, 0x22, 0x8c, 0x56, 0x9c, 0x46, 0x10,
	0x52, 0xbf, 0xec, 0x9a, 0x35, 0xe6, 0x79, 0x31, 0x9e, 0xf2, 0x02, 0x76, 0xdf, 0xac, 0xd1, 0xf6,
	0xf5, 0x0e, 0x9e, 0xc9, 0x7a, 0xf7, 0x31, 0xe4, 0x1f, 0x52, 0xbf, 0xc2, 0x76, 0x80, 0x0e, 0x0d,
	0xd8, 0x74, 0xaa, 0xbf, 0xfa, 0x0a, 0x6a, 0xa0, 0x66, 0xb0, 0x9f, 0x08, 0x59, 0xb8, 0x81, 0x7a,
	0xc3, 0x20, 0x0b, 0x37, 0x10, 0x72, 0xe3, 0x15, 0xd4, 0x05, 0x06, 0xb9, 0xc1, 0x71, 0x6e, 0xde,
	0xc0, 0xf1, 0x65, 0x90, 0x9b, 0x1c, 0xe7, 0xad, 0x57, 0x70, 0x94, 0x18, 0xe4, 0xad, 0x57, 0x08,
	0x81, 0x74, 0xfd, 0x9e, 0x79, 0x80, 0xc2, 0xd6, 0x0c, 0xfc, 0xad, 0xff, 0xbd, 0x21, 0x98, 0xd8,
	0x08, 0x3d, 0x5f, 0x9d, 0x07, 0xbf, 0x04, 0x59, 0xb6, 0x53, 0x54, 0x26, 0xc2, 0xf2, 0xd1, 0xe1,
	0xdc, 0x08, 0xa2, 0xe1, 0x4c, 0x78, 0x7d, 0xa0, 0x99, 0x20, 0xea, 0x19, 0x23, 0x48, 0x74, 0xcd,
	0x6a, 0xe9, 0xf2, 0xd0, 0xc0, 0xba, 0xbc, 0x0c, 0x69, 0x36, 0xa1, 0xc4, 0x2c, 0xb8, 0xda, 0xc3,
	0xf4, 0xb7, 0xfa, 0x24, 0xa8, 0x60, 0x65, 0xb2, 0x04, 0xd9, 0x8a, 0x59, 0x37, 0x2b, 0xad, 0x09,
	0x71, 0xa1, 0x0b, 0x0b, 0xc8, 0xf6, 0xb2, 0xc0, 0x93, 0xb3, 0x41, 0xd6, 0xd3, 0x0f, 0x35, 0xc8,
	0x23, 0x06, 0x37, 0xb0, 0x64, 0x05, 0xd2, 0x16, 0x0d, 0x2a, 0x28, 0xaf, 0xfc, 0xc2, 0xb5, 0x24,
	0x87, 0x2a, 0x2e, 0x6d, 0xc9, 0x19, 0xab, 0x4d, 0xee, 0xc1, 0x48, 0x8d, 0x86, 0xbe, 0x5d, 0x09,
	0xc4, 0xe2, 0xf6, 0x5a, 0x2f, 0x42, 0xbc, 0xf9, 0xd2, 0x3d, 0x5e, 0x0b, 0x17, 0x13, 0x43, 0xd2,
	0x28, 0xbe, 0x0d, 0xa3, 0x6a, 0x41, 0x2f, 0x4b, 0xad, 0xa9, 0xcb, 0xc4, 0xbf, 0xcf, 0x72, 0x37,
	0x2c, 0x72, 0xba, 0x96, 0x63, 0x3d, 0x1c, 0x5c, 0xf4, 0xd8, 0xc1, 0xb8, 0xeb, 0x3a, 0x34, 0x90,
	0xeb, 0x1a, 0xb7, 0x09, 0xa9, 0x76, 0x9b, 0x70, 0x1e, 0xa0, 0x51, 0xb7, 0x4c, 0x51, 0xcc, 0x77,
	0x7a, 0x39, 0x01, 0x59, 0x0c, 0xc9, 0xfd, 0x96, 0x68, 0x33, 0x3d, 0xb7, 0xae, 0x6a, 0xc7, 0xbb,
	0xcb, 0x96, 0x6c, 0xc0, 0x38, 0x9f, 0x24, 0xdc, 0xc7, 0xa4, 0xc1, 0xcc, 0x30, 0x92, 0xbd, 0xdc,
	0xdf, 0x88, 0x49, 0x9b, 0x18, 0xb4, 0x40, 0x34, 0x60, 0x33, 0xd4, 0xf4, 0xab, 0xc1, 0xcc, 0x08,
	0x6e, 0xfa, 0xf0, 0x37, 0x1b, 0x34, 0xea, 0xee, 0x8b, 0xdd, 0x22, 0xfb, 0x49, 0xbe, 0xab, 0x41,
	0xce, 0x31, 0x43, 0xea, 0x56, 0x6c, 0x1a, 0xe0, 0x06, 0x31, 0xbf, 0xf0, 0x46, 0xbf, 0xbd, 0x59,
	0x97, 0x15, 0xb9, 0xd7, 0xf3, 0x79, 0xc6, 0xc6, 0x93, 0x7a, 0x38, 0x2d, 0x2e, 0xc8, 0x77, 0x34,
	0xc8, 0x9a, 0x95, 0xd0, 0xde, 0x67, 0x93, 0x0a, 0x90, 0xa5, 0x1b, 0xfd, 0xb2, 0xb4, 0x28, 0xea,
	0x3d, 0x03, 0x8e, 0x22, 0x1e, 0x48, 0x09, 0x26, 0x43, 0x2f, 0x34, 0x9d, 0xb2, 0xd8, 0xee, 0xd4,
	0x68, 0xcd, 0xf3, 0x9b, 0x33, 0x79, 0xd4, 0x8b, 0x93, 0x58, 0xc4, 0xb7, 0x36, 0xf7, 0xb0, 0x80,
	0x9c, 0x81, 0xac, 0xdb, 0xa8, 0x95, 0x2b, 0xf5, 0x46, 0x30, 0x33, 0x8a, 0xbe, 0xc2, 0x88, 0xdb,
	0xa8, 0x2d, 0xd7, 0x1b, 0x4f, 0x35, 0x8d, 0x8a, 0x5f, 0x80, 0xf1, 0xb8, 0xc4, 0xbb, 0xb8, 0x7a,
	0xb1, 0xda, 0x29, 0xb5, 0x76, 0x05, 0x26, 0xee, 0xd3, 0xf0, 0x23, 0xcf, 0xdf, 0x95, 0x32, 0xe2,
	0x3e, 0x4d, 0xc5, 0xab, 0xd9, 0x6e, 0x15, 0x69, 0xa4, 0x8c, 0xe8, 0x9b, 0x95, 0x79, 0x8d, 0xb0,
	0xea, 0xb1, 0x32, 0x4e, 0x2b, 0xfa, 0x26, 0x33, 0x30, 0xc2, 0x47, 0xab, 0x29, 0xa6, 0x8e, 0xfc,
	0x2c, 0x86, 0x30, 0x16, 0x1b, 0x81, 0x2e, 0x1c, 0xde, 0x53, 0x39, 0xcc, 0x2f, 0xdc, 0xec, 0x77,
	0x64, 0xdb, 0x98, 0x57, 0xed, 0x4b, 0x01, 0xc6, 0x0d, 0x5a, 0xb5, 0x3d, 0x37, 0xda, 0xe7, 0xfd,
	0x2f, 0x0d, 0x26, 0x22, 0x90, 0x30, 0x3a, 0x8f, 0x60, 0xc4, 0xe7, 0x20, 0xe1, 0xa2, 0x26, 0x35,
	0xdd, 0x56, 0x59, 0x7e, 0x8b, 0x89, 0x2b, 0xe8, 0x14, 0x67, 0x61, 0x98, 0x17, 0x30, 0xb9, 0x7f,
	0xd5, 0x73, 0xc5, 0xe6, 0x24, 0x67, 0xf0, 0x8f, 0x62, 0x0d, 0x46, 0xd5, 0x8a, 0x5d, 0x46, 0xfb,
	0x56, 0x5c, 0x1a, 0xaf, 0x0e, 0xcc, 0x92, 0x2a, 0x87, 0xcb, 0x90, 0xe7, 0x22, 0xeb, 0x71, 0x10,
	0xf8, 0xfb, 0x69, 0xc8, 0x19, 0xe6, 0x4e, 0xc8, 0x6c, 0x05, 0x25, 0xd7, 0x01, 0x7c, 0x5a, 0x77,
	0xec, 0x8a, 0x29, 0x31, 0xd3, 0x4b, 0x63, 0x47, 0x87, 0x73, 0x39, 0x83, 0x43, 0xd9, 0xe4, 0x14,
	0x08, 0x6b, 0x16, 0x79, 0x03, 0xe0, 0xb1, 0xe9, 0x5b, 0x68, 0xaa, 0x24, 0xd7, 0x27, 0x4b, 0xfc,
	0x44, 0xb4, 0x74, 0xdb, 0xf4, 0x2d, 0x24, 0x2a, 0x2d, 0xee, 0x63, 0x09, 0x60, 0xe6, 0xc8, 0xa1,
	0xa6, 0x85, 0x0a, 0x93, 0x36, 0xf0, 0x37, 0x13, 0x1a, 0x27, 0x93, 0xe6, 0xbe, 0x3d, 0x7e, 0x30,
	0xed, 0x32, 0xeb, 0x75, 0xc7, 0xa6, 0x16, 0x3a, 0x1c, 0x69, 0x43, 0x7e, 0x92, 0x4d, 0xc8, 0xd6,
	0x7d, 0xaf, 0x8a, 0xfe, 0x12, 0xb7, 0x90, 0x0b, 0x49, 0xf2, 0x92, 0x3d, 0x2c, 0x3d, 0x14, 0x95,
	0xb8, 0x51, 0x10, 0xcb, 0xaf, 0xa4, 0x44, 0x5e, 0x84, 0x09, 0xc6, 0x4d, 0x39, 0xf4, 0x4d, 0x37,
	0xd8, 0xa1, 0x3e, 0xa5, 0xe8, 0x24, 0xa6, 0x8d, 0x71, 0x06, 0xde, 0x8c, 0xa0, 0xc5, 0xbf, 0xa8,
	0x41, 0x56, 0x92, 0x62, 0xbc, 0xd7, 0x70, 0x97, 0x80, 0x02, 0x33, 0xf8, 0x07, 0xeb, 0xa5, 0x4b,
	0x0f, 0xf8, 0xc9, 0x62, 0xda, 0xc0, 0xdf, 0xad, 0x5e, 0xa6, 0xd4, 0x5e, 0x9e, 0x82, 0xe1, 0xba,
	0xd9, 0x08, 0xa8, 0x85, 0x9d, 0xcf, 0x1a, 0xe2, 0x8b, 0x5c, 0x85, 0x42, 0x9d, 0xba, 0x96, 0xed,
	0x56, 0xcb, 0x81, 0x6b, 0xd6, 0x83, 0xc7, 0x5e, 0x28, 0xc4, 0x30, 0x21, 0xe0, 0x1b, 0x02, 0x5c,
	0xfc, 0x10, 0xc6, 0x62, 0x3d, 0x53, 0xd5, 0x2b, 0xcd, 0xd5, 0x6b, 0x39, 0xae, 0x5e, 0x2f, 0x0f,
	0x24, 0x2e, 0x55, 0xb5, 0x8e, 0x86, 0x60, 0xcc, 0x30, 0xdd, 0x2a, 0x7d, 0xe8, 0x7b, 0xdb, 0x0e,
	0xad, 0x05, 0xe4, 0x02, 0xe4, 0x1b, 0xae, 0xb9, 0x6f, 0xda, 0x8e, 0xb9, 0xed, 0xf0, 0xd3, 0xe3,
	0xac, 0xa1, 0x82, 0xc8, 0x0d, 0x38, 0xcd, 0x24, 0xc8, 0x7c, 0x60, 0x2f, 0x2c, 0xf3, 0x93, 0xff,
	0xc7, 0x9e, 0x63, 0x51, 0x1f, 0xd9, 0xc9, 0x1a, 0x53, 0xbc, 0xf8, 0xbe, 0x17, 0xae, 0xb3, 0xc2,
	0xdb, 0x58, 0x46, 0x5e, 0x80, 0x71, 0xd7, 0x2b, 0x33, 0x8d, 0x2a, 0xf3, 0x72, 0x14, 0x5c, 0xd6,
	0x18, 0x75, 0x3d, 0xc6, 0xe3, 0x3a, 0xc2, 0xc8, 0x15, 0x98, 0x68, 0xb8, 0x16, 0xf5, 0x85, 0x66,
	0x86, 0x91, 0x20, 0xdb, 0xc1, 0xe4, 0x32, 0x8c, 0x7b, 0xfb, 0x31, 0xc4, 0x2c, 0x22, 0xb6, 0x41,
	0xd1, 0x6a, 0x7b, 0x9c, 0x4d, 0x94, 0x78, 0xd6, 0x18, 0x71, 0x3d, 0x64, 0x8c, 0xbc, 0x09, 0x33,
	0x7b, 0x0d, 0x9b, 0x06, 0xcc, 0xb1, 0x2e, 0xd3, 0xbd, 0x86, 0xe9, 0x04, 0xe5, 0xd0, 0xae, 0xec,
	0x32, 0xe3, 0x38, 0x8c, 0xa8, 0xa7, 0xa2, 0xf2, 0x55, 0x2c, 0xde, 0xe4, 0xa5, 0xe4, 0x25, 0x20,
	0xbc, 0x27, 0x5e, 0xb5, 0x1c, 0x7a, 0x5e, 0xd9, 0x31, 0xfd, 0x2a, 0xd7, 0xaf, 0xac, 0x31, 0xc1,
	0x4a, 0xd6, 0xbd, 0xea, 0xa6, 0xe7, 0xad, 0x33, 0xb0, 0xbe, 0x0b, 0x13, 0x28, 0x63, 0x36, 0x0c,
	0x36, 0x06, 0x83, 0xc8, 0x75, 0x20, 0x7b, 0x0d, 0xea, 0xdb, 0x34, 0x28, 0xd7, 0xa9, 0x5f, 0x0e,
	0x68, 0xc5, 0x73, 0x2d, 0xe1, 0xd0, 0x17, 0x44, 0xc9, 0x43, 0xea, 0x6f, 0x20, 0x9c, 0x5c, 0x83,
	0x93, 0x1f, 0xf9, 0x76, 0x18, 0x47, 0xe6, 0xeb, 0xc8, 0x04, 0x2f, 0x88, 0x70, 0xf5, 0xdb, 0x00,
	0x0f, 0x7d, 0x1a, 0x86, 0xcd, 0x8d, 0xba, 0x89, 0x3b, 0x28, 0x74, 0x7f, 0xca, 0x2d, 0xfb, 0x94,
	0x45, 0xc0, 0x5d, 0xda, 0x64, 0x86, 0x84, 0xba, 0x78, 0x90, 0x2c, 0x76, 0xe1, 0xc3, 0xd4, 0xb5,
	0xee, 0xd2, 0xe6, 0xdb, 0xe9, 0xff, 0xfa, 0xdb, 0x73, 0x9a, 0xfe, 0xbd, 0x3c, 0x33, 0x27, 0x6e,
	0x95, 0xa2, 0x6b, 0xf5, 0x0b, 0x90, 0x0e, 0xea, 0xa6, 0x2b, 0x7c, 0xbb, 0xa4, 0xe3, 0xc0, 0x56,
	0xf3, 0xd2, 0xaf, 0x63, 0x15, 0xc9, 0x1a, 0x00, 0x8a, 0x4c, 0xb5, 0x30, 0x2f, 0xf4, 0xa3, 0xb8,
	0xd2, 0xe8, 0xf8, 0x91, 0x69, 0x7b, 0x57, 0x35, 0x30, 0x71, 0x57, 0x5a, 0x3d, 0xf8, 0x10, 0xb1,
	0x2c, 0xa4, 0x25, 0xba, 0x21, 0xb7, 0x0a, 0x7c, 0xb2, 0xd6, 0x60, 0x3c, 0xf0, 0x1a, 0x7e, 0x85,
	0x46, 0xe7, 0x45, 0x19, 0xdc, 0xcb, 0xdc, 0x3a, 0x3a, 0x9c, 0x1b, 0xdd, 0xc0, 0x92, 0xa7, 0xdb,
	0xda, 0x8f, 0x06, 0x2d, 0x22, 0x16, 0xd9, 0x83, 0x09, 0xd1, 0x5c, 0xb4, 0x77, 0x1a, 0xc6, 0xf6,
	0xd6, 0x8e, 0x0e, 0xe7, 0xc6, 0x78, 0x7b, 0x4f, 0xbb, 0x83, 0x1a, 0x0b, 0x14, 0x32, 0x56, 0x67,
	0xc4, 0x66, 0xa4, 0x4b, 0xc4, 0x66, 0x19, 0xc6, 0xc4, 0x2c, 0xb6, 0x19, 0x63, 0x4d, 0xb1, 0x4f,
	0x9e, 0xe9, 0xb6, 0x4f, 0x66, 0x78, 0xf2, 0x88, 0x1e, 0x2b, 0xdd, 0xe6, 0x75, 0xc8, 0x1d, 0x34,
	0xe2, 0x68, 0x43, 0x70, 0x5b, 0x9c, 0x5f, 0xb8, 0x92, 0x38, 0xb8, 0x8a, 0xcd, 0x51, 0x4c, 0x37,
	0xb7, 0x41, 0x62, 0x7c, 0xe5, 0xee, 0xf9, 0x5a, 0x2f, 0x42, 0xad, 0x89, 0xa5, 0x8e, 0x6f, 0x40,
	0xb6, 0x60, 0x54, 0x0d, 0x4c, 0xce, 0x8c, 0x21, 0xb9, 0xeb, 0x3d, 0xd5, 0x05, 0x7b, 0x19, 0x73,
	0xc2, 0xf3, 0x4e, 0x0b, 0x44, 0xce, 0x41, 0x2e, 0x32, 0x0b, 0x33, 0xe3, 0x38, 0xe7, 0x5b, 0x00,
	0xb6, 0xce, 0x49, 0x1b, 0x32, 0xc1, 0xcd, 0x8d, 0xf8, 0x24, 0x17, 0x61, 0xd4, 0x67, 0x2b, 0x92,
	0xc3, 0xd6, 0x14, 0x1a, 0xcc, 0x14, 0xd0, 0xc9, 0xca, 0x33, 0xd8, 0x3a, 0x07, 0xb1, 0xf1, 0xc2,
	0x09, 0x1d, 0xe1, 0x9c, 0x44, 0x9c, 0x51, 0x04, 0x4a, 0xa4, 0x29, 0xc8, 0x38, 0x5e, 0x65, 0x37,
	0x98, 0x21, 0xdc, 0x19, 0xc4, 0x0f, 0xf2, 0x1a, 0x9c, 0xc2, 0x1f, 0xe5, 0x8f, 0xec, 0xf0, 0x71,
	0xf9, 0x23, 0xd3, 0x0e, 0xcb, 0x7b, 0x0d, 0xda, 0xa0, 0xc1, 0xcc, 0x24, 0xa2, 0x4d, 0x62, 0xe9,
	0xfb, 0x76, 0xf8, 0xf8, 0x7d, 0xd3, 0x0e, 0x1f, 0x61, 0x11, 0xda, 0x72, 0xaf, 0xb2, 0xab, 0xa0,
	0xe3, 0x4f, 0xea, 0x07, 0x33, 0x53, 0x58, 0x6b, 0x8a, 0x15, 0x47, 0x15, 0xde, 0xe7, 0x65, 0xe4,
	0x63, 0xb8, 0x18, 0x7a, 0xf5, 0xf2, 0x6e, 0x99, 0xb7, 0xb8, 0xdd, 0xec, 0x46, 0x60, 0xba, 0x67,
	0xf4, 0x27, 0x9a, 0x96, 0xa5, 0x75, 0xaf, 0xb2, 0xab, 0xcc, 0xcf, 0xb3, 0xa1, 0x57, 0xbf, 0xcb,
	0x60, 0xc1, 0x52, 0xb3, 0xbd, 0xf1, 0xe2, 0xff, 0xd4, 0xf0, 0x78, 0x72, 0x57, 0xee, 0xf8, 0xea,
	0x68, 0x6f, 0x14, 0x0b, 0x97, 0xe3, 0x10, 0x66, 0xe2, 0xde, 0xe5, 0x4b, 0x27, 0xb3, 0x36, 0xa3,
	0x4b, 0xaf, 0x7f, 0x7a, 0x38, 0xf7, 0xca, 0x40, 0xb3, 0xea, 0x2e, 0x6d, 0xf2, 0x05, 0x97, 0x40,
	0xfa, 0x31, 0x75, 0x2c, 0xb1, 0x64, 0xe1, 0x6f, 0x36, 0xd0, 0xb2, 0xab, 0x7c, 0x2b, 0x29, 0x3f,
	0x99, 0xeb, 0xc1, 0x7e, 0xb2, 0xc5, 0xde, 0xc7, 0x65, 0x8d, 0xc7, 0x3d, 0x52, 0xc6, 0xb8, 0x00,
	0x1b, 0x1c, 0xaa, 0x22, 0xe2, 0x08, 0xfb, 0x01, 0x5a, 0x84, 0x16, 0xe2, 0xfb, 0x1c, 0x7a, 0x27,
	0x9d, 0xcd, 0x17, 0x46, 0xef, 0xa4, 0xb3, 0xa3, 0x85, 0x31, 0xfd, 0xd7, 0x35, 0xb1, 0x66, 0xf7,
	0x0c, 0x86, 0x11, 0x13, 0x72, 0x3e, 0xc3, 0x2c, 0xdb, 0x16, 0x3f, 0x2e, 0x48, 0x2d, 0xad, 0x1c,
	0x1d, 0xce, 0x65, 0xb9, 0xe0, 0x57, 0x82, 0x81, 0xcd, 0x8c, 0xa8, 0x68, 0x64, 0x91, 0xec, 0x9a,
	0x15, 0xe8, 0x9b, 0x30, 0x2e, 0x99, 0x11, 0x0e, 0xf9, 0x12, 0x0c, 0x63, 0xa9, 0xf4, 0xc7, 0x5f,
	0xe8, 0x47, 0x03, 0x64, 0xc0, 0x97, 0xd7, 0xd4, 0xaf, 0xc0, 0xd8, 0x2d, 0x4c, 0xf4, 0xe8, 0xe9,
	0xf4, 0xfe, 0x60, 0x08, 0x26, 0x56, 0x31, 0x59, 0x81, 0xcd, 0xce, 0x00, 0x95, 0xe2, 0x79, 0x9f,
	0x4e, 0xed, 0xc0, 0x29, 0x36, 0xa7, 0xa9, 0x1f, 0x94, 0x4d, 0xd7, 0xe2, 0x66, 0xb3, 0xea, 0x9b,
	0x35, 0x79, 0x5c, 0xf5, 0x8a, 0xda, 0x63, 0x6e, 0x55, 0x4a, 0x32, 0xa1, 0xa2, 0xb4, 0xc9, 0x6b,
	0x2e, 0xba, 0xd6, 0xed, 0xa8, 0x9e, 0x31, 0x15, 0x76, 0x81, 0x92, 0x5b, 0x90, 0xe7, 0xd5, 0xca,
	0x18, 0xc9, 0x4f, 0xe1, 0x31, 0xff, 0xe5, 0x24, 0xe2, 0x5c, 0x12, 0x18, 0xb2, 0x07, 0x1a, 0xfd,
	0xd6, 0x5f, 0x06, 0xa2, 0xc8, 0xa8, 0xa7, 0x4c, 0xff, 0x14, 0x4c, 0xc6, 0xd0, 0xc5, 0xc0, 0x46,
	0x66, 0x99, 0x8f, 0x6b, 0x92, 0x59, 0x6e, 0x1b, 0x91, 0x98, 0x59, 0xd6, 0xff, 0x34, 0xc0, 0xa6,
	0x6f, 0x56, 0xe8, 0xea, 0x3e, 0xb3, 0x97, 0x6f, 0x42, 0x3a, 0xb4, 0x6b, 0x54, 0x38, 0x16, 0xc5,
	0x12, 0xcf, 0x8e, 0x28, 0xc9, 0xec, 0x88, 0xd2, 0xa6, 0x4c, 0x9f, 0x58, 0xca, 0x32, 0x22, 0xbf,
	0xf9, 0xc7, 0x73, 0x9a, 0x81, 0x35, 0xd8, 0x04, 0x8c, 0x27, 0x22, 0xc8, 0x4f, 0xfd, 0xf7, 0x35,
	0x98, 0x58, 0x74, 0x1c, 0xaf, 0x62, 0x86, 0x9e, 0xbf, 0xe2, 0x37, 0x8d, 0x86, 0xcb, 0x94, 0x42,
	0xce, 0x05, 0xbe, 0x2b, 0xe6, 0x4a, 0x21, 0x34, 0xfa, 0x89, 0x67, 0xc2, 0x88, 0x98, 0x09, 0xe4,
	0x8b, 0x30, 0x4c, 0x59, 0x87, 0xe4, 0xb9, 0x5c, 0x92, 0x8b, 0xd4, 0xea, 0xbe, 0x21, 0x2a, 0xe9,
	0x0b, 0x30, 0x1d, 0x71, 0x8c, 0xb4, 0xe5, 0x28, 0x9d, 0x69, 0xe7, 0x3b, 0x6a, 0x52, 0xff, 0x47,
	0x1a, 0x9c, 0x6a, 0xaf, 0xd4, 0x3d, 0x38, 0x9d, 0x7a, 0x96, 0x81, 0x8a, 0x65, 0x18, 0xb1, 0xfc,
	0x66, 0xd9, 0x6f, 0xb8, 0x42, 0xdf, 0x93, 0x34, 0xa1, 0x6d, 0x18, 0x8c, 0x61, 0x0b, 0xff, 0xd5,
	0xbf, 0xa3, 0x41, 0xa1, 0xc5, 0xfb, 0x9f, 0x00, 0x43, 0xf6, 0x01, 0x9c, 0x54, 0xf8, 0x11, 0x62,
	0x5c, 0x85, 0xac, 0xe8, 0x6a, 0x3f, 0x5a, 0xdf, 0xde, 0xd7, 0x11, 0xde, 0xd7, 0x40, 0xd7, 0x61,
	0xf4, 0xce, 0xc6, 0x83, 0xfb, 0x11, 0x59, 0x02, 0x69, 0xcb, 0x0c, 0x4d, 0xec, 0xe4, 0xa8, 0x81,
	0xbf, 0xf5, 0x1a, 0x8c, 0x45, 0x61, 0x48, 0xe6, 0x9d, 0xb1, 0x65, 0x1e, 0xdd, 0x34, 0x21, 0x0a,
	0xfe, 0xc1, 0xaa, 0x56, 0x3c, 0x8b, 0x6b, 0x7c, 0xc6, 0xc0, 0xdf, 0xea, 0x44, 0x48, 0xc5, 0x26,
	0x02, 0x2b, 0xb1, 0x78, 0xda, 0x02, 0x66, 0xe3, 0xe4, 0x0c, 0xf9, 0xa9, 0xff, 0x33, 0x0d, 0xf2,
	0xeb, 0x5e, 0xb5, 0xf7, 0x1a, 0xc2, 0xbc, 0x0d, 0xba, 0x4f, 0x1d, 0x19, 0xa9, 0xc3, 0x8f, 0xe8,
	0xa4, 0xb5, 0x8c, 0x73, 0x97, 0xb7, 0xca, 0xb7, 0x1a, 0x6c, 0xbe, 0x32, 0xa5, 0x65, 0x5b, 0x0b,
	0x2c, 0xe4, 0xa7, 0x00, 0x6c, 0xab, 0x81, 0x45, 0x05, 0x48, 0xd5, 0xcc, 0x03, 0x5c, 0x10, 0x73,
	0x06, 0xfb, 0xc9, 0x98, 0xac, 0x9b, 0x61, 0x48, 0x7d, 0x57, 0x04, 0x79, 0xe4, 0x27, 0xdb, 0x4d,
	0xfb, 0xd4, 0x32, 0x2b, 0xa1, 0xd8, 0x5a, 0x89, 0xaf, 0x3b, 0xe9, 0x6c, 0xb6, 0x90, 0xd3, 0x1f,
	0x00, 0x59, 0xf7, 0xaa, 0x6c, 0x8f, 0x6c, 0x2b, 0xcb, 0xcf, 0x5b, 0x6c, 0x57, 0x83, 0x20, 0x31,
	0x62, 0x67, 0xda, 0x83, 0x2f, 0x8e, 0x57, 0x2d, 0xa9, 0x67, 0x06, 0x12, 0x5f, 0x2f, 0xc1, 0xe4,
	0xba, 0x57, 0x7d, 0xd7, 0x76, 0x68, 0xb0, 0x6e, 0x07, 0x61, 0x4f, 0x3b, 0xf9, 0x10, 0xa6, 0xe2,
	0xf8, 0x82, 0x85, 0x37, 0x21, 0xb3, 0xc3, 0x80, 0x82, 0x81, 0x73, 0xdd, 0x18, 0x60, 0xb5, 0x54,
	0xd3, 0x88, 0x15, 0xf4, 0xaf, 0xc0, 0xb8, 0xa0, 0xd8, 0x73, 0x5c, 0x08, 0xa4, 0x59, 0x1d, 0x31,
	0x2c, 0xf8, 0x5b, 0x91, 0x57, 0xaa, 0x4d, 0x5e, 0xe9, 0x42, 0x46, 0xaf, 0xc0, 0xd8, 0x46, 0x68,
	0x56, 0x76, 0x7b, 0x8f, 0xf9, 0x5b, 0x22, 0x77, 0x8c, 0x07, 0x96, 0x13, 0x73, 0x3f, 0x90, 0x60,
	0x2b, 0x47, 0x4c, 0xdf, 0x80, 0x34, 0x63, 0x1f, 0x8f, 0x4c, 0x4c, 0x61, 0xd6, 0x73, 0x06, 0xfe,
	0x66, 0xbb, 0x51, 0xc6, 0x66, 0x39, 0xb0, 0xbf, 0x2a, 0x4f, 0x32, 0xb3, 0x0c, 0xb0, 0x61, 0x7f,
	0x95, 0x92, 0x22, 0x64, 0x45, 0x96, 0x23, 0x8f, 0x60, 0x8e, 0x1a, 0xd1, 0xb7, 0xfe, 0xd7, 0x34,
	0x98, 0xb8, 0x45, 0x43, 0x94, 0x74, 0x4f, 0xe6, 0xcf, 0x42, 0xce, 0xb1, 0x83, 0xb0, 0xec, 0xb9,
	0x4e, 0x53, 0x9c, 0x48, 0x64, 0x19, 0xe0, 0x81, 0xeb, 0x34, 0xc9, 0x4d, 0xd1, 0xb3, 0x0c, 0xf6,
	0x2c, 0x29, 0xca, 0xc9, 0x1a, 0x53, 0x72, 0xdf, 0x8a, 0x90, 0x15, 0x5a, 0xc9, 0x0f, 0xa9, 0x72,
	0x46, 0xf4, 0xad, 0xaf, 0x41, 0xa1, 0xc5, 0x9d, 0xd0, 0x81, 0x1b, 0x71, 0x1d, 0x98, 0xeb, 0xd1,
	0x92, 0x54, 0x80, 0xff, 0xa3, 0xc1, 0xf8, 0x43, 0xdf, 0xdb, 0xe9, 0x47, 0x03, 0x96, 0x62, 0x7d,
	0x29, 0x25, 0x6e, 0xc9, 0x55, 0x8a, 0x25, 0xa5, 0x5b, 0x33, 0x30, 0xc2, 0xcf, 0x13, 0xb8, 0xe7,
	0x99, 0x31, 0xe4, 0x27, 0xd3, 0x25, 0xc7, 0xdc, 0xa6, 0x4e, 0x20, 0xe7, 0x1e, 0xff, 0xd2, 0x7f,
	0x11, 0xd2, 0x98, 0x4a, 0x96, 0x85, 0xf4, 0xed, 0xd5, 0xc5, 0x87, 0x85, 0x13, 0x64, 0x04, 0x52,
	0xcb, 0x0f, 0xb7, 0x78, 0x2e, 0xd9, 0xad, 0x07, 0xc6, 0x83, 0xad, 0xcd, 0xb5, 0xfb, 0xab, 0x85,
	0x21, 0x52, 0x80, 0xd1, 0xcd, 0xdb, 0xc6, 0xea, 0xe2, 0xca, 0xb2, 0xb1, 0xba, 0xb8, 0xb9, 0x5a,
	0x48, 0x11, 0x80, 0xe1, 0xc5, 0xf5, 0xf5, 0x07, 0xcb, 0x1b, 0x85, 0x34, 0xc9, 0x41, 0x66, 0x69,
	0xfd, 0xc1, 0xf2, 0xdd, 0x42, 0x86, 0xfd, 0xbc, 0xb7, 0xb5, 0xb9, 0xfa, 0xe5, 0xc2, 0xb0, 0x7e,
	0x15, 0xc6, 0xc5, 0x41, 0x7a, 0xcf, 0xd9, 0xf7, 0x77, 0xd0, 0x0f, 0xde, 0x09, 0xd1, 0x94, 0xb3,
	0x25, 0xea, 0xb9, 0x46, 0xe7, 0xbf, 0x04, 0x19, 0x5c, 0x2a, 0xfa, 0x3a, 0xb9, 0x68, 0x3b, 0x6d,
	0xc0, 0x8a, 0xfa, 0x35, 0xe6, 0x29, 0x0b, 0x76, 0xb9, 0x85, 0x57, 0xec, 0xb6, 0x16, 0x77, 0x60,
	0xbe, 0x31, 0x04, 0x13, 0x11, 0xb2, 0xd8, 0x76, 0x3e, 0x6f, 0x07, 0xe6, 0x16, 0x0c, 0xe3, 0x12,
	0x23, 0x1d, 0x98, 0xab, 0x3d, 0x0e, 0x67, 0x5a, 0x1d, 0x91, 0xce, 0x3b, 0xaf, 0x4e, 0x56, 0x64,
	0x46, 0x4f, 0x0a, 0xe9, 0x5c, 0xe9, 0x87, 0x0e, 0x93, 0x76, 0x2c, 0xa5, 0x47, 0x6f, 0x40, 0x81,
	0x95, 0xae, 0xd0, 0xed, 0x46, 0x55, 0xea, 0x42, 0xcc, 0x0d, 0xd0, 0x9e, 0x8b, 0x1b, 0xf0, 0x6f,
	0x86, 0xe0, 0xa4, 0xd2, 0xae, 0x98, 0xcd, 0xdf, 0xd1, 0xda, 0x36, 0x35, 0x6f, 0xf6, 0xe8, 0x54,
	0xac, 0x3a, 0x6f, 0x46, 0x9c, 0x53, 0x7f, 0x41, 0x04, 0xaf, 0x9e, 0x8c, 0x51, 0xc1, 0xc5, 0x33,
	0x1b, 0xac, 0x22, 0x85, 0xbc, 0xc2, 0x9d, 0x7a, 0xd6, 0x9c, 0xe2, 0x5b, 0xdf, 0x2f, 0xc5, 0xcf,
	0x9a, 0xaf, 0xf5, 0xd3, 0x50, 0x67, 0x4a, 0xd1, 0x1f, 0xa5, 0x61, 0x64, 0xf3, 0xc0, 0xc5, 0xed,
	0xd9, 0x23, 0x18, 0x12, 0x2a, 0x3c, 0xba, 0xb4, 0xc8, 0x98, 0xf9, 0xb7, 0xfd, 0xce, 0x4d, 0x9e,
	0xe4, 0xdd, 0xb0, 0xad, 0xd2, 0xd6, 0xd6, 0x1a, 0x1b, 0xf9, 0xa1, 0xb5, 0x15, 0x63, 0xc8, 0xb6,
	0xc8, 0xdb, 0xb8, 0x35, 0xf1, 0x43, 0xc1, 0x64, 0x7f, 0xbb, 0x08, 0x5e, 0x85, 0x6d, 0xc2, 0xc3,
	0x03, 0xb7, 0x6c, 0x89, 0x70, 0xb4, 0xed, 0xb9, 0xc2, 0x9f, 0x19, 0x0f, 0x0f, 0xdc, 0x95, 0x16,
	0x94, 0xbc, 0x01, 0xa7, 0xdd, 0x46, 0x8d, 0x1f, 0x60, 0xd6, 0xd8, 0xba, 0x54, 0xa6, 0x07, 0xb4,
	0xd2, 0x90, 0x67, 0xd4, 0x19, 0x63, 0xda, 0x6d, 0xd4, 0x36, 0xa2, 0xd2, 0x55, 0x51, 0x48, 0xe6,
	0x20, 0xcf, 0xea, 0xf9, 0x94, 0x7b, 0x25, 0x78, 0xc6, 0x68, 0x80, 0xdb, 0xa8, 0x19, 0x1c, 0x42,
	0xae, 0x40, 0x81, 0x21, 0x98, 0x8d, 0xd0, 0x8b, 0xb0, 0xb8, 0x35, 0x1e, 0x77, 0x1b, 0xb5, 0xc5,
	0x46, 0xe8, 0x49, 0xcc, 0x2f, 0x41, 0xd6, 0xa2, 0xa6, 0xe5, 0xd8, 0x2e, 0x3f, 0xca, 0xeb, 0xb7,
	0xab, 0x51, 0x2d, 0x0c, 0x0e, 0xd6, 0xea, 0x8e, 0x5d, 0xb1, 0x43, 0x71, 0x60, 0x1e, 0x7d, 0x33,
	0x46, 0x4d, 0xe6, 0xc2, 0x96, 0xb7, 0x9b, 0x21, 0xe5, 0xc7, 0x78, 0x29, 0x03, 0x10, 0xb4, 0xc4,
	0x20, 0xe4, 0x32, 0x4c, 0xd4, 0xcc, 0x83, 0xb2, 0x8a, 0x04, 0x88, 0x34, 0x56, 0x33, 0x0f, 0x16,
	0x5b, 0x78, 0x67, 0x21, 0x87, 0x27, 0x5d, 0xb8, 0x04, 0xe7, 0x79, 0x2b, 0x0c, 0x80, 0x4b, 0xf0,
	0x25, 0x18, 0xb3, 0x03, 0x71, 0xd6, 0x68, 0x57, 0x4c, 0x07, 0x63, 0xa9, 0x59, 0x63, 0xd4, 0x0e,
	0x6e, 0x47, 0x30, 0x5c, 0x6e, 0x7d, 0xdb, 0xf3, 0xed, 0xb0, 0x89, 0xc7, 0x76, 0x6c, 0xb9, 0x15,
	0xdf, 0xfa, 0x1f, 0xa5, 0x20, 0x8f, 0xf1, 0x42, 0xfa, 0xa8, 0x41, 0xfd, 0x26, 0x39, 0x15, 0xe9,
	0x53, 0x6e, 0x69, 0x58, 0x51, 0x8a, 0xaf, 0xc0, 0x30, 0x1b, 0x58, 0xdb, 0x42, 0x51, 0x8d, 0x2e,
	0xad, 0x3c, 0x9d, 0xae, 0x65, 0x98, 0xfe, 0xae, 0x18, 0x99, 0xf0, 0xc0, 0x5d, 0xb3, 0xd8, 0x44,
	0x09, 0xf6, 0xa4, 0x53, 0xcc, 0x7e, 0xb6, 0x74, 0x30, 0x35, 0xb8, 0x0e, 0x7e, 0x0e, 0xc6, 0xed,
	0xa0, 0x6c, 0xd9, 0x81, 0xc8, 0x69, 0x91, 0x51, 0x8f, 0x31, 0x3b, 0x58, 0x69, 0x01, 0xc9, 0x12,
	0x64, 0xea, 0x8f, 0x65, 0x20, 0x63, 0xbc, 0x6b, 0x56, 0x6b, 0xb4, 0x17, 0x69, 0x09, 0xa8, 0xf4,
	0x90, 0xd5, 0x31, 0x78, 0x55, 0x2e, 0xd9, 0x28, 0xda, 0xa6, 0x5d, 0x19, 0x52, 0x62, 0x66, 0x57,
	0xa0, 0x10, 0xec, 0x39, 0x65, 0xd7, 0x2b, 0x57, 0x3c, 0x37, 0x08, 0x4d, 0xe6, 0x8b, 0x65, 0xf9,
	0x5c, 0x08, 0xf6, 0x9c, 0xfb, 0xde, 0xb2, 0x84, 0x62, 0x4a, 0xf5, 0x9e, 0x53, 0x0e, 0x1a, 0xb5,
	0x9a, 0xe9, 0x37, 0x45, 0x22, 0x14, 0x04, 0x7b, 0xce, 0x06, 0x87, 0xe8, 0x9f, 0x83, 0x0c, 0x36,
	0xcb, 0x9c, 0x82, 0x87, 0xc6, 0xea, 0xc3, 0x45, 0x63, 0xed, 0xfe, 0xad, 0xc2, 0x09, 0xf6, 0xb9,
	0xfa, 0xe5, 0xd5, 0x65, 0xe6, 0x23, 0xdc, 0x2a, 0x68, 0xfa, 0xab, 0x30, 0xc9, 0x5c, 0xe7, 0x0d,
	0x1a, 0x04, 0x4a, 0xa0, 0x97, 0x31, 0xd9, 0x08, 0xa8, 0xaf, 0x78, 0x90, 0xd1, 0xb7, 0xfe, 0x7f,
	0xd3, 0x30, 0x22, 0xf0, 0x9f, 0xeb, 0x8a, 0xaf, 0xf2, 0x30, 0x14, 0xe7, 0x81, 0x8d, 0x57, 0xc5,
	0xb1, 0xa9, 0x1b, 0x46, 0x89, 0x5e, 0xdc, 0x64, 0x8c, 0x71, 0xa8, 0xcc, 0x17, 0xbb, 0x0a, 0x05,
	0x0c, 0x72, 0x56, 0xf0, 0x7e, 0x07, 0xcf, 0x19, 0xe3, 0xdb, 0xa1, 0x09, 0x05, 0x2e, 0xf2, 0xc6,
	0xc6, 0x31, 0x31, 0x81, 0x96, 0x45, 0xf8, 0x47, 0xe4, 0xa0, 0x5c, 0xee, 0x6f, 0x8c, 0x65, 0xb2,
	0x88, 0x19, 0x81, 0x98, 0xb9, 0x88, 0x54, 0x72, 0x78, 0x70, 0x95, 0xbc, 0x06, 0x27, 0x1d, 0x33,
	0x08, 0xcb, 0x0a, 0x57, 0x4d, 0xa1, 0x0c, 0x13, 0xac, 0xa0, 0x73, 0x06, 0xe6, 0x70, 0x96, 0xa9,
	0x33, 0xb0, 0xcd, 0xa0, 0x40, 0x3f, 0x06, 0x25, 0xdf, 0xcd, 0xa0, 0x2c, 0x02, 0x08, 0x3e, 0xc2,
	0x03, 0x17, 0x0d, 0x46, 0x72, 0x5a, 0xa1, 0x58, 0x6a, 0x8c, 0x1c, 0xaf, 0xb5, 0x79, 0xe0, 0x92,
	0x25, 0x98, 0xed, 0xe8, 0x4f, 0x5c, 0xd3, 0xb9, 0x9d, 0x29, 0xb6, 0x75, 0x4e, 0xd1, 0xfa, 0x3b,
	0xe9, 0xec, 0x48, 0x21, 0xab, 0xff, 0xaa, 0x06, 0x27, 0x55, 0xa5, 0xe5, 0xce, 0xdc, 0xf3, 0x54,
	0xc5, 0xe3, 0x4f, 0xba, 0xfe, 0x96, 0x06, 0x53, 0xf1, 0x09, 0x24, 0x3c, 0x96, 0x15, 0xc8, 0x06,
	0x02, 0x26, 0x5c, 0x96, 0x24, 0x79, 0x89, 0xea, 0x32, 0x12, 0x23, 0x6b, 0x92, 0x3b, 0x6d, 0x6e,
	0x46, 0x92, 0xc5, 0xe9, 0x10, 0x49, 0xdc, 0xd3, 0xd0, 0xf7, 0x80, 0x2c, 0x9b, 0x6e, 0x85, 0x3a,
	0x28, 0xd6, 0x9e, 0xbb, 0x9b, 0xcb, 0x90, 0xe5, 0x63, 0x64, 0xf3, 0x58, 0x67, 0x6e, 0x29, 0xcf,
	0xdc, 0x5d, 0xac, 0xcc, 0xdc, 0x56, 0x2c, 0x6c, 0x9b, 0xa6, 0xa9, 0x36, 0x53, 0x71, 0x0b, 0x26,
	0x63, 0x4d, 0x0a, 0xd9, 0xb0, 0xad, 0x26, 0x82, 0xa9, 0x25, 0x02, 0xdc, 0xd1, 0x77, 0xeb, 0xd4,
	0x65, 0x48, 0x39, 0x75, 0xd1, 0x9b, 0x30, 0xc5, 0x09, 0x89, 0x0e, 0xf6, 0xe4, 0xfe, 0x3a, 0x80,
	0x10, 0xa2, 0xe4, 0x7f, 0x94, 0x67, 0x5f, 0x08, 0x02, 0x6b, 0x2b, 0x46, 0x4e, 0x20, 0xf4, 0xe8,
	0xc3, 0x1a, 0x4c, 0xb7, 0x35, 0xfd, 0xc4, 0xbd, 0x38, 0x0f, 0x67, 0xd9, 0x20, 0x2d, 0x47, 0x97,
	0x09, 0xf1, 0x08, 0x32, 0xca, 0xae, 0x91, 0x7a, 0x1d, 0xa5, 0xfa, 0xfc, 0x1c, 0xf5, 0xfa, 0x1f,
	0x6a, 0x70, 0xae, 0x3b, 0xaf, 0xa2, 0xf7, 0xeb, 0xd1, 0x71, 0x2b, 0x3f, 0x38, 0x8e, 0x6d, 0x7f,
	0xf7, 0x9c, 0x92, 0x7a, 0x7d, 0xb2, 0xb4, 0x41, 0x7d, 0xdb, 0x74, 0xec, 0xaf, 0x52, 0xcb, 0xa0,
	0x55, 0xb6, 0x9e, 0x36, 0x23, 0xdd, 0x44, 0x1a, 0x03, 0xeb, 0x79, 0x4c, 0x44, 0x6d, 0x7a, 0x7e,
	0x06, 0x4e, 0x33, 0x14, 0xb6, 0x6e, 0x6f, 0x3c, 0x5a, 0x7f, 0xd7, 0xf1, 0x3e, 0x8a, 0x24, 0xfc,
	0x69, 0x0a, 0x88, 0x80, 0x1b, 0xb4, 0xe6, 0x85, 0x14, 0x4b, 0xc9, 0x0e, 0x8c, 0xec, 0x38, 0xde,
	0x47, 0xe5, 0xc8, 0x2b, 0xbe, 0x27, 0x3c, 0x95, 0xcf, 0xf7, 0x25, 0xdc, 0xb6, 0xab, 0xa0, 0x25,
	0x46, 0x14, 0x3d, 0x96, 0x61, 0xfe, 0xcb, 0x18, 0x66, 0xd4, 0xd7, 0x2c, 0x72, 0x1f, 0x32, 0xb6,
	0xbb, 0xe3, 0xc9, 0x4e, 0x26, 0x65, 0xd9, 0x74, 0x72, 0xa9, 0xa6, 0x5c, 0x72, 0x32, 0xc5, 0x6f,
	0x0d, 0x41, 0x1a, 0x3d, 0xfa, 0xe7, 0xa9, 0x23, 0x4b, 0x90, 0x8b, 0x6e, 0x50, 0x0e, 0xe4, 0xde,
	0xb7, 0xaa, 0x31, 0x65, 0x11, 0x21, 0x60, 0x1e, 0x43, 0x79, 0x7d, 0xb0, 0x9e, 0x8b, 0xed, 0x8c,
	0xa0, 0x41, 0x08, 0xa4, 0x83, 0xb0, 0x16, 0x8a, 0x95, 0x1c, 0x7f, 0xeb, 0x17, 0x61, 0x58, 0x6c,
	0xd3, 0xf3, 0x30, 0x62, 0x6c, 0xdd, 0xbf, 0xcf, 0xbd, 0x1d, 0x80, 0xe1, 0x47, 0x5b, 0xab, 0x5b,
	0xab, 0x2b, 0x05, 0x4d, 0xff, 0x91, 0x06, 0x33, 0x9d, 0x8a, 0x21, 0xd4, 0x79, 0x0d, 0x32, 0x6c,
	0x90, 0xfa, 0xb9, 0x33, 0xd7, 0xc9, 0x60, 0x74, 0x86, 0x88, 0xda, 0xf4, 0x2c, 0x75, 0xf9, 0xdf,
	0x69, 0x50, 0xd8, 0xa8, 0x9b, 0x6e, 0x2c, 0x6e, 0x74, 0xa9, 0xcd, 0xe8, 0x2d, 0x41, 0x6b, 0xb4,
	0xa3, 0x61, 0x33, 0xd4, 0xcc, 0x13, 0x6e, 0xff, 0x6e, 0x7c, 0x7a, 0x38, 0xf7, 0xea, 0x60, 0xbb,
	0xde, 0xbb, 0xb4, 0xa9, 0x24, 0xac, 0xdc, 0x6f, 0x25, 0xac, 0xa4, 0x9e, 0x86, 0xa2, 0xc8, 0x73,
	0x61, 0x46, 0xe6, 0xa4, 0xd2, 0x3b, 0x31, 0x14, 0x73, 0x90, 0xe7, 0x87, 0x0c, 0x15, 0xaf, 0xe1,
	0x86, 0xe2, 0xa0, 0x1d, 0x10, 0xb4, 0xcc, 0x20, 0xe4, 0x75, 0x38, 0x65, 0xd6, 0xeb, 0xbe, 0x77,
	0x60, 0xd7, 0xcc, 0x90, 0x32, 0xaf, 0x7d, 0x57, 0xf8, 0x2e, 0x3c, 0x0b, 0x6e, 0x4a, 0x29, 0x5d,
	0xb1, 0x83, 0x5d, 0xee, 0xc2, 0xac, 0x43, 0x5e, 0x64, 0x9b, 0x8a, 0x18, 0x5a, 0x47, 0x1e, 0x4d,
	0x7b, 0x30, 0xef, 0xde, 0x7b, 0xcb, 0xcb, 0xc8, 0x9a, 0xbc, 0x56, 0xc7, 0x53, 0x52, 0x31, 0x86,
	0xf6, 0x79, 0x98, 0x12, 0xe9, 0x13, 0xf1, 0x50, 0x70, 0x3f, 0x63, 0xa3, 0x7f, 0x7f, 0x0c, 0xa6,
	0xdb, 0x6a, 0x77, 0x86, 0x8d, 0xb2, 0xcf, 0x7a, 0x22, 0xff, 0xa1, 0x06, 0x93, 0x32, 0xc5, 0x43,
	0xbd, 0xa3, 0x95, 0xeb, 0x79, 0x47, 0xab, 0x2b, 0xaf, 0xa5, 0x28, 0x7d, 0xa4, 0xfb, 0x1d, 0xad,
	0xb6, 0xe2, 0x27, 0xbf, 0xa3, 0x55, 0x6f, 0x6b, 0xa7, 0xf8, 0xaf, 0x72, 0x3c, 0xef, 0x3d, 0xca,
	0x99, 0xeb, 0xc8, 0xb2, 0xd1, 0xba, 0x64, 0xd9, 0xfc, 0x59, 0x0d, 0xa6, 0x95, 0x34, 0xba, 0x72,
	0x7b, 0x3c, 0xeb, 0xc1, 0xd1, 0xe1, 0xdc, 0xe4, 0x56, 0x0b, 0xe1, 0xa9, 0xcf, 0xb4, 0x26, 0x1b,
	0xed, 0xc4, 0xac, 0x80, 0xfc, 0x9e, 0x06, 0x97, 0x95, 0x1c, 0xbc, 0x8e, 0x14, 0x3e, 0x85, 0xad,
	0x14, 0xb2, 0xf5, 0x8b, 0x47, 0x87, 0x73, 0x17, 0x5a, 0x09, 0x7a, 0xf1, 0xa4, 0xbe, 0xa7, 0xe6,
	0xf1, 0x82, 0x9f, 0x48, 0xd9, 0x0a, 0xc8, 0xb7, 0x34, 0x98, 0x89, 0xe7, 0x0d, 0x2a, 0x2c, 0xa6,
	0x91, 0xc5, 0x87, 0x47, 0x87, 0x73, 0x53, 0xf7, 0x95, 0x2c, 0xc2, 0xa7, 0x66, 0x6b, 0xca, 0xed,
	0xa0, 0x66, 0x05, 0xe4, 0x00, 0x88, 0xcc, 0x24, 0x54, 0x78, 0xc8, 0x20, 0x0f, 0x77, 0x8f, 0x0e,
	0xe7, 0x26, 0xee, 0xf3, 0xbc, 0xc2, 0xa7, 0x6e, 0x7e, 0xc2, 0x55, 0x09, 0x59, 0x01, 0xf9, 0x0d,
	0x0d, 0xce, 0xb4, 0xe5, 0x3f, 0x2a, 0x1c, 0x0c, 0x23, 0x07, 0x1b, 0x47, 0x87, 0x73, 0xa7, 0xb7,
	0xe2, 0x48, 0x4f, 0xcd, 0xc9, 0xe9, 0x46, 0x37, 0x82, 0x56, 0x40, 0xbe, 0xad, 0xc1, 0x4c, 0x3c,
	0xd1, 0x52, 0x61, 0x28, 0x87, 0x0c, 0x19, 0x47, 0x87, 0x73, 0xa7, 0x1e, 0xec, 0x3f, 0x53, 0x7e,
	0x4e, 0x79, 0xfb, 0x5d, 0xd9, 0xf9, 0xa1, 0x06, 0xfa, 0x71, 0xa9, 0x9c, 0x0a, 0x63, 0x23, 0xc8,
	0xd8, 0x07, 0x47, 0x87, 0x73, 0xb3, 0x8f, 0xba, 0x26, 0x76, 0x3e, 0x35, 0x83, 0xb3, 0x7b, 0x09,
	0x74, 0xad, 0x80, 0xfc, 0x96, 0x06, 0xe7, 0x3a, 0x33, 0x47, 0x15, 0x16, 0xb3, 0xad, 0xc1, 0x34,
	0xe2, 0x79, 0xa4, 0x4f, 0x3f, 0x98, 0x7e, 0x37, 0x82, 0x56, 0x80, 0x97, 0x4e, 0xbb, 0x5a, 0xd3,
	0x5e, 0x97, 0x4e, 0xf3, 0x89, 0xef, 0x4a, 0x74, 0x37, 0xdb, 0xaa, 0xe5, 0x54, 0x4e, 0x88, 0xef,
	0xa4, 0xb3, 0x5a, 0x21, 0xab, 0x7f, 0x1d, 0x0a, 0xb7, 0xbd, 0x70, 0xf0, 0x35, 0x8d, 0x5c, 0x84,
	0x5c, 0x1d, 0x1f, 0x6e, 0x91, 0xb1, 0xc5, 0x0c, 0xae, 0x9a, 0x9a, 0x91, 0x65, 0x60, 0x8c, 0x30,
	0x5e, 0x02, 0x40, 0x94, 0xd0, 0xdb, 0xa5, 0xe2, 0x8c, 0x57, 0xe0, 0x60, 0xd5, 0x4d, 0x06, 0xd6,
	0x7f, 0x35, 0x0b, 0x27, 0x15, 0x0e, 0x3e, 0x83, 0xbb, 0xfe, 0xff, 0x42, 0x83, 0xe9, 0xc7, 0x5e,
	0xc8, 0x75, 0xa0, 0xcb, 0xed, 0xe5, 0xe5, 0x04, 0x11, 0x77, 0x70, 0xda, 0x82, 0xc4, 0x97, 0xc5,
	0x87, 0x62, 0x59, 0x3c, 0xd9, 0x5e, 0xfe, 0xc4, 0xeb, 0xe2, 0xc9, 0xc7, 0xed, 0x2d, 0x15, 0xff,
	0xb7, 0x06, 0x59, 0x49, 0x9f, 0x7c, 0x21, 0x76, 0x19, 0xac, 0xdb, 0xa5, 0x4b, 0xc4, 0x3b, 0xe6,
	0x16, 0x58, 0xf7, 0x04, 0xe9, 0xa1, 0x63, 0x12, 0xa4, 0x7f, 0x19, 0x26, 0xd1, 0x2c, 0x8b, 0x35,
	0x4c, 0xca, 0x0f, 0x6f, 0xfa, 0x2e, 0xad, 0xb3, 0x6e, 0xaf, 0xb7, 0x8a, 0x9f, 0x6e, 0xd4, 0x4e,
	0x3a, 0x6d, 0x94, 0xac, 0xe2, 0xbf, 0xd4, 0x60, 0x0c, 0x73, 0xc4, 0x22, 0x75, 0x79, 0xde, 0x09,
	0x68, 0x1f, 0x00, 0xb4, 0x34, 0x46, 0xa8, 0xc9, 0x8d, 0x27, 0x52, 0x93, 0xe8, 0x46, 0x87, 0xc4,
	0x28, 0xfe, 0x8a, 0xd6, 0x76, 0xab, 0xaf, 0x2f, 0xef, 0xc6, 0x60, 0x3b, 0x2c, 0xcf, 0x8f, 0xb8,
	0x79, 0x7b, 0x20, 0x6e, 0x62, 0xd2, 0x33, 0x04, 0xa5, 0xe2, 0xd7, 0xe1, 0x54, 0x77, 0x6d, 0xee,
	0x62, 0x96, 0x1e, 0xc4, 0xcd, 0xd2, 0x5b, 0x03, 0x35, 0xaf, 0x76, 0x57, 0x0d, 0x5a, 0xfd, 0x41,
	0x16, 0x26, 0x3b, 0xb0, 0xdf, 0x5b, 0x20, 0x0f, 0xda, 0x82, 0x81, 0x37, 0x07, 0x69, 0xed, 0xbd,
	0x85, 0x08, 0x16, 0x45, 0xf3, 0xfe, 0xb1, 0x06, 0x27, 0xf9, 0x8e, 0xab, 0x73, 0xfa, 0x2f, 0x0d,
	0x48, 0x1c, 0xb7, 0x71, 0x6d, 0xb3, 0xff, 0x9e, 0x98, 0xfd, 0xe3, 0xb1, 0xc2, 0x27, 0x9e, 0xfa,
	0xe3, 0x34, 0xd6, 0x06, 0xb9, 0x0e, 0x13, 0x2e, 0x3d, 0x08, 0xcb, 0xc7, 0x58, 0xd7, 0x31, 0x56,
	0xf8, 0x50, 0x5a, 0xd8, 0xe2, 0x0f, 0x33, 0x8a, 0x95, 0x68, 0x0f, 0x6a, 0x67, 0x9e, 0x71, 0x50,
	0x5b, 0x31, 0xdc, 0x43, 0xcf, 0xda, 0x70, 0x9f, 0x81, 0xd4, 0x5e, 0x9d, 0x6f, 0xfa, 0xb4, 0xa5,
	0x91, 0xa3, 0xc3, 0xb9, 0xd4, 0xa3, 0x87, 0x1b, 0x06, 0x83, 0x91, 0xf3, 0x00, 0x21, 0x7a, 0xf9,
	0xca, 0x91, 0x7f, 0x0e, 0x21, 0x78, 0xd8, 0x7f, 0x09, 0xc6, 0x2c, 0x33, 0x34, 0xb7, 0x99, 0x27,
	0x89, 0x18, 0x3c, 0x1b, 0x6a, 0x54, 0x02, 0x11, 0xe9, 0x3c, 0x00, 0x7f, 0x91, 0x0c, 0x31, 0x78,
	0x66, 0x54, 0x0e, 0x21, 0x58, 0x6c, 0x42, 0x41, 0xde, 0xef, 0x12, 0x3d, 0xe4, 0xfe, 0x4d, 0x66,
	0xe9, 0xe6, 0x93, 0x76, 0x6c, 0x5c, 0x10, 0xe4, 0xc3, 0x1a, 0x1c, 0x67, 0x56, 0xb3, 0x9f, 0x89,
	0x59, 0xc5, 0x10, 0x53, 0xe5, 0x31, 0xad, 0x99, 0xea, 0x5d, 0x7b, 0xe0, 0x20, 0x94, 0x80, 0x6a,
	0x65, 0xe1, 0xd9, 0x5b, 0xd9, 0xe2, 0x22, 0x4c, 0x76, 0x99, 0x4c, 0xbd, 0x6e, 0x67, 0xe6, 0x54,
	0x0b, 0x72, 0x15, 0x46, 0xfb, 0x4d, 0xe6, 0xfc, 0x9d, 0x8c, 0x48, 0xeb, 0xfe, 0x4c, 0x9c, 0x0e,
	0x75, 0xde, 0x0d, 0x3d, 0x87, 0x64, 0x92, 0x7f, 0xae, 0xc1, 0x94, 0x2f, 0x3a, 0x12, 0x33, 0x6a,
	0x3c, 0x27, 0xe4, 0x17, 0x7a, 0xa5, 0xcf, 0x28, 0xd7, 0x21, 0x05, 0x91, 0x63, 0xfc, 0x99, 0xf6,
	0xf2, 0x27, 0xf7, 0x67, 0xfc, 0xf6, 0x96, 0x8a, 0xdf, 0x6d, 0x5f, 0x0a, 0x8b, 0x90, 0x95, 0x58,
	0xf2, 0xc8, 0xdd, 0x3f, 0x76, 0x99, 0xec, 0xf6, 0x38, 0xda, 0x97, 0xe4, 0x09, 0x6c, 0x6a, 0xe0,
	0xd4, 0x78, 0x71, 0xe6, 0xfa, 0x31, 0x9c, 0xea, 0x2e, 0x92, 0x2e, 0x7a, 0x79, 0x37, 0xbe, 0x28,
	0xde, 0xe8, 0x5b, 0xe8, 0xc7, 0x2c, 0x88, 0x22, 0x8f, 0xf0, 0x65, 0x20, 0x2b, 0xad, 0x87, 0x0d,
	0x7b, 0xe6, 0x69, 0x5d, 0x11, 0xde, 0x51, 0x6f, 0xcc, 0x1f, 0x0d, 0xc1, 0xa8, 0x78, 0xfb, 0x80,
	0xbf, 0x61, 0xf7, 0xbc, 0xfd, 0xa8, 0x97, 0xe0, 0x24, 0x75, 0x2b, 0x7e, 0x13, 0xf3, 0x3b, 0xe4,
	0x2d, 0x21, 0x3c, 0xac, 0x34, 0x0a, 0xad, 0x02, 0x71, 0xb0, 0x3b, 0x27, 0x0f, 0xf0, 0x78, 0x5e,
	0x1f, 0x3f, 0xeb, 0xe3, 0x67, 0x72, 0x98, 0xfa, 0xd7, 0x42, 0xe0, 0x87, 0x81, 0x69, 0x05, 0x81,
	0x1f, 0x01, 0x5e, 0x81, 0x82, 0x88, 0x3e, 0xee, 0xd2, 0xa6, 0x20, 0xc3, 0x2f, 0x81, 0x8a, 0xd8,
	0xef, 0x5d, 0xda, 0xe4, 0xa4, 0xe2, 0x98, 0x9c, 0xde, 0x70, 0x1b, 0x26, 0xd2, 0xd4, 0xdf, 0x87,
	0x71, 0x29, 0xdd, 0x28, 0x67, 0x59, 0xba, 0x62, 0xbd, 0x5f, 0x54, 0x52, 0xa5, 0x2d, 0x8f, 0x7e,
	0x79, 0x65, 0xfd, 0x87, 0x43, 0x70, 0xb2, 0x95, 0xcc, 0x32, 0xd0, 0x5e, 0x0c, 0x53, 0x39, 0x6b,
	0xdb, 0xb6, 0x4b, 0x2d, 0x99, 0x80, 0x29, 0xbf, 0x49, 0x51, 0xcd, 0x92, 0x48, 0x09, 0x0f, 0x41,
	0x84, 0x9c, 0x4f, 0x41, 0x8a, 0xba, 0x3c, 0xf5, 0x41, 0x96, 0x30, 0x00, 0xd9, 0x02, 0xd8, 0xa1,
	0x61, 0xe5, 0x71, 0xb9, 0xe6, 0x59, 0x32, 0xf7, 0xe1, 0x8d, 0xe4, 0xa4, 0xd4, 0x38, 0xdb, 0xa5,
	0x77, 0x59, 0xf5, 0x7b, 0x4c, 0xab, 0x73, 0x3b, 0xf2, 0xa7, 0xbe, 0x0a, 0xb9, 0x08, 0x4e, 0x26,
	0x61, 0x62, 0x23, 0xac, 0x85, 0x8b, 0xae, 0xb5, 0x79, 0xc0, 0x0f, 0x84, 0x0b, 0x27, 0xc8, 0x49,
	0xa6, 0xba, 0x35, 0xbc, 0x75, 0x18, 0x3c, 0x70, 0x9d, 0x66, 0x41, 0xc3, 0xa4, 0x46, 0x81, 0x80,
	0x90, 0x21, 0xfd, 0xbf, 0xe5, 0x80, 0xa8, 0x2d, 0x8a, 0x61, 0xa8, 0x63, 0x86, 0xb4, 0x80, 0x8a,
	0xa1, 0xb8, 0xd3, 0x27, 0xd3, 0x62, 0x1a, 0x2e, 0x7b, 0x8e, 0x43, 0x2b, 0x21, 0xb5, 0xa2, 0xb2,
	0x8e, 0x9b, 0x6e, 0x4a, 0x1b, 0x64, 0x19, 0x00, 0x23, 0xdc, 0x3e, 0x0d, 0xe8, 0x60, 0x59, 0x28,
	0x39, 0x56, 0xcf, 0x60, 0xd5, 0xc8, 0x4d, 0x98, 0x91, 0x0f, 0x20, 0x95, 0xcd, 0x7a, 0x1d, 0xd7,
	0xde, 0x72, 0xdd, 0xa7, 0x3b, 0xf6, 0x81, 0xf0, 0x63, 0xa6, 0x65, 0xf9, 0x62, 0xbd, 0xce, 0xd6,
	0xe1, 0x87, 0x58, 0x48, 0xbe, 0x06, 0xa3, 0x78, 0xd5, 0x9a, 0xe9, 0xa7, 0xe7, 0xca, 0xf4, 0x85,
	0xcd, 0xc1, 0x7a, 0xbc, 0x2a, 0xde, 0x30, 0x8c, 0x7a, 0xbe, 0xd9, 0x22, 0xd9, 0xd1, 0xf7, 0x58,
	0x7b, 0xc5, 0xff, 0x32, 0x04, 0xb3, 0xb2, 0x7a, 0x17, 0x79, 0xf1, 0xdb, 0x60, 0x59, 0x36, 0x9d,
	0xa2, 0xd4, 0xfb, 0xb6, 0xf3, 0xf7, 0x3d, 0xa7, 0xd4, 0xbd, 0xa2, 0xcc, 0x13, 0xdf, 0xa5, 0xcd,
	0x15, 0x33, 0x34, 0x9f, 0xab, 0x53, 0xb9, 0x06, 0x63, 0x66, 0xb5, 0xea, 0xd3, 0x2a, 0x9e, 0xa9,
	0x85, 0xc1, 0x40, 0xe3, 0x38, 0xda, 0xaa, 0xba, 0x19, 0x90, 0xf7, 0x60, 0x4a, 0x7e, 0x63, 0x1c,
	0x9a, 0x0d, 0xdb, 0xbe, 0x78, 0xe7, 0x2a, 0xbf, 0x70, 0xa6, 0x83, 0xe2, 0x8a, 0x78, 0x87, 0x94,
	0x13, 0xfc, 0x3e, 0x23, 0x38, 0xa9, 0x10, 0x58, 0x13, 0xf5, 0x8b, 0x7f, 0x7d, 0x08, 0xce, 0x25,
	0xa9, 0x26, 0xb1, 0x5a, 0x2b, 0x51, 0x7e, 0x61, 0xfd, 0xc9, 0x34, 0x20, 0x71, 0x24, 0x70, 0x75,
	0xfb, 0x32, 0x26, 0x9d, 0xa0, 0x19, 0x5e, 0xba, 0xcd, 0x93, 0x4e, 0x3e, 0x3d, 0x9c, 0x7b, 0x67,
	0xc0, 0x15, 0xa1, 0x16, 0xbe, 0x6b, 0xbb, 0x55, 0xea, 0xd7, 0x7d, 0xdb, 0x0d, 0x45, 0xda, 0xca,
	0x3b, 0xf2, 0xa2, 0xd3, 0x50, 0x67, 0xa2, 0x49, 0x77, 0x25, 0x89, 0x5d, 0x70, 0x2a, 0xfe, 0x54,
	0x83, 0xcb, 0xfd, 0x69, 0x32, 0x31, 0xb8, 0x95, 0x08, 0x54, 0xa5, 0x7c, 0xb9, 0xad, 0xbd, 0xbe,
	0x26, 0x43, 0x0e, 0xc9, 0x3c, 0x6f, 0xf5, 0xd4, 0x37, 0x61, 0x76, 0x59, 0x98, 0xf2, 0xd6, 0xe0,
	0xc5, 0xa2, 0x83, 0x91, 0x81, 0xd7, 0x8e, 0x35, 0xf0, 0x43, 0x6d, 0x06, 0x5e, 0xff, 0xd6, 0x10,
	0x14, 0x23, 0x72, 0x31, 0xdf, 0xa2, 0xee, 0xf9, 0x21, 0x19, 0x8f, 0x12, 0xfc, 0x52, 0x38, 0x3e,
	0xe7, 0x20, 0x57, 0xf1, 0x6a, 0x75, 0x87, 0x86, 0xd1, 0x02, 0xd3, 0x02, 0x90, 0xd7, 0x60, 0x3a,
	0x32, 0x8a, 0xe5, 0x9d, 0xd6, 0xe0, 0x8a, 0xcc, 0x8a, 0xa9, 0xa8, 0x50, 0x19, 0x78, 0xf2, 0x0e,
	0xcc, 0xb4, 0x2a, 0x29, 0xcf, 0x36, 0x33, 0x21, 0xaa, 0xeb, 0xd1, 0xa9, 0xa0, 0x0b, 0x9b, 0x98,
	0x3c, 0x3d, 0xea, 0x73, 0x01, 0xf0, 0xc7, 0x85, 0x32, 0x03, 0xcc, 0xda, 0x7c, 0x54, 0x73, 0x31,
	0xd4, 0x7f, 0x09, 0x5e, 0x5c, 0xf6, 0xa9, 0x19, 0xd2, 0xe3, 0xe5, 0x21, 0x25, 0x7d, 0x6c, 0x47,
	0xb5, 0xe3, 0x3b, 0xaa, 0x37, 0xe1, 0x4a, 0x6f, 0xfa, 0x62, 0x09, 0xbb, 0x07, 0xc3, 0x3e, 0x42,
	0x84, 0x62, 0xde, 0xe8, 0x67, 0x2a, 0x77, 0x92, 0x13, 0x44, 0xf4, 0x17, 0x40, 0x3f, 0x1e, 0x2b,
	0xca, 0x91, 0xf8, 0x65, 0xb8, 0x94, 0x88, 0x25, 0x78, 0xdb, 0x82, 0x11, 0x4e, 0x56, 0xae, 0xad,
	0x4f, 0xc6, 0x9c, 0x34, 0xed, 0x82, 0x96, 0xfe, 0xbb, 0x1a, 0x4c, 0x75, 0xc3, 0xee, 0xd0, 0xc1,
	0x63, 0x85, 0x3f, 0x94, 0xa0, 0x65, 0xb7, 0x60, 0xb4, 0x22, 0x27, 0xb3, 0x7c, 0xa1, 0xaa, 0x6f,
	0x2d, 0x89, 0x6a, 0x2e, 0xca, 0x0b, 0x3d, 0xef, 0xc3, 0xd9, 0xee, 0x3d, 0xe3, 0xfa, 0xf1, 0x66,
	0x82, 0x4e, 0xf3, 0x8e, 0x1c, 0xa3, 0xcd, 0xfa, 0x1e, 0x9c, 0xeb, 0x4e, 0x38, 0x7a, 0x73, 0x27,
	0xaf, 0xd0, 0x13, 0x66, 0x72, 0x7e, 0xd0, 0x01, 0x50, 0x69, 0xe8, 0xaf, 0xc1, 0xcc, 0x1d, 0x6f,
	0x5b, 0xa6, 0xe7, 0x88, 0x8c, 0x8b, 0x5e, 0x1b, 0x86, 0xff, 0xae, 0xc1, 0x99, 0x2e, 0xb5, 0x3e,
	0x83, 0xfd, 0xf3, 0x57, 0x60, 0xd4, 0x6f, 0xb8, 0xae, 0xed, 0x56, 0xcb, 0x1f, 0x7a, 0xdb, 0xf2,
	0xd4, 0x33, 0xe9, 0x56, 0xc0, 0xb1, 0x7c, 0x62, 0x49, 0x5e, 0x50, 0xbb, 0xe3, 0x6d, 0x07, 0xc5,
	0x69, 0x48, 0xdd, 0xf1, 0xb6, 0xdb, 0x55, 0x4e, 0xbf, 0x0a, 0x85, 0x3b, 0xde, 0x76, 0x5c, 0x34,
	0xd3, 0x30, 0xfc, 0xa1, 0xb7, 0xdd, 0x1a, 0xd1, 0xcc, 0x87, 0xde, 0xf6, 0x9a, 0xa5, 0xaf, 0xc2,
	0x49, 0x05, 0x55, 0xc8, 0xe3, 0x15, 0x48, 0x7d, 0xe8, 0x6d, 0x8b, 0xb9, 0x3c, 0xdb, 0xb6, 0xc8,
	0xe0, 0xeb, 0xf9, 0xfc, 0x25, 0x7d, 0x64, 0x88, 0xa1, 0xea, 0x1e, 0x4c, 0xa1, 0x57, 0xb8, 0xf1,
	0x68, 0x7d, 0xf0, 0x0c, 0x90, 0x05, 0x98, 0x46, 0x4f, 0xb4, 0x5c, 0xa7, 0x7e, 0x60, 0xa3, 0x61,
	0x6c, 0xad, 0xaa, 0x59, 0x63, 0x12, 0x0b, 0x1f, 0xca, 0x32, 0x9e, 0xd6, 0x70, 0x1a, 0xa6, 0xdb,
	0x1a, 0xe4, 0xbc, 0xeb, 0x4b, 0x70, 0x76, 0xcd, 0xb5, 0xe8, 0x01, 0xbe, 0x6c, 0xdd, 0x5a, 0xfc,
	0x06, 0x4a, 0x7b, 0xf8, 0x07, 0x1a, 0x9c, 0xeb, 0x4e, 0x44, 0x08, 0x48, 0x2c, 0xc6, 0x1c, 0xda,
	0xed, 0xe5, 0x60, 0x75, 0x31, 0xee, 0x46, 0x49, 0x75, 0xca, 0xc5, 0x02, 0xff, 0x2c, 0x9c, 0x72,
	0xd6, 0x7b, 0xfc, 0x11, 0x6f, 0x73, 0xb0, 0xde, 0xcf, 0xc2, 0xb9, 0xee, 0x34, 0x84, 0x84, 0xa7,
	0x61, 0x72, 0x2b, 0xa0, 0xfe, 0xc6, 0xa3, 0x75, 0xc3, 0x6b, 0x5d, 0xb3, 0xd3, 0xaf, 0xc3, 0x54,
	0x1c, 0x2c, 0x64, 0x35, 0x05, 0x19, 0xdf, 0x73, 0x5a, 0x2f, 0x63, 0xe1, 0xc7, 0xb5, 0x2b, 0x00,
	0xad, 0x1b, 0x81, 0x64, 0x0a, 0x0a, 0xd1, 0x7d, 0xb0, 0xf2, 0xc6, 0xe6, 0xe2, 0xf2, 0xdd, 0x8d,
	0xc2, 0x09, 0x3d, 0x9d, 0xd5, 0x0a, 0xda, 0xb5, 0x17, 0x20, 0x2b, 0x6f, 0xd8, 0x29, 0x57, 0xc9,
	0xc6, 0x01, 0xa2, 0x1a, 0x1b, 0x05, 0x6d, 0xe1, 0x3f, 0xdf, 0x8c, 0xf2, 0xaa, 0xbe, 0xaf, 0xc1,
	0xa8, 0xfa, 0xea, 0x38, 0x29, 0xf5, 0xf7, 0xae, 0xb8, 0xec, 0x49, 0x71, 0xbe, 0x6f, 0x7c, 0x21,
	0x91, 0x17, 0xbf, 0xf9, 0xaf, 0xff, 0xd3, 0x5f, 0x1a, 0xba, 0x48, 0xe6, 0xe6, 0xc5, 0xd1, 0xc0,
	0xbc, 0xfa, 0x28, 0xf9, 0xfc, 0xc7, 0x42, 0xe6, 0x9f, 0x90, 0x3f, 0xa7, 0xc1, 0x88, 0x3c, 0xb2,
	0x48, 0xba, 0x88, 0x13, 0x7f, 0xc3, 0xbc, 0x78, 0xad, 0x1f, 0x54, 0xc1, 0x8b, 0x8e, 0xbc, 0x9c,
	0x23, 0xc5, 0x88, 0x17, 0x71, 0x91, 0x57, 0x61, 0x63, 0x1b, 0x46, 0xc4, 0x63, 0x62, 0x89, 0x5c,
	0xc4, 0xdf, 0x54, 0x4b, 0xe4, 0xa2, 0xed, 0x6d, 0x32, 0xfd, 0x04, 0xf1, 0x21, 0x83, 0x2f, 0x26,
	0x93, 0x17, 0x7b, 0xbf, 0xa9, 0xcc, 0xe9, 0x5f, 0xe9, 0xf7, 0xf1, 0x65, 0xfd, 0x14, 0xf6, 0xb1,
	0x40, 0xc6, 0xa3, 0x3e, 0xf2, 0xc7, 0x9d, 0xbf, 0x06, 0x69, 0xbc, 0xde, 0x77, 0xb9, 0xe7, 0x9b,
	0x72, 0xbc, 0xc5, 0x81, 0x1e, 0xfb, 0xd6, 0x2f, 0x60, 0xab, 0x45, 0x32, 0x13, 0x6f, 0x55, 0x91,
	0xeb, 0xd7, 0x61, 0x04, 0x19, 0xdd, 0x5a, 0xeb, 0xbf, 0xd7, 0xaf, 0x0c, 0xfa, 0xe4, 0xb4, 0x7e,
	0x06, 0xf9, 0x98, 0x24, 0x27, 0xe3, 0x7c, 0x94, 0x1b, 0x36, 0xf9, 0x1a, 0xe0, 0x64, 0xde, 0x5a,
	0xeb, 0x5b, 0x04, 0xfd, 0xbe, 0xa2, 0xad, 0x5f, 0xc2, 0x56, 0xcf, 0x93, 0xb3, 0x1d, 0xad, 0x2a,
	0x02, 0xf8, 0x84, 0xbf, 0x2b, 0x87, 0x77, 0xda, 0xc8, 0x4b, 0xfd, 0xdd, 0x7c, 0x3b, 0x7e, 0x28,
	0x8e, 0xbd, 0x26, 0xa7, 0x4f, 0x23, 0x33, 0x13, 0x64, 0x2c, 0x62, 0xc6, 0x37, 0x77, 0x42, 0xf2,
	0x0d, 0x0d, 0x86, 0x79, 0x98, 0x8b, 0xf4, 0x7c, 0x53, 0x28, 0x1a, 0x80, 0xab, 0x7d, 0x60, 0x8a,
	0x66, 0x2f, 0x62, 0xb3, 0x67, 0xc9, 0x19, 0xa5, 0x59, 0x86, 0xa0, 0x48, 0x20, 0x80, 0x61, 0xfe,
	0x1e, 0x49, 0x22, 0x07, 0xb1, 0x27, 0x4b, 0x8a, 0xea, 0xb5, 0x6f, 0xf1, 0x57, 0x6b, 0xd6, 0xdc,
	0x1d, 0x4f, 0xa8, 0x5d, 0x67, 0xa3, 0xe2, 0x0f, 0xdc, 0xb4, 0x1a, 0xfd, 0xcb, 0x1a, 0xe4, 0x95,
	0x87, 0x34, 0xc8, 0xcb, 0xfd, 0x3d, 0xb8, 0x21, 0xdb, 0x2f, 0xf5, 0x8b, 0x2e, 0xc4, 0x70, 0x19,
	0x39, 0xba, 0x40, 0x66, 0x23, 0x8e, 0x78, 0x26, 0x22, 0x2e, 0xda, 0x0a, 0x5b, 0xdf, 0xd5, 0x20,
	0x17, 0xbd, 0x74, 0x90, 0xa8, 0x0e, 0xed, 0xef, 0x3b, 0x24, 0xaa, 0x43, 0xc7, 0xe3, 0x0b, 0xfa,
	0x55, 0x64, 0xe8, 0x12, 0xb9, 0x18, 0x31, 0x64, 0x4a, 0x1c, 0xd4, 0x52, 0x85, 0xa7, 0x1f, 0x68,
	0x30, 0x1e, 0x7f, 0x09, 0x83, 0xbc, 0xd2, 0x57, 0x5b, 0x4a, 0x70, 0xa6, 0xf8, 0xea, 0x00, 0x35,
	0x04, 0x8b, 0x2f, 0x21, 0x8b, 0x9f, 0x23, 0x97, 0xba, 0xb0, 0x88, 0x4a, 0x34, 0xff, 0xb1, 0x0c,
	0xb3, 0x7c, 0x42, 0x7e, 0x4d, 0x83, 0x51, 0xf5, 0x92, 0x44, 0xe2, 0x0a, 0xd6, 0xe5, 0x56, 0x54,
	0xe2, 0x0a, 0xd6, 0xed, 0x12, 0x48, 0x17, 0x9b, 0x12, 0xdd, 0xec, 0xf8, 0x9e, 0x48, 0xf6, 0xc7,
	0x97, 0xaf, 0x3f, 0x3b, 0x8e, 0xe6, 0x90, 0xa3, 0x33, 0xe4, 0x74, 0xc4, 0x11, 0xbe, 0xb1, 0x5d,
	0x8e, 0xf8, 0xfa, 0xbe, 0x06, 0x79, 0xe5, 0xce, 0x46, 0xa2, 0xd2, 0x77, 0x5e, 0x27, 0x49, 0x54,
	0xfa, 0x2e, 0x57, 0x41, 0xf4, 0x6b, 0xc8, 0xcf, 0x0b, 0xba, 0xb2, 0xc6, 0x23, 0x16, 0xbf, 0x1f,
	0xd4, 0xd2, 0xb0, 0xb7, 0xb5, 0x6b, 0xe4, 0xaf, 0x68, 0x50, 0xe0, 0x34, 0x50, 0x68, 0x9f, 0x09,
	0x7f, 0x62, 0x52, 0xea, 0x67, 0xdb, 0xf9, 0xe3, 0x62, 0x43, 0x2e, 0x19, 0x6f, 0x7f, 0x5b, 0xdc,
	0x03, 0x6a, 0xbf, 0x2f, 0x41, 0xde, 0xe8, 0x31, 0x42, 0xc7, 0x5c, 0x06, 0x29, 0xde, 0x1c, 0xb8,
	0xde, 0xb1, 0x9e, 0x4a, 0xeb, 0x2a, 0x46, 0x59, 0x5c, 0xb7, 0xf8, 0xfb, 0x1a, 0x9c, 0x89, 0x94,
	0xef, 0xe7, 0xcf, 0xf2, 0x15, 0x64, 0x59, 0x27, 0x17, 0xda, 0x94, 0xb2, 0x93, 0xf1, 0xbf, 0xaa,
	0x41, 0xa1, 0x3d, 0x87, 0x9f, 0x2c, 0xf4, 0x68, 0xb7, 0xcb, 0x4d, 0x90, 0xe2, 0x6b, 0x03, 0xd5,
	0x11, 0x7c, 0xce, 0x22, 0x9f, 0x33, 0xe4, 0x54, 0xcb, 0x09, 0xb4, 0x83, 0x30, 0xd8, 0x73, 0xca,
	0x3c, 0xf3, 0xff, 0x87, 0xf8, 0xc7, 0x23, 0x84, 0x58, 0x7f, 0x3e, 0x2c, 0xbe, 0x80, 0x2c, 0xce,
	0x92, 0x73, 0x6d, 0xa2, 0x8c, 0x33, 0xfa, 0xdb, 0x1a, 0x8c, 0xc5, 0x2e, 0x35, 0x91, 0xf9, 0x9e,
	0xf3, 0x22, 0x7e, 0xf3, 0x2a, 0xd1, 0xc1, 0xea, 0x7a, 0x5f, 0x4a, 0xbf, 0x8e, 0xac, 0x5d, 0xd6,
	0x2f, 0xb6, 0x4f, 0x25, 0x61, 0x7b, 0xe2, 0x93, 0xfd, 0x6f, 0x6a, 0xf2, 0xba, 0x9a, 0x6a, 0x21,
	0x3f, 0x0b, 0x3e, 0x85, 0x36, 0xea, 0xe7, 0xbb, 0x4f, 0x79, 0xc1, 0x2d, 0xe3, 0xf1, 0x1b, 0x1a,
	0xe4, 0xa2, 0xfb, 0x0b, 0x89, 0x2b, 0x71, 0xfb, 0x1d, 0x8e, 0xc4, 0x95, 0xb8, 0xe3, 0x4a, 0x84,
	0x3e, 0x83, 0x2c, 0x11, 0xbd, 0xe5, 0x98, 0x05, 0x75, 0x13, 0x59, 0xf8, 0x1a, 0xee, 0xcf, 0x2a,
	0xbb, 0xc9, 0xae, 0x59, 0xec, 0xd9, 0x99, 0x44, 0xe7, 0x54, 0x7d, 0x26, 0xa9, 0x8b, 0x8f, 0x14,
	0x20, 0x21, 0x65, 0xe1, 0xff, 0x33, 0x1a, 0x8c, 0x88, 0xd7, 0x4d, 0x12, 0x37, 0x3d, 0xf1, 0x17,
	0x50, 0xfa, 0x67, 0xa1, 0xd3, 0x9a, 0xd5, 0x39, 0xa5, 0x36, 0x1e, 0xc4, 0xa3, 0x25, 0x89, 0x3c,
	0xc4, 0x1f, 0x36, 0x79, 0x1a, 0x1e, 0xc4, 0x0b, 0xf3, 0x0a, 0x0f, 0x7f, 0x5e, 0x83, 0xac, 0x7c,
	0x83, 0x86, 0x24, 0x6d, 0xe9, 0xda, 0x9e, 0xd1, 0x29, 0xbe, 0xd4, 0x17, 0xae, 0xe0, 0xa4, 0x73,
	0xaf, 0x84, 0x41, 0xec, 0xb8, 0xcf, 0x3a, 0xaa, 0xbe, 0x89, 0x94, 0xec, 0x51, 0x74, 0x3e, 0xb6,
	0x94, 0xec, 0x51, 0x74, 0x79, 0x6c, 0xa9, 0xcb, 0x0e, 0xc6, 0xf1, 0xaa, 0xed, 0x6c, 0xfd, 0x86,
	0x06, 0x23, 0xa2, 0x76, 0xe2, 0x10, 0xc5, 0x1f, 0x5f, 0x2a, 0xbe, 0x9c, 0x8c, 0xda, 0xf6, 0xf4,
	0x94, 0x74, 0x26, 0x88, 0x9e, 0xc0, 0xca, 0xfc, 0xc7, 0x0c, 0xf0, 0x09, 0xdb, 0xd4, 0xae, 0x7b,
	0xd5, 0x20, 0x71, 0x47, 0xa7, 0xbc, 0xcf, 0x35, 0x28, 0x2b, 0xdd, 0xfc, 0xac, 0xaa, 0x2a, 0x91,
	0xdf, 0xd2, 0xf0, 0x99, 0xe9, 0x56, 0x82, 0x76, 0xa2, 0x69, 0xeb, 0x76, 0xd7, 0x28, 0xd1, 0xb4,
	0x75, 0xcd, 0xfd, 0xee, 0xb2, 0x80, 0x89, 0xcb, 0x35, 0x22, 0x0f, 0xf2, 0x9b, 0x1a, 0xe4, 0xa2,
	0x9c, 0xc6, 0x44, 0x83, 0xd6, 0x9e, 0x24, 0x9e, 0x68, 0xd0, 0x3a, 0xd2, 0x24, 0xf5, 0x22, 0x32,
	0x32, 0x45, 0x48, 0xc4, 0xc8, 0x63, 0x2f, 0x14, 0x4c, 0x7c, 0x5b, 0x83, 0x7c, 0x54, 0xe3, 0xbd,
	0x85, 0xc1, 0xd8, 0x28, 0x0d, 0x96, 0xad, 0x29, 0x67, 0x94, 0x3e, 0x1d, 0x31, 0xb2, 0xbf, 0xd0,
	0xe2, 0x85, 0x59, 0xd8, 0x4f, 0x20, 0xc3, 0x37, 0x34, 0x2f, 0xf6, 0x4e, 0xdf, 0xe9, 0x7d, 0xe2,
	0x12, 0xdf, 0xbe, 0x1c, 0xb3, 0xf3, 0x55, 0x37, 0x2d, 0x3f, 0xd0, 0x20, 0xaf, 0xc6, 0x41, 0x92,
	0x6f, 0x26, 0xb6, 0xc7, 0x20, 0x8a, 0x5f, 0xe8, 0x44, 0x57, 0xff, 0x28, 0x6a, 0xec, 0xcf, 0xa5,
	0x2a, 0xf5, 0x79, 0x70, 0xa6, 0xcb, 0x96, 0x54, 0xfd, 0x5b, 0xab, 0x2d, 0x65, 0xfe, 0x86, 0xc6,
	0x96, 0x21, 0xcf, 0xa7, 0xbd, 0x96, 0x21, 0x25, 0x0d, 0x29, 0xf1, 0x84, 0x20, 0x9e, 0x52, 0xd3,
	0x75, 0x21, 0x62, 0x08, 0x0a, 0x0b, 0x7f, 0x41, 0xc3, 0xa3, 0x4f, 0x99, 0x8b, 0x71, 0x7d, 0x90,
	0xf4, 0x94, 0xc4, 0xc9, 0xdd, 0x19, 0x23, 0xd7, 0xcf, 0x22, 0x3b, 0xd3, 0x64, 0x52, 0x5d, 0x17,
	0x65, 0xcb, 0x3f, 0xd0, 0xe0, 0x54, 0x47, 0x88, 0x96, 0x7b, 0x08, 0x49, 0x59, 0xd1, 0xc9, 0x51,
	0xdd, 0x41, 0x39, 0xec, 0x9c, 0xe8, 0x32, 0x01, 0x28, 0x08, 0x6b, 0x61, 0x40, 0x7e, 0xa2, 0xc1,
	0x85, 0x5e, 0x61, 0x48, 0x92, 0x94, 0xf9, 0xdc, 0x67, 0x8c, 0xb4, 0xb8, 0xfc, 0x54, 0x34, 0xe2,
	0x4b, 0x8c, 0x3e, 0xa3, 0xc8, 0xbb, 0x16, 0x32, 0x55, 0x14, 0x61, 0x43, 0x36, 0x4f, 0xff, 0x40,
	0x3b, 0x2e, 0x68, 0x86, 0x9c, 0x04, 0xe4, 0x8b, 0x4f, 0x14, 0xa0, 0x8c, 0x46, 0xe0, 0x9d, 0x27,
	0xad, 0x7e, 0xec, 0xda, 0xdd, 0xd6, 0x09, 0xf2, 0x4f, 0x8e, 0x8b, 0x7d, 0xbe, 0x31, 0x70, 0xd3,
	0xbd, 0x37, 0x64, 0x49, 0xf1, 0x45, 0xfd, 0x75, 0xe4, 0xb5, 0x44, 0xae, 0x77, 0xf0, 0x3a, 0xff,
	0xf1, 0x71, 0x21, 0xcd, 0x4f, 0xc8, 0xef, 0x68, 0x18, 0xf5, 0x8a, 0x47, 0xd9, 0xc8, 0x6b, 0x83,
	0xc5, 0xe4, 0x38, 0xe7, 0xaf, 0x3f, 0x49, 0x20, 0xaf, 0x4b, 0xc0, 0xe0, 0x43, 0x6f, 0xbb, 0xec,
	0x0b, 0xe4, 0xb8, 0xb7, 0x96, 0x8b, 0xe2, 0x73, 0x89, 0x0b, 0x4c, 0x7b, 0xc0, 0x2f, 0x71, 0x9d,
	0xeb, 0x08, 0xf9, 0xe9, 0xe7, 0x91, 0xa3, 0xd3, 0x64, 0x5a, 0xe5, 0x68, 0xfe, 0x63, 0x1e, 0x32,
	0xfc, 0x84, 0x7c, 0x4f, 0xc3, 0x47, 0x47, 0x5b, 0xf1, 0xb6, 0x44, 0x27, 0xa0, 0x5b, 0x28, 0x30,
	0xd1, 0x09, 0xe8, 0x1e, 0xca, 0x13, 0xc6, 0x54, 0x6f, 0xd9, 0x06, 0x8c, 0x8d, 0x05, 0x7b, 0x0e,
	0x9e, 0x34, 0xb2, 0xb9, 0xf4, 0x7b, 0x1a, 0x4c, 0x75, 0x8b, 0xaf, 0x25, 0x6a, 0x62, 0x42, 0x7c,
	0x30, 0x51, 0x13, 0x93, 0x42, 0x82, 0xfa, 0xe7, 0x90, 0xd9, 0x39, 0xd2, 0xda, 0x8c, 0x61, 0x06,
	0x3e, 0xfe, 0xe1, 0x5d, 0x25, 0xca, 0xf7, 0x23, 0x4d, 0x44, 0x4a, 0xdb, 0xa2, 0x6b, 0x89, 0x0c,
	0x27, 0x84, 0xf4, 0x8a, 0x37, 0x07, 0xae, 0x77, 0xec, 0xee, 0x11, 0xa5, 0x1b, 0xe7, 0x1a, 0x85,
	0xfc, 0x6b, 0x1a, 0x8c, 0xaa, 0xa1, 0xbd, 0x44, 0x57, 0xbd, 0x4b, 0x68, 0x30, 0xd1, 0x55, 0xef,
	0x16, 0x33, 0xec, 0x76, 0x1c, 0xb9, 0xe7, 0x60, 0xe0, 0x70, 0xe9, 0xda, 0x8f, 0xff, 0xe3, 0xec,
	0x89, 0x1f, 0x1f, 0xcd, 0x6a, 0x3f, 0x39, 0x9a, 0xd5, 0x7e, 0x7a, 0x34, 0xab, 0xfd, 0x87, 0xa3,
	0x59, 0xed, 0x37, 0x7f, 0x36, 0x7b, 0xe2, 0x27, 0x3f, 0x9b, 0x3d, 0xf1, 0xd3, 0x9f, 0xcd, 0x9e,
	0xf8, 0x20, 0x2b, 0x69, 0x6f, 0x0f, 0x63, 0xd8, 0xf4, 0xb5, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff,
	0xa4, 0x61, 0x5a, 0x78, 0x5e, 0x7e, 0x00, 0x00,
}

func (this *PrettySpan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrettySpan)
	if !ok {
		that2, ok := that.(PrettySpan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartKey != that1.StartKey {
		return false
	}
	if this.EndKey != that1.EndKey {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StatusClient is the client API for Status service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StatusClient interface {
	// Certificates retrieves a copy of the TLS certificates.
	Certificates(ctx context.Context, in *CertificatesRequest, opts ...grpc.CallOption) (*CertificatesResponse, error)
	// Details retrieves details about the nodes in the cluster.
	Details(ctx context.Context, in *DetailsRequest, opts ...grpc.CallOption) (*DetailsResponse, error)
	// RegionsRequest retrieves all available regions.
	Regions(ctx context.Context, in *RegionsRequest, opts ...grpc.CallOption) (*RegionsResponse, error)
	// Nodes returns status info for all commissioned nodes. Decommissioned nodes
	// are not included, except in rare cases where the node doing the
	// decommissioning crashed before completing the operation. In these cases,
	// the decommission operation can be rerun to clean up the status entry.
	//
	// API: PUBLIC ALPHA
	//
	// Don't introduce additional usages of this RPC. See #50707 for more details.
	// The underlying response type is something we're looking to get rid of.
	Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesResponse, error)
	// Node retrieves details about a single node.
	// API: PUBLIC ALPHA
	Node(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*statuspb.NodeStatus, error)
	NodesUI(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesResponseExternal, error)
	NodeUI(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*NodeResponse, error)
	// RaftDebug requests internal details about Raft.
	RaftDebug(ctx context.Context, in *RaftDebugRequest, opts ...grpc.CallOption) (*RaftDebugResponse, error)
	// Ranges requests internal details about ranges on a given node.
	Ranges(ctx context.Context, in *RangesRequest, opts ...grpc.CallOption) (*RangesResponse, error)
	// Gossip retrieves gossip-level details about a given node.
	Gossip(ctx context.Context, in *GossipRequest, opts ...grpc.CallOption) (*gossip.InfoStatus, error)
	// EngineStats retrieves statistics about a storage engine.
	EngineStats(ctx context.Context, in *EngineStatsRequest, opts ...grpc.CallOption) (*EngineStatsResponse, error)
	// Allocator retrieves statistics about the replica allocator.
	Allocator(ctx context.Context, in *AllocatorRequest, opts ...grpc.CallOption) (*AllocatorResponse, error)
	// AllocatorRange retrieves statistics about the replica allocator given
	// a specific range.
	AllocatorRange(ctx context.Context, in *AllocatorRangeRequest, opts ...grpc.CallOption) (*AllocatorRangeResponse, error)
	// ListSessions retrieves the SQL sessions across the entire cluster.
	ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error)
	// ListLocalSessions retrieves the SQL sessions on this node.
	ListLocalSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error)
	// CancelQuery cancels a SQL query given its ID.
	CancelQuery(ctx context.Context, in *CancelQueryRequest, opts ...grpc.CallOption) (*CancelQueryResponse, error)
	// CancelLocalQuery cancels a SQL query running on this node given its ID.
	CancelLocalQuery(ctx context.Context, in *CancelQueryRequest, opts ...grpc.CallOption) (*CancelQueryResponse, error)
	// ListContentionEvents retrieves the contention events across the entire
	// cluster.
	//
	// For SQL keys the following orderings are maintained:
	// - on the highest level, all IndexContentionEvents objects are ordered
	//   according to their importance (as defined by the number of contention
	//   events within each object).
	// - on the middle level, all SingleKeyContention objects are ordered by their
	//   keys lexicographically.
	// - on the lowest level, all SingleTxnContention objects are ordered by the
	//   number of times that transaction was observed to contend with other
	//   transactions.
	//
	// For non-SQL keys the following orderings are maintained:
	// - on the top level, all SingleNonSQLKeyContention objects are ordered
	//   by their keys lexicographically.
	// - on the bottom level, all SingleTxnContention objects are ordered by the
	//   number of times that transaction was observed to contend with other
	//   transactions.
	ListContentionEvents(ctx context.Context, in *ListContentionEventsRequest, opts ...grpc.CallOption) (*ListContentionEventsResponse, error)
	// ListLocalContentionEvents retrieves the contention events on this node.
	//
	// For SQL keys the following orderings are maintained:
	// - on the highest level, all IndexContentionEvents objects are ordered
	//   according to their importance (as defined by the number of contention
	//   events within each object).
	// - on the middle level, all SingleKeyContention objects are ordered by their
	//   keys lexicographically.
	// - on the lowest level, all SingleTxnContention objects are ordered by the
	//   number of times that transaction was observed to contend with other
	//   transactions.
	//
	// For non-SQL keys the following orderings are maintained:
	// - on the top level, all SingleNonSQLKeyContention objects are ordered
	//   by their keys lexicographically.
	// - on the bottom level, all SingleTxnContention objects are ordered by the
	//   number of times that transaction was observed to contend with other
	//   transactions.
	ListLocalContentionEvents(ctx context.Context, in *ListContentionEventsRequest, opts ...grpc.CallOption) (*ListContentionEventsResponse, error)
	// ListDistSQLFlows retrieves all of the remote flows of the DistSQL execution
	// that are currently running or queued on any node in the cluster. The local
	// flows (those that are running on the same node as the query originated on)
	// are not included.
	//
	// Flows are ordered lexicographically by the flow ID.
	ListDistSQLFlows(ctx context.Context, in *ListDistSQLFlowsRequest, opts ...grpc.CallOption) (*ListDistSQLFlowsResponse, error)
	// ListLocalDistSQLFlows retrieves all of the remote flows of the DistSQL
	// execution that are currently running or queued on this node in the cluster.
	// Queries that originated on this node are not be included.
	//
	// Flows are ordered lexicographically by the flow ID.
	ListLocalDistSQLFlows(ctx context.Context, in *ListDistSQLFlowsRequest, opts ...grpc.CallOption) (*ListDistSQLFlowsResponse, error)
	// CancelSessions forcefully terminates a SQL session given its ID.
	CancelSession(ctx context.Context, in *CancelSessionRequest, opts ...grpc.CallOption) (*CancelSessionResponse, error)
	// CancelLocalSession forcefully terminates a SQL session running on this node given its ID.
	CancelLocalSession(ctx context.Context, in *CancelSessionRequest, opts ...grpc.CallOption) (*CancelSessionResponse, error)
	// SpanStats accepts a key span and node ID, and returns a set of stats
	// summed from all ranges on the stores on that node which contain keys
	// in that span. This is designed to compute stats specific to a SQL table:
	// it will be called with the highest/lowest key for a SQL table, and return
	// information about the resources on a node used by that table.
	SpanStats(ctx context.Context, in *SpanStatsRequest, opts ...grpc.CallOption) (*SpanStatsResponse, error)
	// Stacks retrieves the stack traces of all goroutines on a given node.
	Stacks(ctx context.Context, in *StacksRequest, opts ...grpc.CallOption) (*JSONResponse, error)
	// Profile retrieves a CPU profile on a given node.
	Profile(ctx context.Context, in *ProfileRequest, opts ...grpc.CallOption) (*JSONResponse, error)
	// Metrics retrieves the node metrics for a given node.
	//
	// Note: this is a reserved API and should not be relied upon to
	// build external tools. No guarantee is made about its
	// availability and stability in external uses.
	Metrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*JSONResponse, error)
	// GetFiles retrieves heap or goroutine dump files from a given node.
	GetFiles(ctx context.Context, in *GetFilesRequest, opts ...grpc.CallOption) (*GetFilesResponse, error)
	// LogFilesList retrieves a list of log files on a given node.
	LogFilesList(ctx context.Context, in *LogFilesListRequest, opts ...grpc.CallOption) (*LogFilesListResponse, error)
	// LogFile retrieves a given log file.
	LogFile(ctx context.Context, in *LogFileRequest, opts ...grpc.CallOption) (*LogEntriesResponse, error)
	// Logs retrieves individual log entries.
	Logs(ctx context.Context, in *LogsRequest, opts ...grpc.CallOption) (*LogEntriesResponse, error)
	// ProblemRanges retrieves the list of problem ranges.
	ProblemRanges(ctx context.Context, in *ProblemRangesRequest, opts ...grpc.CallOption) (*ProblemRangesResponse, error)
	HotRanges(ctx context.Context, in *HotRangesRequest, opts ...grpc.CallOption) (*HotRangesResponse, error)
	HotRangesV2(ctx context.Context, in *HotRangesRequest, opts ...grpc.CallOption) (*HotRangesResponseV2, error)
	Range(ctx context.Context, in *RangeRequest, opts ...grpc.CallOption) (*RangeResponse, error)
	Diagnostics(ctx context.Context, in *DiagnosticsRequest, opts ...grpc.CallOption) (*diagnosticspb.DiagnosticReport, error)
	Stores(ctx context.Context, in *StoresRequest, opts ...grpc.CallOption) (*StoresResponse, error)
	Statements(ctx context.Context, in *StatementsRequest, opts ...grpc.CallOption) (*StatementsResponse, error)
	// Retrieve the combined in-memory and persisted statement stats by date range.
	CombinedStatementStats(ctx context.Context, in *CombinedStatementsStatsRequest, opts ...grpc.CallOption) (*StatementsResponse, error)
	CreateStatementDiagnosticsReport(ctx context.Context, in *CreateStatementDiagnosticsReportRequest, opts ...grpc.CallOption) (*CreateStatementDiagnosticsReportResponse, error)
	StatementDiagnosticsRequests(ctx context.Context, in *StatementDiagnosticsReportsRequest, opts ...grpc.CallOption) (*StatementDiagnosticsReportsResponse, error)
	StatementDiagnostics(ctx context.Context, in *StatementDiagnosticsRequest, opts ...grpc.CallOption) (*StatementDiagnosticsResponse, error)
	JobRegistryStatus(ctx context.Context, in *JobRegistryStatusRequest, opts ...grpc.CallOption) (*JobRegistryStatusResponse, error)
	JobStatus(ctx context.Context, in *JobStatusRequest, opts ...grpc.CallOption) (*JobStatusResponse, error)
	ResetSQLStats(ctx context.Context, in *ResetSQLStatsRequest, opts ...grpc.CallOption) (*ResetSQLStatsResponse, error)
	IndexUsageStatistics(ctx context.Context, in *IndexUsageStatisticsRequest, opts ...grpc.CallOption) (*IndexUsageStatisticsResponse, error)
	ResetIndexUsageStats(ctx context.Context, in *ResetIndexUsageStatsRequest, opts ...grpc.CallOption) (*ResetIndexUsageStatsResponse, error)
	UserSQLRoles(ctx context.Context, in *UserSQLRolesRequest, opts ...grpc.CallOption) (*UserSQLRolesResponse, error)
}

type statusClient struct {
	cc *grpc.ClientConn
}

func NewStatusClient(cc *grpc.ClientConn) StatusClient {
	return &statusClient{cc}
}

func (c *statusClient) Certificates(ctx context.Context, in *CertificatesRequest, opts ...grpc.CallOption) (*CertificatesResponse, error) {
	out := new(CertificatesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Certificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Details(ctx context.Context, in *DetailsRequest, opts ...grpc.CallOption) (*DetailsResponse, error) {
	out := new(DetailsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Details", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Regions(ctx context.Context, in *RegionsRequest, opts ...grpc.CallOption) (*RegionsResponse, error) {
	out := new(RegionsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Regions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesResponse, error) {
	out := new(NodesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Nodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Node(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*statuspb.NodeStatus, error) {
	out := new(statuspb.NodeStatus)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Node", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) NodesUI(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesResponseExternal, error) {
	out := new(NodesResponseExternal)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/NodesUI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) NodeUI(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*NodeResponse, error) {
	out := new(NodeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/NodeUI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) RaftDebug(ctx context.Context, in *RaftDebugRequest, opts ...grpc.CallOption) (*RaftDebugResponse, error) {
	out := new(RaftDebugResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/RaftDebug", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Ranges(ctx context.Context, in *RangesRequest, opts ...grpc.CallOption) (*RangesResponse, error) {
	out := new(RangesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Ranges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Gossip(ctx context.Context, in *GossipRequest, opts ...grpc.CallOption) (*gossip.InfoStatus, error) {
	out := new(gossip.InfoStatus)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Gossip", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) EngineStats(ctx context.Context, in *EngineStatsRequest, opts ...grpc.CallOption) (*EngineStatsResponse, error) {
	out := new(EngineStatsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/EngineStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Allocator(ctx context.Context, in *AllocatorRequest, opts ...grpc.CallOption) (*AllocatorResponse, error) {
	out := new(AllocatorResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Allocator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) AllocatorRange(ctx context.Context, in *AllocatorRangeRequest, opts ...grpc.CallOption) (*AllocatorRangeResponse, error) {
	out := new(AllocatorRangeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/AllocatorRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error) {
	out := new(ListSessionsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ListSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ListLocalSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error) {
	out := new(ListSessionsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ListLocalSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CancelQuery(ctx context.Context, in *CancelQueryRequest, opts ...grpc.CallOption) (*CancelQueryResponse, error) {
	out := new(CancelQueryResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CancelQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CancelLocalQuery(ctx context.Context, in *CancelQueryRequest, opts ...grpc.CallOption) (*CancelQueryResponse, error) {
	out := new(CancelQueryResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CancelLocalQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ListContentionEvents(ctx context.Context, in *ListContentionEventsRequest, opts ...grpc.CallOption) (*ListContentionEventsResponse, error) {
	out := new(ListContentionEventsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ListContentionEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ListLocalContentionEvents(ctx context.Context, in *ListContentionEventsRequest, opts ...grpc.CallOption) (*ListContentionEventsResponse, error) {
	out := new(ListContentionEventsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ListLocalContentionEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ListDistSQLFlows(ctx context.Context, in *ListDistSQLFlowsRequest, opts ...grpc.CallOption) (*ListDistSQLFlowsResponse, error) {
	out := new(ListDistSQLFlowsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ListDistSQLFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ListLocalDistSQLFlows(ctx context.Context, in *ListDistSQLFlowsRequest, opts ...grpc.CallOption) (*ListDistSQLFlowsResponse, error) {
	out := new(ListDistSQLFlowsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ListLocalDistSQLFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CancelSession(ctx context.Context, in *CancelSessionRequest, opts ...grpc.CallOption) (*CancelSessionResponse, error) {
	out := new(CancelSessionResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CancelSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CancelLocalSession(ctx context.Context, in *CancelSessionRequest, opts ...grpc.CallOption) (*CancelSessionResponse, error) {
	out := new(CancelSessionResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CancelLocalSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) SpanStats(ctx context.Context, in *SpanStatsRequest, opts ...grpc.CallOption) (*SpanStatsResponse, error) {
	out := new(SpanStatsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/SpanStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Stacks(ctx context.Context, in *StacksRequest, opts ...grpc.CallOption) (*JSONResponse, error) {
	out := new(JSONResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Stacks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Profile(ctx context.Context, in *ProfileRequest, opts ...grpc.CallOption) (*JSONResponse, error) {
	out := new(JSONResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Profile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Metrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*JSONResponse, error) {
	out := new(JSONResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Metrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) GetFiles(ctx context.Context, in *GetFilesRequest, opts ...grpc.CallOption) (*GetFilesResponse, error) {
	out := new(GetFilesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/GetFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) LogFilesList(ctx context.Context, in *LogFilesListRequest, opts ...grpc.CallOption) (*LogFilesListResponse, error) {
	out := new(LogFilesListResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/LogFilesList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) LogFile(ctx context.Context, in *LogFileRequest, opts ...grpc.CallOption) (*LogEntriesResponse, error) {
	out := new(LogEntriesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/LogFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Logs(ctx context.Context, in *LogsRequest, opts ...grpc.CallOption) (*LogEntriesResponse, error) {
	out := new(LogEntriesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Logs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ProblemRanges(ctx context.Context, in *ProblemRangesRequest, opts ...grpc.CallOption) (*ProblemRangesResponse, error) {
	out := new(ProblemRangesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ProblemRanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) HotRanges(ctx context.Context, in *HotRangesRequest, opts ...grpc.CallOption) (*HotRangesResponse, error) {
	out := new(HotRangesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/HotRanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) HotRangesV2(ctx context.Context, in *HotRangesRequest, opts ...grpc.CallOption) (*HotRangesResponseV2, error) {
	out := new(HotRangesResponseV2)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/HotRangesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Range(ctx context.Context, in *RangeRequest, opts ...grpc.CallOption) (*RangeResponse, error) {
	out := new(RangeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Range", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Diagnostics(ctx context.Context, in *DiagnosticsRequest, opts ...grpc.CallOption) (*diagnosticspb.DiagnosticReport, error) {
	out := new(diagnosticspb.DiagnosticReport)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Diagnostics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Stores(ctx context.Context, in *StoresRequest, opts ...grpc.CallOption) (*StoresResponse, error) {
	out := new(StoresResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Stores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Statements(ctx context.Context, in *StatementsRequest, opts ...grpc.CallOption) (*StatementsResponse, error) {
	out := new(StatementsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Statements", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CombinedStatementStats(ctx context.Context, in *CombinedStatementsStatsRequest, opts ...grpc.CallOption) (*StatementsResponse, error) {
	out := new(StatementsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CombinedStatementStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CreateStatementDiagnosticsReport(ctx context.Context, in *CreateStatementDiagnosticsReportRequest, opts ...grpc.CallOption) (*CreateStatementDiagnosticsReportResponse, error) {
	out := new(CreateStatementDiagnosticsReportResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CreateStatementDiagnosticsReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) StatementDiagnosticsRequests(ctx context.Context, in *StatementDiagnosticsReportsRequest, opts ...grpc.CallOption) (*StatementDiagnosticsReportsResponse, error) {
	out := new(StatementDiagnosticsReportsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/StatementDiagnosticsRequests", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) StatementDiagnostics(ctx context.Context, in *StatementDiagnosticsRequest, opts ...grpc.CallOption) (*StatementDiagnosticsResponse, error) {
	out := new(StatementDiagnosticsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/StatementDiagnostics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) JobRegistryStatus(ctx context.Context, in *JobRegistryStatusRequest, opts ...grpc.CallOption) (*JobRegistryStatusResponse, error) {
	out := new(JobRegistryStatusResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/JobRegistryStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) JobStatus(ctx context.Context, in *JobStatusRequest, opts ...grpc.CallOption) (*JobStatusResponse, error) {
	out := new(JobStatusResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/JobStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ResetSQLStats(ctx context.Context, in *ResetSQLStatsRequest, opts ...grpc.CallOption) (*ResetSQLStatsResponse, error) {
	out := new(ResetSQLStatsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ResetSQLStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) IndexUsageStatistics(ctx context.Context, in *IndexUsageStatisticsRequest, opts ...grpc.CallOption) (*IndexUsageStatisticsResponse, error) {
	out := new(IndexUsageStatisticsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/IndexUsageStatistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ResetIndexUsageStats(ctx context.Context, in *ResetIndexUsageStatsRequest, opts ...grpc.CallOption) (*ResetIndexUsageStatsResponse, error) {
	out := new(ResetIndexUsageStatsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ResetIndexUsageStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) UserSQLRoles(ctx context.Context, in *UserSQLRolesRequest, opts ...grpc.CallOption) (*UserSQLRolesResponse, error) {
	out := new(UserSQLRolesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/UserSQLRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StatusServer is the server API for Status service.
type StatusServer interface {
	// Certificates retrieves a copy of the TLS certificates.
	Certificates(context.Context, *CertificatesRequest) (*CertificatesResponse, error)
	// Details retrieves details about the nodes in the cluster.
	Details(context.Context, *DetailsRequest) (*DetailsResponse, error)
	// RegionsRequest retrieves all available regions.
	Regions(context.Context, *RegionsRequest) (*RegionsResponse, error)
	// Nodes returns status info for all commissioned nodes. Decommissioned nodes
	// are not included, except in rare cases where the node doing the
	// decommissioning crashed before completing the operation. In these cases,
	// the decommission operation can be rerun to clean up the status entry.
	//
	// API: PUBLIC ALPHA
	//
	// Don't introduce additional usages of this RPC. See #50707 for more details.
	// The underlying response type is something we're looking to get rid of.
	Nodes(context.Context, *NodesRequest) (*NodesResponse, error)
	// Node retrieves details about a single node.
	// API: PUBLIC ALPHA
	Node(context.Context, *NodeRequest) (*statuspb.NodeStatus, error)
	NodesUI(context.Context, *NodesRequest) (*NodesResponseExternal, error)
	NodeUI(context.Context, *NodeRequest) (*NodeResponse, error)
	// RaftDebug requests internal details about Raft.
	RaftDebug(context.Context, *RaftDebugRequest) (*RaftDebugResponse, error)
	// Ranges requests internal details about ranges on a given node.
	Ranges(context.Context, *RangesRequest) (*RangesResponse, error)
	// Gossip retrieves gossip-level details about a given node.
	Gossip(context.Context, *GossipRequest) (*gossip.InfoStatus, error)
	// EngineStats retrieves statistics about a storage engine.
	EngineStats(context.Context, *EngineStatsRequest) (*EngineStatsResponse, error)
	// Allocator retrieves statistics about the replica allocator.
	Allocator(context.Context, *AllocatorRequest) (*AllocatorResponse, error)
	// AllocatorRange retrieves statistics about the replica allocator given
	// a specific range.
	AllocatorRange(context.Context, *AllocatorRangeRequest) (*AllocatorRangeResponse, error)
	// ListSessions retrieves the SQL sessions across the entire cluster.
	ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
	// ListLocalSessions retrieves the SQL sessions on this node.
	ListLocalSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
	// CancelQuery cancels a SQL query given its ID.
	CancelQuery(context.Context, *CancelQueryRequest) (*CancelQueryResponse, error)
	// CancelLocalQuery cancels a SQL query running on this node given its ID.
	CancelLocalQuery(context.Context, *CancelQueryRequest) (*CancelQueryResponse, error)
	// ListContentionEvents retrieves the contention events across the entire
	// cluster.
	//
	// For SQL keys the following orderings are maintained:
	// - on the highest level, all IndexContentionEvents objects are ordered
	//   according to their importance (as defined by the number of contention
	//   events within each object).
	// - on the middle level, all SingleKeyContention objects are ordered by their
	//   keys lexicographically.
	// - on the lowest level, all SingleTxnContention objects are ordered by the
	//   number of times that transaction was observed to contend with other
	//   transactions.
	//
	// For non-SQL keys the following orderings are maintained:
	// - on the top level, all SingleNonSQLKeyContention objects are ordered
	//   by their keys lexicographically.
	// - on the bottom level, all SingleTxnContention objects are ordered by the
	//   number of times that transaction was observed to contend with other
	//   transactions.
	ListContentionEvents(context.Context, *ListContentionEventsRequest) (*ListContentionEventsResponse, error)
	// ListLocalContentionEvents retrieves the contention events on this node.
	//
	// For SQL keys the following orderings are maintained:
	// - on the highest level, all IndexContentionEvents objects are ordered
	//   according to their importance (as defined by the number of contention
	//   events within each object).
	// - on the middle level, all SingleKeyContention objects are ordered by their
	//   keys lexicographically.
	// - on the lowest level, all SingleTxnContention objects are ordered by the
	//   number of times that transaction was observed to contend with other
	//   transactions.
	//
	// For non-SQL keys the following orderings are maintained:
	// - on the top level, all SingleNonSQLKeyContention objects are ordered
	//   by their keys lexicographically.
	// - on the bottom level, all SingleTxnContention objects are ordered by the
	//   number of times that transaction was observed to contend with other
	//   transactions.
	ListLocalContentionEvents(context.Context, *ListContentionEventsRequest) (*ListContentionEventsResponse, error)
	// ListDistSQLFlows retrieves all of the remote flows of the DistSQL execution
	// that are currently running or queued on any node in the cluster. The local
	// flows (those that are running on the same node as the query originated on)
	// are not included.
	//
	// Flows are ordered lexicographically by the flow ID.
	ListDistSQLFlows(context.Context, *ListDistSQLFlowsRequest) (*ListDistSQLFlowsResponse, error)
	// ListLocalDistSQLFlows retrieves all of the remote flows of the DistSQL
	// execution that are currently running or queued on this node in the cluster.
	// Queries that originated on this node are not be included.
	//
	// Flows are ordered lexicographically by the flow ID.
	ListLocalDistSQLFlows(context.Context, *ListDistSQLFlowsRequest) (*ListDistSQLFlowsResponse, error)
	// CancelSessions forcefully terminates a SQL session given its ID.
	CancelSession(context.Context, *CancelSessionRequest) (*CancelSessionResponse, error)
	// CancelLocalSession forcefully terminates a SQL session running on this node given its ID.
	CancelLocalSession(context.Context, *CancelSessionRequest) (*CancelSessionResponse, error)
	// SpanStats accepts a key span and node ID, and returns a set of stats
	// summed from all ranges on the stores on that node which contain keys
	// in that span. This is designed to compute stats specific to a SQL table:
	// it will be called with the highest/lowest key for a SQL table, and return
	// information about the resources on a node used by that table.
	SpanStats(context.Context, *SpanStatsRequest) (*SpanStatsResponse, error)
	// Stacks retrieves the stack traces of all goroutines on a given node.
	Stacks(context.Context, *StacksRequest) (*JSONResponse, error)
	// Profile retrieves a CPU profile on a given node.
	Profile(context.Context, *ProfileRequest) (*JSONResponse, error)
	// Metrics retrieves the node metrics for a given node.
	//
	// Note: this is a reserved API and should not be relied upon to
	// build external tools. No guarantee is made about its
	// availability and stability in external uses.
	Metrics(context.Context, *MetricsRequest) (*JSONResponse, error)
	// GetFiles retrieves heap or goroutine dump files from a given node.
	GetFiles(context.Context, *GetFilesRequest) (*GetFilesResponse, error)
	// LogFilesList retrieves a list of log files on a given node.
	LogFilesList(context.Context, *LogFilesListRequest) (*LogFilesListResponse, error)
	// LogFile retrieves a given log file.
	LogFile(context.Context, *LogFileRequest) (*LogEntriesResponse, error)
	// Logs retrieves individual log entries.
	Logs(context.Context, *LogsRequest) (*LogEntriesResponse, error)
	// ProblemRanges retrieves the list of problem ranges.
	ProblemRanges(context.Context, *ProblemRangesRequest) (*ProblemRangesResponse, error)
	HotRanges(context.Context, *HotRangesRequest) (*HotRangesResponse, error)
	HotRangesV2(context.Context, *HotRangesRequest) (*HotRangesResponseV2, error)
	Range(context.Context, *RangeRequest) (*RangeResponse, error)
	Diagnostics(context.Context, *DiagnosticsRequest) (*diagnosticspb.DiagnosticReport, error)
	Stores(context.Context, *StoresRequest) (*StoresResponse, error)
	Statements(context.Context, *StatementsRequest) (*StatementsResponse, error)
	// Retrieve the combined in-memory and persisted statement stats by date range.
	CombinedStatementStats(context.Context, *CombinedStatementsStatsRequest) (*StatementsResponse, error)
	CreateStatementDiagnosticsReport(context.Context, *CreateStatementDiagnosticsReportRequest) (*CreateStatementDiagnosticsReportResponse, error)
	StatementDiagnosticsRequests(context.Context, *StatementDiagnosticsReportsRequest) (*StatementDiagnosticsReportsResponse, error)
	StatementDiagnostics(context.Context, *StatementDiagnosticsRequest) (*StatementDiagnosticsResponse, error)
	JobRegistryStatus(context.Context, *JobRegistryStatusRequest) (*JobRegistryStatusResponse, error)
	JobStatus(context.Context, *JobStatusRequest) (*JobStatusResponse, error)
	ResetSQLStats(context.Context, *ResetSQLStatsRequest) (*ResetSQLStatsResponse, error)
	IndexUsageStatistics(context.Context, *IndexUsageStatisticsRequest) (*IndexUsageStatisticsResponse, error)
	ResetIndexUsageStats(context.Context, *ResetIndexUsageStatsRequest) (*ResetIndexUsageStatsResponse, error)
	UserSQLRoles(context.Context, *UserSQLRolesRequest) (*UserSQLRolesResponse, error)
}

// UnimplementedStatusServer can be embedded to have forward compatible implementations.
type UnimplementedStatusServer struct {
}

func (*UnimplementedStatusServer) Certificates(ctx context.Context, req *CertificatesRequest) (*CertificatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Certificates not implemented")
}
func (*UnimplementedStatusServer) Details(ctx context.Context, req *DetailsRequest) (*DetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Details not implemented")
}
func (*UnimplementedStatusServer) Regions(ctx context.Context, req *RegionsRequest) (*RegionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Regions not implemented")
}
func (*UnimplementedStatusServer) Nodes(ctx context.Context, req *NodesRequest) (*NodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Nodes not implemented")
}
func (*UnimplementedStatusServer) Node(ctx context.Context, req *NodeRequest) (*statuspb.NodeStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Node not implemented")
}
func (*UnimplementedStatusServer) NodesUI(ctx context.Context, req *NodesRequest) (*NodesResponseExternal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodesUI not implemented")
}
func (*UnimplementedStatusServer) NodeUI(ctx context.Context, req *NodeRequest) (*NodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeUI not implemented")
}
func (*UnimplementedStatusServer) RaftDebug(ctx context.Context, req *RaftDebugRequest) (*RaftDebugResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RaftDebug not implemented")
}
func (*UnimplementedStatusServer) Ranges(ctx context.Context, req *RangesRequest) (*RangesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ranges not implemented")
}
func (*UnimplementedStatusServer) Gossip(ctx context.Context, req *GossipRequest) (*gossip.InfoStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Gossip not implemented")
}
func (*UnimplementedStatusServer) EngineStats(ctx context.Context, req *EngineStatsRequest) (*EngineStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EngineStats not implemented")
}
func (*UnimplementedStatusServer) Allocator(ctx context.Context, req *AllocatorRequest) (*AllocatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Allocator not implemented")
}
func (*UnimplementedStatusServer) AllocatorRange(ctx context.Context, req *AllocatorRangeRequest) (*AllocatorRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocatorRange not implemented")
}
func (*UnimplementedStatusServer) ListSessions(ctx context.Context, req *ListSessionsRequest) (*ListSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSessions not implemented")
}
func (*UnimplementedStatusServer) ListLocalSessions(ctx context.Context, req *ListSessionsRequest) (*ListSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLocalSessions not implemented")
}
func (*UnimplementedStatusServer) CancelQuery(ctx context.Context, req *CancelQueryRequest) (*CancelQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelQuery not implemented")
}
func (*UnimplementedStatusServer) CancelLocalQuery(ctx context.Context, req *CancelQueryRequest) (*CancelQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelLocalQuery not implemented")
}
func (*UnimplementedStatusServer) ListContentionEvents(ctx context.Context, req *ListContentionEventsRequest) (*ListContentionEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContentionEvents not implemented")
}
func (*UnimplementedStatusServer) ListLocalContentionEvents(ctx context.Context, req *ListContentionEventsRequest) (*ListContentionEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLocalContentionEvents not implemented")
}
func (*UnimplementedStatusServer) ListDistSQLFlows(ctx context.Context, req *ListDistSQLFlowsRequest) (*ListDistSQLFlowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDistSQLFlows not implemented")
}
func (*UnimplementedStatusServer) ListLocalDistSQLFlows(ctx context.Context, req *ListDistSQLFlowsRequest) (*ListDistSQLFlowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLocalDistSQLFlows not implemented")
}
func (*UnimplementedStatusServer) CancelSession(ctx context.Context, req *CancelSessionRequest) (*CancelSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSession not implemented")
}
func (*UnimplementedStatusServer) CancelLocalSession(ctx context.Context, req *CancelSessionRequest) (*CancelSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelLocalSession not implemented")
}
func (*UnimplementedStatusServer) SpanStats(ctx context.Context, req *SpanStatsRequest) (*SpanStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpanStats not implemented")
}
func (*UnimplementedStatusServer) Stacks(ctx context.Context, req *StacksRequest) (*JSONResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stacks not implemented")
}
func (*UnimplementedStatusServer) Profile(ctx context.Context, req *ProfileRequest) (*JSONResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Profile not implemented")
}
func (*UnimplementedStatusServer) Metrics(ctx context.Context, req *MetricsRequest) (*JSONResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metrics not implemented")
}
func (*UnimplementedStatusServer) GetFiles(ctx context.Context, req *GetFilesRequest) (*GetFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFiles not implemented")
}
func (*UnimplementedStatusServer) LogFilesList(ctx context.Context, req *LogFilesListRequest) (*LogFilesListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogFilesList not implemented")
}
func (*UnimplementedStatusServer) LogFile(ctx context.Context, req *LogFileRequest) (*LogEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogFile not implemented")
}
func (*UnimplementedStatusServer) Logs(ctx context.Context, req *LogsRequest) (*LogEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logs not implemented")
}
func (*UnimplementedStatusServer) ProblemRanges(ctx context.Context, req *ProblemRangesRequest) (*ProblemRangesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProblemRanges not implemented")
}
func (*UnimplementedStatusServer) HotRanges(ctx context.Context, req *HotRangesRequest) (*HotRangesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HotRanges not implemented")
}
func (*UnimplementedStatusServer) HotRangesV2(ctx context.Context, req *HotRangesRequest) (*HotRangesResponseV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HotRangesV2 not implemented")
}
func (*UnimplementedStatusServer) Range(ctx context.Context, req *RangeRequest) (*RangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Range not implemented")
}
func (*UnimplementedStatusServer) Diagnostics(ctx context.Context, req *DiagnosticsRequest) (*diagnosticspb.DiagnosticReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Diagnostics not implemented")
}
func (*UnimplementedStatusServer) Stores(ctx context.Context, req *StoresRequest) (*StoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stores not implemented")
}
func (*UnimplementedStatusServer) Statements(ctx context.Context, req *StatementsRequest) (*StatementsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Statements not implemented")
}
func (*UnimplementedStatusServer) CombinedStatementStats(ctx context.Context, req *CombinedStatementsStatsRequest) (*StatementsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CombinedStatementStats not implemented")
}
func (*UnimplementedStatusServer) CreateStatementDiagnosticsReport(ctx context.Context, req *CreateStatementDiagnosticsReportRequest) (*CreateStatementDiagnosticsReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStatementDiagnosticsReport not implemented")
}
func (*UnimplementedStatusServer) StatementDiagnosticsRequests(ctx context.Context, req *StatementDiagnosticsReportsRequest) (*StatementDiagnosticsReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatementDiagnosticsRequests not implemented")
}
func (*UnimplementedStatusServer) StatementDiagnostics(ctx context.Context, req *StatementDiagnosticsRequest) (*StatementDiagnosticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatementDiagnostics not implemented")
}
func (*UnimplementedStatusServer) JobRegistryStatus(ctx context.Context, req *JobRegistryStatusRequest) (*JobRegistryStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JobRegistryStatus not implemented")
}
func (*UnimplementedStatusServer) JobStatus(ctx context.Context, req *JobStatusRequest) (*JobStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JobStatus not implemented")
}
func (*UnimplementedStatusServer) ResetSQLStats(ctx context.Context, req *ResetSQLStatsRequest) (*ResetSQLStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetSQLStats not implemented")
}
func (*UnimplementedStatusServer) IndexUsageStatistics(ctx context.Context, req *IndexUsageStatisticsRequest) (*IndexUsageStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IndexUsageStatistics not implemented")
}
func (*UnimplementedStatusServer) ResetIndexUsageStats(ctx context.Context, req *ResetIndexUsageStatsRequest) (*ResetIndexUsageStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetIndexUsageStats not implemented")
}
func (*UnimplementedStatusServer) UserSQLRoles(ctx context.Context, req *UserSQLRolesRequest) (*UserSQLRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserSQLRoles not implemented")
}

func RegisterStatusServer(s *grpc.Server, srv StatusServer) {
	s.RegisterService(&_Status_serviceDesc, srv)
}

func _Status_Certificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Certificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Certificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Certificates(ctx, req.(*CertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Details_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Details(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Details",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Details(ctx, req.(*DetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Regions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Regions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Regions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Regions(ctx, req.(*RegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Nodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Nodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Nodes(ctx, req.(*NodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Node_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Node(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Node",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Node(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_NodesUI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).NodesUI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/NodesUI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).NodesUI(ctx, req.(*NodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_NodeUI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).NodeUI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/NodeUI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).NodeUI(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_RaftDebug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftDebugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).RaftDebug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/RaftDebug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).RaftDebug(ctx, req.(*RaftDebugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Ranges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Ranges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Ranges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Ranges(ctx, req.(*RangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Gossip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GossipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Gossip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Gossip",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Gossip(ctx, req.(*GossipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_EngineStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EngineStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).EngineStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/EngineStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).EngineStats(ctx, req.(*EngineStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Allocator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Allocator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Allocator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Allocator(ctx, req.(*AllocatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_AllocatorRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocatorRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).AllocatorRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/AllocatorRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).AllocatorRange(ctx, req.(*AllocatorRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ListSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ListSessions(ctx, req.(*ListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ListLocalSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ListLocalSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ListLocalSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ListLocalSessions(ctx, req.(*ListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CancelQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CancelQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CancelQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CancelQuery(ctx, req.(*CancelQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CancelLocalQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CancelLocalQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CancelLocalQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CancelLocalQuery(ctx, req.(*CancelQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ListContentionEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContentionEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ListContentionEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ListContentionEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ListContentionEvents(ctx, req.(*ListContentionEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ListLocalContentionEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContentionEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ListLocalContentionEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ListLocalContentionEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ListLocalContentionEvents(ctx, req.(*ListContentionEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ListDistSQLFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDistSQLFlowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ListDistSQLFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ListDistSQLFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ListDistSQLFlows(ctx, req.(*ListDistSQLFlowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ListLocalDistSQLFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDistSQLFlowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ListLocalDistSQLFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ListLocalDistSQLFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ListLocalDistSQLFlows(ctx, req.(*ListDistSQLFlowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CancelSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CancelSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CancelSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CancelSession(ctx, req.(*CancelSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CancelLocalSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CancelLocalSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CancelLocalSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CancelLocalSession(ctx, req.(*CancelSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_SpanStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).SpanStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/SpanStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).SpanStats(ctx, req.(*SpanStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Stacks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StacksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Stacks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Stacks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Stacks(ctx, req.(*StacksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Profile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Profile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Profile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Profile(ctx, req.(*ProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Metrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Metrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Metrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Metrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_GetFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).GetFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/GetFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).GetFiles(ctx, req.(*GetFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_LogFilesList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogFilesListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).LogFilesList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/LogFilesList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).LogFilesList(ctx, req.(*LogFilesListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_LogFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).LogFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/LogFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).LogFile(ctx, req.(*LogFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Logs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Logs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Logs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Logs(ctx, req.(*LogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ProblemRanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemRangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ProblemRanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ProblemRanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ProblemRanges(ctx, req.(*ProblemRangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_HotRanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HotRangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).HotRanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/HotRanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).HotRanges(ctx, req.(*HotRangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_HotRangesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HotRangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).HotRangesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/HotRangesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).HotRangesV2(ctx, req.(*HotRangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Range_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Range(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Range",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Range(ctx, req.(*RangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Diagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Diagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Diagnostics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Diagnostics(ctx, req.(*DiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Stores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Stores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Stores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Stores(ctx, req.(*StoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Statements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Statements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Statements",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Statements(ctx, req.(*StatementsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CombinedStatementStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CombinedStatementsStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CombinedStatementStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CombinedStatementStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CombinedStatementStats(ctx, req.(*CombinedStatementsStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CreateStatementDiagnosticsReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStatementDiagnosticsReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CreateStatementDiagnosticsReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CreateStatementDiagnosticsReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CreateStatementDiagnosticsReport(ctx, req.(*CreateStatementDiagnosticsReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_StatementDiagnosticsRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementDiagnosticsReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).StatementDiagnosticsRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/StatementDiagnosticsRequests",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).StatementDiagnosticsRequests(ctx, req.(*StatementDiagnosticsReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_StatementDiagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementDiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).StatementDiagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/StatementDiagnostics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).StatementDiagnostics(ctx, req.(*StatementDiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_JobRegistryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRegistryStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).JobRegistryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/JobRegistryStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).JobRegistryStatus(ctx, req.(*JobRegistryStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_JobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).JobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/JobStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).JobStatus(ctx, req.(*JobStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ResetSQLStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetSQLStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ResetSQLStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ResetSQLStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ResetSQLStats(ctx, req.(*ResetSQLStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_IndexUsageStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexUsageStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).IndexUsageStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/IndexUsageStatistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).IndexUsageStatistics(ctx, req.(*IndexUsageStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ResetIndexUsageStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetIndexUsageStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ResetIndexUsageStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ResetIndexUsageStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ResetIndexUsageStats(ctx, req.(*ResetIndexUsageStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_UserSQLRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSQLRolesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).UserSQLRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/UserSQLRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).UserSQLRoles(ctx, req.(*UserSQLRolesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Status_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.server.serverpb.Status",
	HandlerType: (*StatusServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Certificates",
			Handler:    _Status_Certificates_Handler,
		},
		{
			MethodName: "Details",
			Handler:    _Status_Details_Handler,
		},
		{
			MethodName: "Regions",
			Handler:    _Status_Regions_Handler,
		},
		{
			MethodName: "Nodes",
			Handler:    _Status_Nodes_Handler,
		},
		{
			MethodName: "Node",
			Handler:    _Status_Node_Handler,
		},
		{
			MethodName: "NodesUI",
			Handler:    _Status_NodesUI_Handler,
		},
		{
			MethodName: "NodeUI",
			Handler:    _Status_NodeUI_Handler,
		},
		{
			MethodName: "RaftDebug",
			Handler:    _Status_RaftDebug_Handler,
		},
		{
			MethodName: "Ranges",
			Handler:    _Status_Ranges_Handler,
		},
		{
			MethodName: "Gossip",
			Handler:    _Status_Gossip_Handler,
		},
		{
			MethodName: "EngineStats",
			Handler:    _Status_EngineStats_Handler,
		},
		{
			MethodName: "Allocator",
			Handler:    _Status_Allocator_Handler,
		},
		{
			MethodName: "AllocatorRange",
			Handler:    _Status_AllocatorRange_Handler,
		},
		{
			MethodName: "ListSessions",
			Handler:    _Status_ListSessions_Handler,
		},
		{
			MethodName: "ListLocalSessions",
			Handler:    _Status_ListLocalSessions_Handler,
		},
		{
			MethodName: "CancelQuery",
			Handler:    _Status_CancelQuery_Handler,
		},
		{
			MethodName: "CancelLocalQuery",
			Handler:    _Status_CancelLocalQuery_Handler,
		},
		{
			MethodName: "ListContentionEvents",
			Handler:    _Status_ListContentionEvents_Handler,
		},
		{
			MethodName: "ListLocalContentionEvents",
			Handler:    _Status_ListLocalContentionEvents_Handler,
		},
		{
			MethodName: "ListDistSQLFlows",
			Handler:    _Status_ListDistSQLFlows_Handler,
		},
		{
			MethodName: "ListLocalDistSQLFlows",
			Handler:    _Status_ListLocalDistSQLFlows_Handler,
		},
		{
			MethodName: "CancelSession",
			Handler:    _Status_CancelSession_Handler,
		},
		{
			MethodName: "CancelLocalSession",
			Handler:    _Status_CancelLocalSession_Handler,
		},
		{
			MethodName: "SpanStats",
			Handler:    _Status_SpanStats_Handler,
		},
		{
			MethodName: "Stacks",
			Handler:    _Status_Stacks_Handler,
		},
		{
			MethodName: "Profile",
			Handler:    _Status_Profile_Handler,
		},
		{
			MethodName: "Metrics",
			Handler:    _Status_Metrics_Handler,
		},
		{
			MethodName: "GetFiles",
			Handler:    _Status_GetFiles_Handler,
		},
		{
			MethodName: "LogFilesList",
			Handler:    _Status_LogFilesList_Handler,
		},
		{
			MethodName: "LogFile",
			Handler:    _Status_LogFile_Handler,
		},
		{
			MethodName: "Logs",
			Handler:    _Status_Logs_Handler,
		},
		{
			MethodName: "ProblemRanges",
			Handler:    _Status_ProblemRanges_Handler,
		},
		{
			MethodName: "HotRanges",
			Handler:    _Status_HotRanges_Handler,
		},
		{
			MethodName: "HotRangesV2",
			Handler:    _Status_HotRangesV2_Handler,
		},
		{
			MethodName: "Range",
			Handler:    _Status_Range_Handler,
		},
		{
			MethodName: "Diagnostics",
			Handler:    _Status_Diagnostics_Handler,
		},
		{
			MethodName: "Stores",
			Handler:    _Status_Stores_Handler,
		},
		{
			MethodName: "Statements",
			Handler:    _Status_Statements_Handler,
		},
		{
			MethodName: "CombinedStatementStats",
			Handler:    _Status_CombinedStatementStats_Handler,
		},
		{
			MethodName: "CreateStatementDiagnosticsReport",
			Handler:    _Status_CreateStatementDiagnosticsReport_Handler,
		},
		{
			MethodName: "StatementDiagnosticsRequests",
			Handler:    _Status_StatementDiagnosticsRequests_Handler,
		},
		{
			MethodName: "StatementDiagnostics",
			Handler:    _Status_StatementDiagnostics_Handler,
		},
		{
			MethodName: "JobRegistryStatus",
			Handler:    _Status_JobRegistryStatus_Handler,
		},
		{
			MethodName: "JobStatus",
			Handler:    _Status_JobStatus_Handler,
		},
		{
			MethodName: "ResetSQLStats",
			Handler:    _Status_ResetSQLStats_Handler,
		},
		{
			MethodName: "IndexUsageStatistics",
			Handler:    _Status_IndexUsageStatistics_Handler,
		},
		{
			MethodName: "ResetIndexUsageStats",
			Handler:    _Status_ResetIndexUsageStats_Handler,
		},
		{
			MethodName: "UserSQLRoles",
			Handler:    _Status_UserSQLRoles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server/serverpb/status.proto",
}

func (m *CertificatesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificatesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificatesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertificateDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CertificateDetails_Fields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateDetails_Fields) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateDetails_Fields) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtendedKeyUsage) > 0 {
		for iNdEx := len(m.ExtendedKeyUsage) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtendedKeyUsage[iNdEx])
			copy(dAtA[i:], m.ExtendedKeyUsage[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.ExtendedKeyUsage[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.KeyUsage) > 0 {
		for iNdEx := len(m.KeyUsage) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyUsage[iNdEx])
			copy(dAtA[i:], m.KeyUsage[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.KeyUsage[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SignatureAlgorithm) > 0 {
		i -= len(m.SignatureAlgorithm)
		copy(dAtA[i:], m.SignatureAlgorithm)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SignatureAlgorithm)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ValidUntil != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.ValidUntil))
		i--
		dAtA[i] = 0x20
	}
	if m.ValidFrom != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.ValidFrom))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertificatesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificatesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificatesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Certificates) > 0 {
		for iNdEx := len(m.Certificates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Certificates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KernelInfo) > 0 {
		i -= len(m.KernelInfo)
		copy(dAtA[i:], m.KernelInfo)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.KernelInfo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SystemInfo) > 0 {
		i -= len(m.SystemInfo)
		copy(dAtA[i:], m.SystemInfo)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SystemInfo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.SQLAddress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.SystemInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.BuildInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *NodesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LivenessByNodeID) > 0 {
		keysForLivenessByNodeID := make([]int32, 0, len(m.LivenessByNodeID))
		for k := range m.LivenessByNodeID {
			keysForLivenessByNodeID = append(keysForLivenessByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForLivenessByNodeID)
		for iNdEx := len(keysForLivenessByNodeID) - 1; iNdEx >= 0; iNdEx-- {
			v := m.LivenessByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForLivenessByNodeID[iNdEx])]
			baseI := i
			i = encodeVarintStatus(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintStatus(dAtA, i, uint64(keysForLivenessByNodeID[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodesResponseExternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesResponseExternal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodesResponseExternal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LivenessByNodeID) > 0 {
		keysForLivenessByNodeID := make([]int32, 0, len(m.LivenessByNodeID))
		for k := range m.LivenessByNodeID {
			keysForLivenessByNodeID = append(keysForLivenessByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForLivenessByNodeID)
		for iNdEx := len(keysForLivenessByNodeID) - 1; iNdEx >= 0; iNdEx-- {
			v := m.LivenessByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForLivenessByNodeID[iNdEx])]
			baseI := i
			i = encodeVarintStatus(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintStatus(dAtA, i, uint64(keysForLivenessByNodeID[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Locality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Locality) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Locality) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tiers) > 0 {
		for iNdEx := len(m.Tiers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tiers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Internal != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Internal))
		i--
		dAtA[i] = 0x20
	}
	if m.Patch != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Patch))
		i--
		dAtA[i] = 0x18
	}
	if m.Minor != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Minor))
		i--
		dAtA[i] = 0x10
	}
	if m.Major != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Major))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.SQLAddress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.LocalityAddress) > 0 {
		for iNdEx := len(m.LocalityAddress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalityAddress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.StartedAt != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StartedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.BuildTag) > 0 {
		i -= len(m.BuildTag)
		copy(dAtA[i:], m.BuildTag)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.BuildTag)))
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.ServerVersion.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Locality.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Attrs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Percentiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Percentiles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Percentiles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PMax != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PMax))))
		i--
		dAtA[i] = 0x31
	}
	if m.P90 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P90))))
		i--
		dAtA[i] = 0x29
	}
	if m.P75 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P75))))
		i--
		dAtA[i] = 0x21
	}
	if m.P50 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P50))))
		i--
		dAtA[i] = 0x19
	}
	if m.P25 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P25))))
		i--
		dAtA[i] = 0x11
	}
	if m.P10 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P10))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *StoreDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Capacity.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Attrs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.StoreID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		keysForMetrics := make([]string, 0, len(m.Metrics))
		for k := range m.Metrics {
			keysForMetrics = append(keysForMetrics, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForMetrics)
		for iNdEx := len(keysForMetrics) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Metrics[string(keysForMetrics[iNdEx])]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i -= len(keysForMetrics[iNdEx])
			copy(dAtA[i:], keysForMetrics[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(keysForMetrics[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumCpus != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NumCpus))
		i--
		dAtA[i] = 0x60
	}
	if m.TotalSystemMemory != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.TotalSystemMemory))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Activity) > 0 {
		keysForActivity := make([]int32, 0, len(m.Activity))
		for k := range m.Activity {
			keysForActivity = append(keysForActivity, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForActivity)
		for iNdEx := len(keysForActivity) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Activity[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForActivity[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintStatus(dAtA, i, uint64(keysForActivity[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Latencies) > 0 {
		keysForLatencies := make([]int32, 0, len(m.Latencies))
		for k := range m.Latencies {
			keysForLatencies = append(keysForLatencies, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForLatencies)
		for iNdEx := len(keysForLatencies) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Latencies[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForLatencies[iNdEx])]
			baseI := i
			i = encodeVarintStatus(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintStatus(dAtA, i, uint64(keysForLatencies[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Env) > 0 {
		for iNdEx := len(m.Env) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Env[iNdEx])
			copy(dAtA[i:], m.Env[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.Env[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.StoreStatuses) > 0 {
		for iNdEx := len(m.StoreStatuses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StoreStatuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Metrics) > 0 {
		keysForMetrics := make([]string, 0, len(m.Metrics))
		for k := range m.Metrics {
			keysForMetrics = append(keysForMetrics, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForMetrics)
		for iNdEx := len(keysForMetrics) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Metrics[string(keysForMetrics[iNdEx])]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i -= len(keysForMetrics[iNdEx])
			copy(dAtA[i:], keysForMetrics[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(keysForMetrics[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.StartedAt != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StartedAt))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.BuildInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NodeResponse_NetworkActivity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeResponse_NetworkActivity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeResponse_NetworkActivity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Latency != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Latency))
		i--
		dAtA[i] = 0x18
	}
	if m.Outgoing != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Outgoing))
		i--
		dAtA[i] = 0x10
	}
	if m.Incoming != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Incoming))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RegionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Regions) > 0 {
		keysForRegions := make([]string, 0, len(m.Regions))
		for k := range m.Regions {
			keysForRegions = append(keysForRegions, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForRegions)
		for iNdEx := len(keysForRegions) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Regions[string(keysForRegions[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintStatus(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForRegions[iNdEx])
			copy(dAtA[i:], keysForRegions[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(keysForRegions[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RegionsResponse_Region) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionsResponse_Region) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionsResponse_Region) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Zones) > 0 {
		for iNdEx := len(m.Zones) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Zones[iNdEx])
			copy(dAtA[i:], m.Zones[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.Zones[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeadTransferee != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.LeadTransferee))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Progress) > 0 {
		keysForProgress := make([]uint64, 0, len(m.Progress))
		for k := range m.Progress {
			keysForProgress = append(keysForProgress, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForProgress)
		for iNdEx := len(keysForProgress) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Progress[uint64(keysForProgress[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintStatus(dAtA, i, uint64(keysForProgress[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Applied != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Applied))
		i--
		dAtA[i] = 0x28
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x22
	}
	if m.Lead != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Lead))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.HardState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ReplicaID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftState_Progress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftState_Progress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftState_Progress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PendingSnapshot != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.PendingSnapshot))
		i--
		dAtA[i] = 0x28
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Next != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Next))
		i--
		dAtA[i] = 0x10
	}
	if m.Match != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Match))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeProblems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeProblems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeProblems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Overreplicated {
		i--
		if m.Overreplicated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RaftLogTooLarge {
		i--
		if m.RaftLogTooLarge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.QuiescentEqualsTicking {
		i--
		if m.QuiescentEqualsTicking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.NoLease {
		i--
		if m.NoLease {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Underreplicated {
		i--
		if m.Underreplicated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.NoRaftLeader {
		i--
		if m.NoRaftLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.LeaderNotLeaseHolder {
		i--
		if m.LeaderNotLeaseHolder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Unavailable {
		i--
		if m.Unavailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WritesPerSecond != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WritesPerSecond))))
		i--
		dAtA[i] = 0x11
	}
	if m.QueriesPerSecond != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QueriesPerSecond))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *PrettySpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrettySpan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrettySpan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TopKLocksByWaitQueueWaiters) > 0 {
		for iNdEx := len(m.TopKLocksByWaitQueueWaiters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TopKLocksByWaitQueueWaiters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.LockWaitQueueWaiters != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.LockWaitQueueWaiters))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.LocksWithWaitQueues != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.LocksWithWaitQueues))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Locks != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Locks))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.WriteLatches != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.WriteLatches))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.ReadLatches != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.ReadLatches))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Ticking {
		i--
		if m.Ticking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Quiescent {
		i--
		if m.Quiescent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	{
		size, err := m.LeaseStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.Problems.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.LeaseHistory) > 0 {
		for iNdEx := len(m.LeaseHistory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeaseHistory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SourceStoreID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.SourceStoreID))
		i--
		dAtA[i] = 0x30
	}
	if m.SourceNodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.SourceNodeID))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.RaftState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeInfo_LockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeInfo_LockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeInfo_LockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WaitingWriters != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.WaitingWriters))
		i--
		dAtA[i] = 0x30
	}
	if m.WaitingReaders != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.WaitingReaders))
		i--
		dAtA[i] = 0x28
	}
	if m.Waiters != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Waiters))
		i--
		dAtA[i] = 0x20
	}
	if m.Held {
		i--
		if m.Held {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrettyKey) > 0 {
		i -= len(m.PrettyKey)
		copy(dAtA[i:], m.PrettyKey)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.PrettyKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeIDs) > 0 {
		dAtA27 := make([]byte, len(m.RangeIDs)*10)
		var j26 int
		for _, num1 := range m.RangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintStatus(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GossipRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GossipRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EngineStatsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineStatsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EngineStatsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EngineType != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.EngineType))
		i--
		dAtA[i] = 0x18
	}
	if m.TickersAndHistograms != nil {
		{
			size, err := m.TickersAndHistograms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StoreID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EngineStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EngineStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EngineStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EngineStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for iNdEx := len(m.Stats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	n29, err29 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Time):])
	if err29 != nil {
		return 0, err29
	}
	i -= n29
	i = encodeVarintStatus(dAtA, i, uint64(n29))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AllocatorDryRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorDryRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocatorDryRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RangeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AllocatorRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocatorRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AllocatorRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocatorRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DryRun != nil {
		{
			size, err := m.DryRun.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AllocatorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocatorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeIDs) > 0 {
		dAtA32 := make([]byte, len(m.RangeIDs)*10)
		var j31 int
		for _, num1 := range m.RangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintStatus(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllocatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DryRuns) > 0 {
		for iNdEx := len(m.DryRuns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DryRuns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JSONResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JSONResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JSONResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		for iNdEx := len(m.Details) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Details[iNdEx])
			copy(dAtA[i:], m.Details[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.Details[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Redact {
		i--
		if m.Redact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Pattern) > 0 {
		i -= len(m.Pattern)
		copy(dAtA[i:], m.Pattern)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Pattern)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Max) > 0 {
		i -= len(m.Max)
		copy(dAtA[i:], m.Max)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Max)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogEntriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEntriesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntriesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LogFilesListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFilesListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogFilesListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogFilesListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFilesListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogFilesListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LogFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Redact {
		i--
		if m.Redact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StacksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StacksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StacksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Contents) > 0 {
		i -= len(m.Contents)
		copy(dAtA[i:], m.Contents)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Contents)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FileSize != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFilesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFilesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFilesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Patterns) > 0 {
		for iNdEx := len(m.Patterns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Patterns[iNdEx])
			copy(dAtA[i:], m.Patterns[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.Patterns[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Type != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.ListOnly {
		i--
		if m.ListOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFilesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFilesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFilesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProfileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Labels {
		i--
		if m.Labels {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Seconds != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x30
	}
	if m.Type != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftRangeNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRangeNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftRangeNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftRangeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRangeError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftRangeError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftRangeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRangeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftRangeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RangeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftDebugRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftDebugRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftDebugRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeIDs) > 0 {
		dAtA35 := make([]byte, len(m.RangeIDs)*10)
		var j34 int
		for _, num1 := range m.RangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA35[:j34])
		i = encodeVarintStatus(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftDebugResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftDebugResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftDebugResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Ranges) > 0 {
		keysForRanges := make([]int64, 0, len(m.Ranges))
		for k := range m.Ranges {
			keysForRanges = append(keysForRanges, int64(k))
		}
		github_com_gogo_protobuf_sortkeys.Int64s(keysForRanges)
		for iNdEx := len(keysForRanges) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Ranges[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(keysForRanges[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintStatus(dAtA, i, uint64(keysForRanges[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TxnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Priority) > 0 {
		i -= len(m.Priority)
		copy(dAtA[i:], m.Priority)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Priority)))
		i--
		dAtA[i] = 0x6a
	}
	if m.IsHistorical {
		i--
		if m.IsHistorical {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.MaxAllocBytes != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.MaxAllocBytes))
		i--
		dAtA[i] = 0x50
	}
	if m.AllocBytes != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.AllocBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.Implicit {
		i--
		if m.Implicit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	n37, err37 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Deadline, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Deadline):])
	if err37 != nil {
		return 0, err37
	}
	i -= n37
	i = encodeVarintStatus(dAtA, i, uint64(n37))
	i--
	dAtA[i] = 0x3a
	if m.NumAutoRetries != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NumAutoRetries))
		i--
		dAtA[i] = 0x30
	}
	if m.NumRetries != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NumRetries))
		i--
		dAtA[i] = 0x28
	}
	if m.NumStatementsExecuted != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NumStatementsExecuted))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TxnDescription) > 0 {
		i -= len(m.TxnDescription)
		copy(dAtA[i:], m.TxnDescription)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.TxnDescription)))
		i--
		dAtA[i] = 0x1a
	}
	n38, err38 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Start):])
	if err38 != nil {
		return 0, err38
	}
	i -= n38
	i = encodeVarintStatus(dAtA, i, uint64(n38))
	i--
	dAtA[i] = 0x12
	{
		size := m.ID.Size()
		i -= size
		if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ActiveQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SqlSummary) > 0 {
		i -= len(m.SqlSummary)
		copy(dAtA[i:], m.SqlSummary)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SqlSummary)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SqlNoConstants) > 0 {
		i -= len(m.SqlNoConstants)
		copy(dAtA[i:], m.SqlNoConstants)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SqlNoConstants)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.TxnID.Size()
		i -= size
		if _, err := m.TxnID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.Progress != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Progress))))
		i--
		dAtA[i] = 0x35
	}
	if m.Phase != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x28
	}
	if m.IsDistributed {
		i--
		if m.IsDistributed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	n39, err39 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Start):])
	if err39 != nil {
		return 0, err39
	}
	i -= n39
	i = encodeVarintStatus(dAtA, i, uint64(n39))
	i--
	dAtA[i] = 0x1a
	if len(m.Sql) > 0 {
		i -= len(m.Sql)
		copy(dAtA[i:], m.Sql)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Sql)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListSessionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSessionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSessionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LastActiveQueryNoConstants) > 0 {
		i -= len(m.LastActiveQueryNoConstants)
		copy(dAtA[i:], m.LastActiveQueryNoConstants)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.LastActiveQueryNoConstants)))
		i--
		dAtA[i] = 0x6a
	}
	if m.ActiveTxn != nil {
		{
			size, err := m.ActiveTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MaxAllocBytes != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.MaxAllocBytes))
		i--
		dAtA[i] = 0x58
	}
	if m.AllocBytes != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.AllocBytes))
		i--
		dAtA[i] = 0x50
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.LastActiveQuery) > 0 {
		i -= len(m.LastActiveQuery)
		copy(dAtA[i:], m.LastActiveQuery)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.LastActiveQuery)))
		i--
		dAtA[i] = 0x42
	}
	n41, err41 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Start):])
	if err41 != nil {
		return 0, err41
	}
	i -= n41
	i = encodeVarintStatus(dAtA, i, uint64(n41))
	i--
	dAtA[i] = 0x32
	if len(m.ActiveQueries) > 0 {
		for iNdEx := len(m.ActiveQueries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActiveQueries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ApplicationName) > 0 {
		i -= len(m.ApplicationName)
		copy(dAtA[i:], m.ApplicationName)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ApplicationName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClientAddress) > 0 {
		i -= len(m.ClientAddress)
		copy(dAtA[i:], m.ClientAddress)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ClientAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListSessionsError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSessionsError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSessionsError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListSessionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSessionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSessionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CancelQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QueryID) > 0 {
		i -= len(m.QueryID)
		copy(dAtA[i:], m.QueryID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.QueryID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Canceled {
		i--
		if m.Canceled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Canceled {
		i--
		if m.Canceled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListContentionEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListContentionEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListContentionEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListActivityError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListActivityError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListActivityError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListContentionEventsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListContentionEventsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListContentionEventsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListDistSQLFlowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDistSQLFlowsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDistSQLFlowsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DistSQLRemoteFlows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistSQLRemoteFlows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistSQLRemoteFlows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for iNdEx := len(m.Infos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Infos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.FlowID.Size()
		i -= size
		if _, err := m.FlowID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DistSQLRemoteFlows_Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistSQLRemoteFlows_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistSQLRemoteFlows_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stmt) > 0 {
		i -= len(m.Stmt)
		copy(dAtA[i:], m.Stmt)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Stmt)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	n43, err43 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err43 != nil {
		return 0, err43
	}
	i -= n43
	i = encodeVarintStatus(dAtA, i, uint64(n43))
	i--
	dAtA[i] = 0x12
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListDistSQLFlowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDistSQLFlowsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDistSQLFlowsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Flows) > 0 {
		for iNdEx := len(m.Flows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApproximateDiskBytes != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.ApproximateDiskBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.RangeCount != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeCount))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.TotalStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProblemRangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProblemRangesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProblemRangesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProblemRangesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProblemRangesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProblemRangesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProblemsByNodeID) > 0 {
		keysForProblemsByNodeID := make([]int32, 0, len(m.ProblemsByNodeID))
		for k := range m.ProblemsByNodeID {
			keysForProblemsByNodeID = append(keysForProblemsByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForProblemsByNodeID)
		for iNdEx := len(keysForProblemsByNodeID) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ProblemsByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForProblemsByNodeID[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintStatus(dAtA, i, uint64(keysForProblemsByNodeID[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x40
	}
	return len(dAtA) - i, nil
}

func (m *ProblemRangesResponse_NodeProblems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProblemRangesResponse_NodeProblems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProblemRangesResponse_NodeProblems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OverreplicatedRangeIDs) > 0 {
		dAtA47 := make([]byte, len(m.OverreplicatedRangeIDs)*10)
		var j46 int
		for _, num1 := range m.OverreplicatedRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintStatus(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RaftLogTooLargeRangeIDs) > 0 {
		dAtA49 := make([]byte, len(m.RaftLogTooLargeRangeIDs)*10)
		var j48 int
		for _, num1 := range m.RaftLogTooLargeRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		i -= j48
		copy(dAtA[i:], dAtA49[:j48])
		i = encodeVarintStatus(dAtA, i, uint64(j48))
		i--
		dAtA[i] = 0x42
	}
	if len(m.QuiescentEqualsTickingRangeIDs) > 0 {
		dAtA51 := make([]byte, len(m.QuiescentEqualsTickingRangeIDs)*10)
		var j50 int
		for _, num1 := range m.QuiescentEqualsTickingRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA51[j50] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j50++
			}
			dAtA51[j50] = uint8(num)
			j50++
		}
		i -= j50
		copy(dAtA[i:], dAtA51[:j50])
		i = encodeVarintStatus(dAtA, i, uint64(j50))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UnderreplicatedRangeIDs) > 0 {
		dAtA53 := make([]byte, len(m.UnderreplicatedRangeIDs)*10)
		var j52 int
		for _, num1 := range m.UnderreplicatedRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintStatus(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NoLeaseRangeIDs) > 0 {
		dAtA55 := make([]byte, len(m.NoLeaseRangeIDs)*10)
		var j54 int
		for _, num1 := range m.NoLeaseRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		i -= j54
		copy(dAtA[i:], dAtA55[:j54])
		i = encodeVarintStatus(dAtA, i, uint64(j54))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NoRaftLeaderRangeIDs) > 0 {
		dAtA57 := make([]byte, len(m.NoRaftLeaderRangeIDs)*10)
		var j56 int
		for _, num1 := range m.NoRaftLeaderRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA57[j56] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j56++
			}
			dAtA57[j56] = uint8(num)
			j56++
		}
		i -= j56
		copy(dAtA[i:], dAtA57[:j56])
		i = encodeVarintStatus(dAtA, i, uint64(j56))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RaftLeaderNotLeaseHolderRangeIDs) > 0 {
		dAtA59 := make([]byte, len(m.RaftLeaderNotLeaseHolderRangeIDs)*10)
		var j58 int
		for _, num1 := range m.RaftLeaderNotLeaseHolderRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		i -= j58
		copy(dAtA[i:], dAtA59[:j58])
		i = encodeVarintStatus(dAtA, i, uint64(j58))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UnavailableRangeIDs) > 0 {
		dAtA61 := make([]byte, len(m.UnavailableRangeIDs)*10)
		var j60 int
		for _, num1 := range m.UnavailableRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		i -= j60
		copy(dAtA[i:], dAtA61[:j60])
		i = encodeVarintStatus(dAtA, i, uint64(j60))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HotRangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotRangesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PageToken) > 0 {
		i -= len(m.PageToken)
		copy(dAtA[i:], m.PageToken)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.PageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HotRangesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotRangesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HotRangesByNodeID) > 0 {
		keysForHotRangesByNodeID := make([]int32, 0, len(m.HotRangesByNodeID))
		for k := range m.HotRangesByNodeID {
			keysForHotRangesByNodeID = append(keysForHotRangesByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForHotRangesByNodeID)
		for iNdEx := len(keysForHotRangesByNodeID) - 1; iNdEx >= 0; iNdEx-- {
			v := m.HotRangesByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForHotRangesByNodeID[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintStatus(dAtA, i, uint64(keysForHotRangesByNodeID[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HotRangesResponse_HotRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponse_HotRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotRangesResponse_HotRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeaseholderNodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.LeaseholderNodeID))
		i--
		dAtA[i] = 0x18
	}
	if m.QueriesPerSecond != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QueriesPerSecond))))
		i--
		dAtA[i] = 0x11
	}
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HotRangesResponse_StoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponse_StoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotRangesResponse_StoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HotRanges) > 0 {
		for iNdEx := len(m.HotRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HotRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.StoreID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HotRangesResponse_NodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponse_NodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotRangesResponse_NodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stores) > 0 {
		for iNdEx := len(m.Stores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HotRangesResponseV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponseV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotRangesResponseV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorsByNodeID) > 0 {
		keysForErrorsByNodeID := make([]int32, 0, len(m.ErrorsByNodeID))
		for k := range m.ErrorsByNodeID {
			keysForErrorsByNodeID = append(keysForErrorsByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForErrorsByNodeID)
		for iNdEx := len(keysForErrorsByNodeID) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ErrorsByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForErrorsByNodeID[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStatus(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintStatus(dAtA, i, uint64(keysForErrorsByNodeID[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HotRangesResponseV2_HotRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponseV2_HotRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotRangesResponseV2_HotRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x50
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.LeaseholderNodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.LeaseholderNodeID))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ReplicaNodeIds) > 0 {
		dAtA65 := make([]byte, len(m.ReplicaNodeIds)*10)
		var j64 int
		for _, num1 := range m.ReplicaNodeIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA65[j64] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j64++
			}
			dAtA65[j64] = uint8(num)
			j64++
		}
		i -= j64
		copy(dAtA[i:], dAtA65[:j64])
		i = encodeVarintStatus(dAtA, i, uint64(j64))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x22
	}
	if m.QPS != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QPS))))
		i--
		dAtA[i] = 0x19
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponsesByNodeID) > 0 {
		keysForResponsesByNodeID := make([]int32, 0, len(m.ResponsesByNodeID))
		for k := range m.ResponsesByNodeID {
			keysForResponsesByNodeID = append(keysForResponsesByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForResponsesByNodeID)
		for iNdEx := len(keysForResponsesByNodeID) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ResponsesByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(keysForResponsesByNodeID[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintStatus(dAtA, i, uint64(keysForResponsesByNodeID[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.RangeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeResponse_NodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeResponse_NodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeResponse_NodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for iNdEx := len(m.Infos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Infos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Response {
		i--
		if m.Response {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiagnosticsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiagnosticsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiagnosticsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoresRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoresRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoresRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActiveKeyBytes != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.ActiveKeyBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.ActiveKeyFiles != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.ActiveKeyFiles))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalBytes != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.TotalBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalFiles != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.TotalFiles))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EncryptionStatus) > 0 {
		i -= len(m.EncryptionStatus)
		copy(dAtA[i:], m.EncryptionStatus)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.EncryptionStatus)))
		i--
		dAtA[i] = 0x12
	}
	if m.StoreID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StoresResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoresResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoresResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stores) > 0 {
		for iNdEx := len(m.Stores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatementsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FetchMode != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.FetchMode))
		i--
		dAtA[i] = 0x28
	}
	if m.End != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x20
	}
	if m.Start != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x18
	}
	if m.Combined {
		i--
		if m.Combined {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatementsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for iNdEx := len(m.Transactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.InternalAppNamePrefix) > 0 {
		i -= len(m.InternalAppNamePrefix)
		copy(dAtA[i:], m.InternalAppNamePrefix)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.InternalAppNamePrefix)))
		i--
		dAtA[i] = 0x22
	}
	n67, err67 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastReset, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastReset):])
	if err67 != nil {
		return 0, err67
	}
	i -= n67
	i = encodeVarintStatus(dAtA, i, uint64(n67))
	i--
	dAtA[i] = 0x1a
	if len(m.Statements) > 0 {
		for iNdEx := len(m.Statements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Statements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n68, err68 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.AggregationInterval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.AggregationInterval):])
	if err68 != nil {
		return 0, err68
	}
	i -= n68
	i = encodeVarintStatus(dAtA, i, uint64(n68))
	i--
	dAtA[i] = 0x22
	n69, err69 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.AggregatedTs, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.AggregatedTs):])
	if err69 != nil {
		return 0, err69
	}
	i -= n69
	i = encodeVarintStatus(dAtA, i, uint64(n69))
	i--
	dAtA[i] = 0x1a
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.KeyData.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StatementsResponse_CollectedStatementStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsResponse_CollectedStatementStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementsResponse_CollectedStatementStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.StatsData.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CombinedStatementsStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombinedStatementsStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombinedStatementsStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatementDiagnosticsReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementDiagnosticsReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n74, err74 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RequestedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RequestedAt):])
	if err74 != nil {
		return 0, err74
	}
	i -= n74
	i = encodeVarintStatus(dAtA, i, uint64(n74))
	i--
	dAtA[i] = 0x2a
	if m.StatementDiagnosticsId != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StatementDiagnosticsId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.StatementFingerprint) > 0 {
		i -= len(m.StatementFingerprint)
		copy(dAtA[i:], m.StatementFingerprint)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StatementFingerprint)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateStatementDiagnosticsReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatementDiagnosticsReportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateStatementDiagnosticsReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatementFingerprint) > 0 {
		i -= len(m.StatementFingerprint)
		copy(dAtA[i:], m.StatementFingerprint)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StatementFingerprint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateStatementDiagnosticsReportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatementDiagnosticsReportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateStatementDiagnosticsReportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Report != nil {
		{
			size, err := m.Report.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatementDiagnosticsReportsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsReportsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementDiagnosticsReportsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *StatementDiagnosticsReportsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsReportsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementDiagnosticsReportsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reports) > 0 {
		for iNdEx := len(m.Reports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatementDiagnostics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnostics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementDiagnostics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n76, err76 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CollectedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CollectedAt):])
	if err76 != nil {
		return 0, err76
	}
	i -= n76
	i = encodeVarintStatus(dAtA, i, uint64(n76))
	i--
	dAtA[i] = 0x1a
	if len(m.StatementFingerprint) > 0 {
		i -= len(m.StatementFingerprint)
		copy(dAtA[i:], m.StatementFingerprint)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StatementFingerprint)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatementDiagnosticsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementDiagnosticsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatementDiagnosticsId != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.StatementDiagnosticsId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatementDiagnosticsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementDiagnosticsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Diagnostics != nil {
		{
			size, err := m.Diagnostics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *JobRegistryStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRegistryStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRegistryStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRegistryStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRegistryStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRegistryStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RunningJobs) > 0 {
		for iNdEx := len(m.RunningJobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RunningJobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NodeID != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobRegistryStatusResponse_Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRegistryStatusResponse_Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRegistryStatusResponse_Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JobId != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResetSQLStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetSQLStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetSQLStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetPersistedStats {
		i--
		if m.ResetPersistedStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResetSQLStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetSQLStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetSQLStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *IndexUsageStatisticsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexUsageStatisticsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexUsageStatisticsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexUsageStatisticsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexUsageStatisticsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexUsageStatisticsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n79, err79 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastReset, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastReset):])
	if err79 != nil {
		return 0, err79
	}
	i -= n79
	i = encodeVarintStatus(dAtA, i, uint64(n79))
	i--
	dAtA[i] = 0x1a
	if len(m.Statistics) > 0 {
		for iNdEx := len(m.Statistics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Statistics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResetIndexUsageStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetIndexUsageStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetIndexUsageStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResetIndexUsageStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetIndexUsageStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetIndexUsageStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UserSQLRolesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSQLRolesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSQLRolesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UserSQLRolesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSQLRolesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSQLRolesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintStatus(dAtA []byte, offset int, v uint64) int {
	offset -= sovStatus(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CertificatesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CertificateDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovStatus(uint64(m.Type))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *CertificateDetails_Fields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.ValidFrom != 0 {
		n += 1 + sovStatus(uint64(m.ValidFrom))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovStatus(uint64(m.ValidUntil))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = len(m.SignatureAlgorithm)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.KeyUsage) > 0 {
		for _, s := range m.KeyUsage {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.ExtendedKeyUsage) > 0 {
		for _, s := range m.ExtendedKeyUsage {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *CertificatesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Certificates) > 0 {
		for _, e := range m.Certificates {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *DetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *SystemInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SystemInfo)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.KernelInfo)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *DetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = m.Address.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.BuildInfo.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.SystemInfo.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.SQLAddress.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *NodesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NodesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.LivenessByNodeID) > 0 {
		for k, v := range m.LivenessByNodeID {
			_ = k
			_ = v
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NodesResponseExternal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.LivenessByNodeID) > 0 {
		for k, v := range m.LivenessByNodeID {
			_ = k
			_ = v
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Locality) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tiers) > 0 {
		for _, e := range m.Tiers {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *Tier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovStatus(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovStatus(uint64(m.Minor))
	}
	if m.Patch != 0 {
		n += 1 + sovStatus(uint64(m.Patch))
	}
	if m.Internal != 0 {
		n += 1 + sovStatus(uint64(m.Internal))
	}
	return n
}

func (m *NodeDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = m.Address.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Attrs.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Locality.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.ServerVersion.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.BuildTag)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.StartedAt != 0 {
		n += 1 + sovStatus(uint64(m.StartedAt))
	}
	if len(m.LocalityAddress) > 0 {
		for _, e := range m.LocalityAddress {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = m.SQLAddress.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *Percentiles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P10 != 0 {
		n += 9
	}
	if m.P25 != 0 {
		n += 9
	}
	if m.P50 != 0 {
		n += 9
	}
	if m.P75 != 0 {
		n += 9
	}
	if m.P90 != 0 {
		n += 9
	}
	if m.PMax != 0 {
		n += 9
	}
	return n
}

func (m *StoreDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	l = m.Attrs.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Node.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Capacity.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *StoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovStatus(uint64(l))
	if len(m.Metrics) > 0 {
		for k, v := range m.Metrics {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.BuildInfo.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.StartedAt != 0 {
		n += 1 + sovStatus(uint64(m.StartedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovStatus(uint64(m.UpdatedAt))
	}
	if len(m.Metrics) > 0 {
		for k, v := range m.Metrics {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if len(m.StoreStatuses) > 0 {
		for _, e := range m.StoreStatuses {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Latencies) > 0 {
		for k, v := range m.Latencies {
			_ = k
			_ = v
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if len(m.Activity) > 0 {
		for k, v := range m.Activity {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.TotalSystemMemory != 0 {
		n += 1 + sovStatus(uint64(m.TotalSystemMemory))
	}
	if m.NumCpus != 0 {
		n += 1 + sovStatus(uint64(m.NumCpus))
	}
	return n
}

func (m *NodeResponse_NetworkActivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Incoming != 0 {
		n += 1 + sovStatus(uint64(m.Incoming))
	}
	if m.Outgoing != 0 {
		n += 1 + sovStatus(uint64(m.Outgoing))
	}
	if m.Latency != 0 {
		n += 1 + sovStatus(uint64(m.Latency))
	}
	return n
}

func (m *RegionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RegionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Regions) > 0 {
		for k, v := range m.Regions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStatus(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RegionsResponse_Region) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Zones) > 0 {
		for _, s := range m.Zones {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *NodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *RaftState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaID != 0 {
		n += 1 + sovStatus(uint64(m.ReplicaID))
	}
	l = m.HardState.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.Lead != 0 {
		n += 1 + sovStatus(uint64(m.Lead))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Applied != 0 {
		n += 1 + sovStatus(uint64(m.Applied))
	}
	if len(m.Progress) > 0 {
		for k, v := range m.Progress {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.LeadTransferee != 0 {
		n += 1 + sovStatus(uint64(m.LeadTransferee))
	}
	return n
}

func (m *RaftState_Progress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != 0 {
		n += 1 + sovStatus(uint64(m.Match))
	}
	if m.Next != 0 {
		n += 1 + sovStatus(uint64(m.Next))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	if m.PendingSnapshot != 0 {
		n += 1 + sovStatus(uint64(m.PendingSnapshot))
	}
	return n
}

func (m *RangeProblems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unavailable {
		n += 2
	}
	if m.LeaderNotLeaseHolder {
		n += 2
	}
	if m.NoRaftLeader {
		n += 2
	}
	if m.Underreplicated {
		n += 2
	}
	if m.NoLease {
		n += 2
	}
	if m.QuiescentEqualsTicking {
		n += 2
	}
	if m.RaftLogTooLarge {
		n += 2
	}
	if m.Overreplicated {
		n += 2
	}
	return n
}

func (m *RangeStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueriesPerSecond != 0 {
		n += 9
	}
	if m.WritesPerSecond != 0 {
		n += 9
	}
	return n
}

func (m *PrettySpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *RangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.RaftState.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.State.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.SourceNodeID != 0 {
		n += 1 + sovStatus(uint64(m.SourceNodeID))
	}
	if m.SourceStoreID != 0 {
		n += 1 + sovStatus(uint64(m.SourceStoreID))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.LeaseHistory) > 0 {
		for _, e := range m.LeaseHistory {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = m.Problems.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Stats.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.LeaseStatus.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.Quiescent {
		n += 2
	}
	if m.Ticking {
		n += 2
	}
	if m.ReadLatches != 0 {
		n += 2 + sovStatus(uint64(m.ReadLatches))
	}
	if m.WriteLatches != 0 {
		n += 2 + sovStatus(uint64(m.WriteLatches))
	}
	if m.Locks != 0 {
		n += 2 + sovStatus(uint64(m.Locks))
	}
	if m.LocksWithWaitQueues != 0 {
		n += 2 + sovStatus(uint64(m.LocksWithWaitQueues))
	}
	if m.LockWaitQueueWaiters != 0 {
		n += 2 + sovStatus(uint64(m.LockWaitQueueWaiters))
	}
	if len(m.TopKLocksByWaitQueueWaiters) > 0 {
		for _, e := range m.TopKLocksByWaitQueueWaiters {
			l = e.Size()
			n += 2 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *RangeInfo_LockInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrettyKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Held {
		n += 2
	}
	if m.Waiters != 0 {
		n += 1 + sovStatus(uint64(m.Waiters))
	}
	if m.WaitingReaders != 0 {
		n += 1 + sovStatus(uint64(m.WaitingReaders))
	}
	if m.WaitingWriters != 0 {
		n += 1 + sovStatus(uint64(m.WaitingWriters))
	}
	return n
}

func (m *RangesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.RangeIDs) > 0 {
		l = 0
		for _, e := range m.RangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	return n
}

func (m *RangesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *GossipRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *EngineStatsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	if m.TickersAndHistograms != nil {
		l = m.TickersAndHistograms.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.EngineType != 0 {
		n += 1 + sovStatus(uint64(m.EngineType))
	}
	return n
}

func (m *EngineStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *EngineStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *TraceEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *AllocatorDryRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovStatus(uint64(m.RangeID))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *AllocatorRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovStatus(uint64(m.RangeId))
	}
	return n
}

func (m *AllocatorRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if m.DryRun != nil {
		l = m.DryRun.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *AllocatorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.RangeIDs) > 0 {
		l = 0
		for _, e := range m.RangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	return n
}

func (m *AllocatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DryRuns) > 0 {
		for _, e := range m.DryRuns {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *JSONResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ResponseError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovStatus(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Details) > 0 {
		for _, s := range m.Details {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *LogsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Max)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Redact {
		n += 2
	}
	return n
}

func (m *LogEntriesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *LogFilesListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *LogFilesListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *LogFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Redact {
		n += 2
	}
	return n
}

func (m *StacksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovStatus(uint64(m.Type))
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovStatus(uint64(m.FileSize))
	}
	l = len(m.Contents)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *GetFilesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.ListOnly {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovStatus(uint64(m.Type))
	}
	if len(m.Patterns) > 0 {
		for _, s := range m.Patterns {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *GetFilesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *ProfileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovStatus(uint64(m.Type))
	}
	if m.Seconds != 0 {
		n += 1 + sovStatus(uint64(m.Seconds))
	}
	if m.Labels {
		n += 2
	}
	return n
}

func (m *MetricsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *RaftRangeNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = m.Range.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *RaftRangeError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *RaftRangeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovStatus(uint64(m.RangeID))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *RaftDebugRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RangeIDs) > 0 {
		l = 0
		for _, e := range m.RangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	return n
}

func (m *RaftDebugResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for k, v := range m.Ranges {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *TxnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.TxnDescription)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.NumStatementsExecuted != 0 {
		n += 1 + sovStatus(uint64(m.NumStatementsExecuted))
	}
	if m.NumRetries != 0 {
		n += 1 + sovStatus(uint64(m.NumRetries))
	}
	if m.NumAutoRetries != 0 {
		n += 1 + sovStatus(uint64(m.NumAutoRetries))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Deadline)
	n += 1 + l + sovStatus(uint64(l))
	if m.Implicit {
		n += 2
	}
	if m.AllocBytes != 0 {
		n += 1 + sovStatus(uint64(m.AllocBytes))
	}
	if m.MaxAllocBytes != 0 {
		n += 1 + sovStatus(uint64(m.MaxAllocBytes))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.IsHistorical {
		n += 2
	}
	l = len(m.Priority)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ActiveQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovStatus(uint64(l))
	if m.IsDistributed {
		n += 2
	}
	if m.Phase != 0 {
		n += 1 + sovStatus(uint64(m.Phase))
	}
	if m.Progress != 0 {
		n += 5
	}
	l = m.TxnID.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.SqlNoConstants)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.SqlSummary)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListSessionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.ClientAddress)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.ApplicationName)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.ActiveQueries) > 0 {
		for _, e := range m.ActiveQueries {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.LastActiveQuery)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.AllocBytes != 0 {
		n += 1 + sovStatus(uint64(m.AllocBytes))
	}
	if m.MaxAllocBytes != 0 {
		n += 1 + sovStatus(uint64(m.MaxAllocBytes))
	}
	if m.ActiveTxn != nil {
		l = m.ActiveTxn.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.LastActiveQueryNoConstants)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListSessionsError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListSessionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *CancelQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.QueryID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CancelQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Canceled {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CancelSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CancelSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Canceled {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListContentionEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListActivityError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListContentionEventsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Events.Size()
	n += 1 + l + sovStatus(uint64(l))
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *ListDistSQLFlowsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DistSQLRemoteFlows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FlowID.Size()
	n += 1 + l + sovStatus(uint64(l))
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *DistSQLRemoteFlows_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovStatus(uint64(l))
	if m.Status != 0 {
		n += 1 + sovStatus(uint64(m.Status))
	}
	l = len(m.Stmt)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListDistSQLFlowsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Flows) > 0 {
		for _, e := range m.Flows {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *SpanStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *SpanStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalStats.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.RangeCount != 0 {
		n += 1 + sovStatus(uint64(m.RangeCount))
	}
	if m.ApproximateDiskBytes != 0 {
		n += 1 + sovStatus(uint64(m.ApproximateDiskBytes))
	}
	return n
}

func (m *ProblemRangesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ProblemRangesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if len(m.ProblemsByNodeID) > 0 {
		for k, v := range m.ProblemsByNodeID {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ProblemRangesResponse_NodeProblems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.UnavailableRangeIDs) > 0 {
		l = 0
		for _, e := range m.UnavailableRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.RaftLeaderNotLeaseHolderRangeIDs) > 0 {
		l = 0
		for _, e := range m.RaftLeaderNotLeaseHolderRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.NoRaftLeaderRangeIDs) > 0 {
		l = 0
		for _, e := range m.NoRaftLeaderRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.NoLeaseRangeIDs) > 0 {
		l = 0
		for _, e := range m.NoLeaseRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.UnderreplicatedRangeIDs) > 0 {
		l = 0
		for _, e := range m.UnderreplicatedRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.QuiescentEqualsTickingRangeIDs) > 0 {
		l = 0
		for _, e := range m.QuiescentEqualsTickingRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.RaftLogTooLargeRangeIDs) > 0 {
		l = 0
		for _, e := range m.RaftLogTooLargeRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.OverreplicatedRangeIDs) > 0 {
		l = 0
		for _, e := range m.OverreplicatedRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	return n
}

func (m *HotRangesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovStatus(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *HotRangesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if len(m.HotRangesByNodeID) > 0 {
		for k, v := range m.HotRangesByNodeID {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HotRangesResponse_HotRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.QueriesPerSecond != 0 {
		n += 9
	}
	if m.LeaseholderNodeID != 0 {
		n += 1 + sovStatus(uint64(m.LeaseholderNodeID))
	}
	return n
}

func (m *HotRangesResponse_StoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	if len(m.HotRanges) > 0 {
		for _, e := range m.HotRanges {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *HotRangesResponse_NodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Stores) > 0 {
		for _, e := range m.Stores {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *HotRangesResponseV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.ErrorsByNodeID) > 0 {
		for k, v := range m.ErrorsByNodeID {
			_ = k
			_ = v
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + len(v) + sovStatus(uint64(len(v)))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *HotRangesResponseV2_HotRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovStatus(uint64(m.RangeID))
	}
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if m.QPS != 0 {
		n += 9
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.ReplicaNodeIds) > 0 {
		l = 0
		for _, e := range m.ReplicaNodeIds {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if m.LeaseholderNodeID != 0 {
		n += 1 + sovStatus(uint64(m.LeaseholderNodeID))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	return n
}

func (m *RangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovStatus(uint64(m.RangeId))
	}
	return n
}

func (m *RangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if m.RangeID != 0 {
		n += 1 + sovStatus(uint64(m.RangeID))
	}
	if len(m.ResponsesByNodeID) > 0 {
		for k, v := range m.ResponsesByNodeID {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RangeResponse_NodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response {
		n += 2
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *DiagnosticsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *StoresRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *StoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	l = len(m.EncryptionStatus)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.TotalFiles != 0 {
		n += 1 + sovStatus(uint64(m.TotalFiles))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovStatus(uint64(m.TotalBytes))
	}
	if m.ActiveKeyFiles != 0 {
		n += 1 + sovStatus(uint64(m.ActiveKeyFiles))
	}
	if m.ActiveKeyBytes != 0 {
		n += 1 + sovStatus(uint64(m.ActiveKeyBytes))
	}
	return n
}

func (m *StoresResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Stores) > 0 {
		for _, e := range m.Stores {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *StatementsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Combined {
		n += 2
	}
	if m.Start != 0 {
		n += 1 + sovStatus(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovStatus(uint64(m.End))
	}
	if m.FetchMode != 0 {
		n += 1 + sovStatus(uint64(m.FetchMode))
	}
	return n
}

func (m *StatementsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Statements) > 0 {
		for _, e := range m.Statements {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastReset)
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.InternalAppNamePrefix)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.KeyData.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.AggregatedTs)
	n += 1 + l + sovStatus(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.AggregationInterval)
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *StatementsResponse_CollectedStatementStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Stats.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.ID != 0 {
		n += 1 + sovStatus(uint64(m.ID))
	}
	return n
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StatsData.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	return n
}

func (m *CombinedStatementsStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovStatus(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovStatus(uint64(m.End))
	}
	return n
}

func (m *StatementDiagnosticsReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStatus(uint64(m.Id))
	}
	if m.Completed {
		n += 2
	}
	l = len(m.StatementFingerprint)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.StatementDiagnosticsId != 0 {
		n += 1 + sovStatus(uint64(m.StatementDiagnosticsId))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RequestedAt)
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *CreateStatementDiagnosticsReportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StatementFingerprint)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CreateStatementDiagnosticsReportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Report != nil {
		l = m.Report.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *StatementDiagnosticsReportsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StatementDiagnosticsReportsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reports) > 0 {
		for _, e := range m.Reports {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *StatementDiagnostics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStatus(uint64(m.Id))
	}
	l = len(m.StatementFingerprint)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CollectedAt)
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *StatementDiagnosticsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatementDiagnosticsId != 0 {
		n += 1 + sovStatus(uint64(m.StatementDiagnosticsId))
	}
	return n
}

func (m *StatementDiagnosticsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Diagnostics != nil {
		l = m.Diagnostics.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *JobRegistryStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *JobRegistryStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if len(m.RunningJobs) > 0 {
		for _, e := range m.RunningJobs {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *JobRegistryStatusResponse_Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStatus(uint64(m.Id))
	}
	return n
}

func (m *JobStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != 0 {
		n += 1 + sovStatus(uint64(m.JobId))
	}
	return n
}

func (m *JobStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ResetSQLStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.ResetPersistedStats {
		n += 2
	}
	return n
}

func (m *ResetSQLStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *IndexUsageStatisticsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *IndexUsageStatisticsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Statistics) > 0 {
		for _, e := range m.Statistics {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastReset)
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *ResetIndexUsageStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ResetIndexUsageStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UserSQLRolesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UserSQLRolesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func sovStatus(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStatus(x uint64) (n int) {
	return sovStatus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CertificatesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificatesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificatesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CertificateDetails_CertificateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, CertificateDetails_Fields{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateDetails_Fields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidFrom", wireType)
			}
			m.ValidFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidFrom |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureAlgorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignatureAlgorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUsage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyUsage = append(m.KeyUsage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedKeyUsage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendedKeyUsage = append(m.ExtendedKeyUsage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificatesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificatesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificatesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificates = append(m.Certificates, CertificateDetails{})
			if err := m.Certificates[len(m.Certificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BuildInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SystemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SQLAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, statuspb.NodeStatus{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessByNodeID == nil {
				m.LivenessByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus)
			}
			var mapkey int32
			var mapvalue livenesspb.NodeLivenessStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= livenesspb.NodeLivenessStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LivenessByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesResponseExternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesResponseExternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesResponseExternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, NodeResponse{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessByNodeID == nil {
				m.LivenessByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]livenesspb.NodeLivenessStatus)
			}
			var mapkey int32
			var mapvalue livenesspb.NodeLivenessStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= livenesspb.NodeLivenessStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LivenessByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Locality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Locality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Locality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tiers = append(m.Tiers, Tier{})
			if err := m.Tiers[len(m.Tiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			m.Patch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Patch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			m.Internal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Internal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Locality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServerVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityAddress = append(m.LocalityAddress, roachpb.LocalityAddress{})
			if err := m.LocalityAddress[len(m.LocalityAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SQLAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Percentiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Percentiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Percentiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P10", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P10 = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P25", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P25 = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P50", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P50 = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P75", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P75 = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P90 = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PMax = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Capacity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metrics[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BuildInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metrics[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreStatuses = append(m.StoreStatuses, StoreStatus{})
			if err := m.StoreStatuses[len(m.StoreStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Latencies == nil {
				m.Latencies = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Latencies[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Activity == nil {
				m.Activity = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]NodeResponse_NetworkActivity)
			}
			var mapkey int32
			mapvalue := &NodeResponse_NetworkActivity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NodeResponse_NetworkActivity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Activity[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSystemMemory", wireType)
			}
			m.TotalSystemMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSystemMemory |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCpus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeResponse_NetworkActivity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkActivity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkActivity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incoming", wireType)
			}
			m.Incoming = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Incoming |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outgoing", wireType)
			}
			m.Outgoing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Outgoing |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			m.Latency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Regions == nil {
				m.Regions = make(map[string]*RegionsResponse_Region)
			}
			var mapkey string
			var mapvalue *RegionsResponse_Region
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RegionsResponse_Region{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Regions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionsResponse_Region) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Region: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Region: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zones", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zones = append(m.Zones, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HardState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lead", wireType)
			}
			m.Lead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = make(map[uint64]RaftState_Progress)
			}
			var mapkey uint64
			mapvalue := &RaftState_Progress{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RaftState_Progress{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Progress[mapkey] = *mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadTransferee", wireType)
			}
			m.LeadTransferee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeadTransferee |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftState_Progress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Progress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Progress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			m.Match = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Match |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			m.Next = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Next |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingSnapshot", wireType)
			}
			m.PendingSnapshot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingSnapshot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeProblems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeProblems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeProblems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unavailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unavailable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderNotLeaseHolder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeaderNotLeaseHolder = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRaftLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoRaftLeader = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Underreplicated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Underreplicated = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoLease", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoLease = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuiescentEqualsTicking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QuiescentEqualsTicking = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLogTooLarge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RaftLogTooLarge = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overreplicated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overreplicated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueriesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QueriesPerSecond = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WritesPerSecond = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrettySpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrettySpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrettySpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNodeID", wireType)
			}
			m.SourceNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceNodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStoreID", wireType)
			}
			m.SourceStoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceStoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseHistory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseHistory = append(m.LeaseHistory, roachpb.Lease{})
			if err := m.LeaseHistory[len(m.LeaseHistory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Problems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Problems.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeaseStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quiescent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quiescent = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ticking = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadLatches", wireType)
			}
			m.ReadLatches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadLatches |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteLatches", wireType)
			}
			m.WriteLatches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteLatches |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			m.Locks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Locks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocksWithWaitQueues", wireType)
			}
			m.LocksWithWaitQueues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocksWithWaitQueues |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockWaitQueueWaiters", wireType)
			}
			m.LockWaitQueueWaiters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockWaitQueueWaiters |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopKLocksByWaitQueueWaiters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopKLocksByWaitQueueWaiters = append(m.TopKLocksByWaitQueueWaiters, RangeInfo_LockInfo{})
			if err := m.TopKLocksByWaitQueueWaiters[len(m.TopKLocksByWaitQueueWaiters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeInfo_LockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrettyKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrettyKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Held", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Held = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waiters", wireType)
			}
			m.Waiters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Waiters |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitingReaders", wireType)
			}
			m.WaitingReaders = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitingReaders |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitingWriters", wireType)
			}
			m.WaitingWriters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitingWriters |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RangeIDs = append(m.RangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RangeIDs) == 0 {
					m.RangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RangeIDs = append(m.RangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, RangeInfo{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineStatsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineStatsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineStatsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickersAndHistograms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TickersAndHistograms == nil {
				m.TickersAndHistograms = &enginepb.TickersAndHistograms{}
			}
			if err := m.TickersAndHistograms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngineType", wireType)
			}
			m.EngineType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EngineType |= enginepb.EngineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, EngineStatsInfo{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorDryRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorDryRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorDryRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &TraceEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DryRun == nil {
				m.DryRun = &AllocatorDryRun{}
			}
			if err := m.DryRun.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RangeIDs = append(m.RangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RangeIDs) == 0 {
					m.RangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RangeIDs = append(m.RangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRuns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DryRuns = append(m.DryRuns, &AllocatorDryRun{})
			if err := m.DryRuns[len(m.DryRuns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JSONResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JSONResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JSONResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Max = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redact = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, logpb.Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFilesListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFilesListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFilesListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFilesListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFilesListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFilesListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, logpb.FileInfo{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redact = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StacksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StacksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StacksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StacksType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contents", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = append(m.Contents[:0], dAtA[iNdEx:postIndex]...)
			if m.Contents == nil {
				m.Contents = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFilesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFilesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFilesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ListOnly = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patterns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patterns = append(m.Patterns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFilesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFilesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFilesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ProfileRequest_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Labels = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftRangeNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRangeNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRangeNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftRangeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRangeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRangeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftRangeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRangeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRangeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, RaftRangeError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, RaftRangeNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftDebugRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftDebugRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftDebugRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RangeIDs = append(m.RangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RangeIDs) == 0 {
					m.RangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RangeIDs = append(m.RangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftDebugResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftDebugResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftDebugResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ranges == nil {
				m.Ranges = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID]RaftRangeStatus)
			}
			var mapkey int64
			mapvalue := &RaftRangeStatus{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RaftRangeStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ranges[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, RaftRangeError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumStatementsExecuted", wireType)
			}
			m.NumStatementsExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumStatementsExecuted |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRetries", wireType)
			}
			m.NumRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRetries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAutoRetries", wireType)
			}
			m.NumAutoRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAutoRetries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Deadline, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implicit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Implicit = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocBytes", wireType)
			}
			m.AllocBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllocBytes", wireType)
			}
			m.MaxAllocBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllocBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHistorical", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHistorical = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Priority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDistributed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDistributed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= ActiveQuery_Phase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = float32(math.Float32frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlNoConstants", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlNoConstants = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlSummary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlSummary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSessionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSessionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSessionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveQueries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveQueries = append(m.ActiveQueries, ActiveQuery{})
			if err := m.ActiveQueries[len(m.ActiveQueries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActiveQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastActiveQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocBytes", wireType)
			}
			m.AllocBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllocBytes", wireType)
			}
			m.MaxAllocBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllocBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveTxn == nil {
				m.ActiveTxn = &TxnInfo{}
			}
			if err := m.ActiveTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActiveQueryNoConstants", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastActiveQueryNoConstants = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSessionsError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSessionsError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSessionsError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSessionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSessionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSessionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, Session{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, ListSessionsError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Canceled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Canceled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = append(m.SessionID[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionID == nil {
				m.SessionID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Canceled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Canceled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListContentionEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListContentionEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListContentionEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListActivityError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListActivityError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListActivityError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListContentionEventsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListContentionEventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListContentionEventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Events.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, ListActivityError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDistSQLFlowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDistSQLFlowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDistSQLFlowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistSQLRemoteFlows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistSQLRemoteFlows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistSQLRemoteFlows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FlowID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, DistSQLRemoteFlows_Info{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistSQLRemoteFlows_Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DistSQLRemoteFlows_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDistSQLFlowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDistSQLFlowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDistSQLFlowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flows = append(m.Flows, DistSQLRemoteFlows{})
			if err := m.Flows[len(m.Flows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, ListActivityError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateDiskBytes", wireType)
			}
			m.ApproximateDiskBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateDiskBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProblemRangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProblemRangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProblemRangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProblemRangesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProblemRangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProblemRangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProblemsByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProblemsByNodeID == nil {
				m.ProblemsByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]ProblemRangesResponse_NodeProblems)
			}
			var mapkey int32
			mapvalue := &ProblemRangesResponse_NodeProblems{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ProblemRangesResponse_NodeProblems{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProblemsByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProblemRangesResponse_NodeProblems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeProblems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeProblems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnavailableRangeIDs = append(m.UnavailableRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnavailableRangeIDs) == 0 {
					m.UnavailableRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnavailableRangeIDs = append(m.UnavailableRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnavailableRangeIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RaftLeaderNotLeaseHolderRangeIDs = append(m.RaftLeaderNotLeaseHolderRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RaftLeaderNotLeaseHolderRangeIDs) == 0 {
					m.RaftLeaderNotLeaseHolderRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RaftLeaderNotLeaseHolderRangeIDs = append(m.RaftLeaderNotLeaseHolderRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLeaderNotLeaseHolderRangeIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NoRaftLeaderRangeIDs = append(m.NoRaftLeaderRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NoRaftLeaderRangeIDs) == 0 {
					m.NoRaftLeaderRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NoRaftLeaderRangeIDs = append(m.NoRaftLeaderRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRaftLeaderRangeIDs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NoLeaseRangeIDs = append(m.NoLeaseRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NoLeaseRangeIDs) == 0 {
					m.NoLeaseRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NoLeaseRangeIDs = append(m.NoLeaseRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoLeaseRangeIDs", wireType)
			}
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnderreplicatedRangeIDs = append(m.UnderreplicatedRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnderreplicatedRangeIDs) == 0 {
					m.UnderreplicatedRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnderreplicatedRangeIDs = append(m.UnderreplicatedRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderreplicatedRangeIDs", wireType)
			}
		case 7:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.QuiescentEqualsTickingRangeIDs = append(m.QuiescentEqualsTickingRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.QuiescentEqualsTickingRangeIDs) == 0 {
					m.QuiescentEqualsTickingRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.QuiescentEqualsTickingRangeIDs = append(m.QuiescentEqualsTickingRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QuiescentEqualsTickingRangeIDs", wireType)
			}
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RaftLogTooLargeRangeIDs = append(m.RaftLogTooLargeRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RaftLogTooLargeRangeIDs) == 0 {
					m.RaftLogTooLargeRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RaftLogTooLargeRangeIDs = append(m.RaftLogTooLargeRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLogTooLargeRangeIDs", wireType)
			}
		case 9:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OverreplicatedRangeIDs = append(m.OverreplicatedRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OverreplicatedRangeIDs) == 0 {
					m.OverreplicatedRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OverreplicatedRangeIDs = append(m.OverreplicatedRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OverreplicatedRangeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotRangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotRangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotRangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotRangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotRangesByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HotRangesByNodeID == nil {
				m.HotRangesByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]HotRangesResponse_NodeResponse)
			}
			var mapkey int32
			mapvalue := &HotRangesResponse_NodeResponse{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HotRangesResponse_NodeResponse{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HotRangesByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponse_HotRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueriesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QueriesPerSecond = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseholderNodeID", wireType)
			}
			m.LeaseholderNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseholderNodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponse_StoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HotRanges = append(m.HotRanges, HotRangesResponse_HotRange{})
			if err := m.HotRanges[len(m.HotRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponse_NodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, &HotRangesResponse_StoreResponse{})
			if err := m.Stores[len(m.Stores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponseV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotRangesResponseV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotRangesResponseV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &HotRangesResponseV2_HotRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorsByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ErrorsByNodeID == nil {
				m.ErrorsByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ErrorsByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponseV2_HotRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QPS", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QPS = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReplicaNodeIds = append(m.ReplicaNodeIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatus
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReplicaNodeIds) == 0 {
					m.ReplicaNodeIds = make([]github_com_cockroachdb_cockroach_pkg_roachpb.NodeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.NodeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReplicaNodeIds = append(m.ReplicaNodeIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNodeIds", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseholderNodeID", wireType)
			}
			m.LeaseholderNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseholderNodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsesByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponsesByNodeID == nil {
				m.ResponsesByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]RangeResponse_NodeResponse)
			}
			var mapkey int32
			mapvalue := &RangeResponse_NodeResponse{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RangeResponse_NodeResponse{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResponsesByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeResponse_NodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Response = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, RangeInfo{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiagnosticsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiagnosticsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiagnosticsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoresRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoresRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoresRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionStatus", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionStatus = append(m.EncryptionStatus[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionStatus == nil {
				m.EncryptionStatus = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFiles", wireType)
			}
			m.TotalFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFiles |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveKeyFiles", wireType)
			}
			m.ActiveKeyFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveKeyFiles |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveKeyBytes", wireType)
			}
			m.ActiveKeyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveKeyBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoresResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoresResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoresResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, StoreDetails{})
			if err := m.Stores[len(m.Stores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combined", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Combined = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchMode", wireType)
			}
			m.FetchMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FetchMode |= StatementsRequest_FetchMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statements = append(m.Statements, StatementsResponse_CollectedStatementStatistics{})
			if err := m.Statements[len(m.Statements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastReset, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalAppNamePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalAppNamePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, StatementsResponse_ExtendedCollectedTransactionStatistics{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendedStatementStatisticsKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendedStatementStatisticsKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KeyData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.AggregatedTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.AggregationInterval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsResponse_CollectedStatementStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectedStatementStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectedStatementStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= github_com_cockroachdb_cockroach_pkg_roachpb.StmtFingerprintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendedCollectedTransactionStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendedCollectedTransactionStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StatsData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombinedStatementsStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombinedStatementsStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombinedStatementsStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementDiagnosticsId", wireType)
			}
			m.StatementDiagnosticsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatementDiagnosticsId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RequestedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatementDiagnosticsReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatementDiagnosticsReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatementDiagnosticsReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatementDiagnosticsReportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatementDiagnosticsReportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatementDiagnosticsReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Report == nil {
				m.Report = &StatementDiagnosticsReport{}
			}
			if err := m.Report.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsReportsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsReportsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsReportsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsReportsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsReportsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsReportsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reports = append(m.Reports, StatementDiagnosticsReport{})
			if err := m.Reports[len(m.Reports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnostics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnostics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnostics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CollectedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementDiagnosticsId", wireType)
			}
			m.StatementDiagnosticsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatementDiagnosticsId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diagnostics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Diagnostics == nil {
				m.Diagnostics = &StatementDiagnostics{}
			}
			if err := m.Diagnostics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRegistryStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRegistryStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRegistryStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRegistryStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRegistryStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRegistryStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningJobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningJobs = append(m.RunningJobs, &JobRegistryStatusResponse_Job{})
			if err := m.RunningJobs[len(m.RunningJobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRegistryStatusResponse_Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &jobspb.Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetSQLStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetSQLStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetSQLStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetPersistedStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResetPersistedStats = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetSQLStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetSQLStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetSQLStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexUsageStatisticsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexUsageStatisticsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexUsageStatisticsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexUsageStatisticsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexUsageStatisticsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexUsageStatisticsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statistics = append(m.Statistics, roachpb.CollectedIndexUsageStatistics{})
			if err := m.Statistics[len(m.Statistics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastReset, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetIndexUsageStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetIndexUsageStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetIndexUsageStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetIndexUsageStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetIndexUsageStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetIndexUsageStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSQLRolesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSQLRolesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSQLRolesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSQLRolesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSQLRolesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSQLRolesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStatus
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStatus
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStatus
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStatus        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatus          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStatus = fmt.Errorf("proto: unexpected end of group")
)
