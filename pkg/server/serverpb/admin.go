// Copyright 2018 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

package serverpb

import (
	context "context"
	"fmt"
	"regexp"
	"sort"

	"github.com/cockroachdb/cockroach/pkg/util/metric"
	io_prometheus_client "github.com/prometheus/client_model/go"
)

// MetricsFilterEntry represents a single filter criterion - either a literal
// metric name or a regex pattern.
type MetricsFilterEntry struct {
	Value   string
	IsRegex bool
}

// FilterStats contains statistics from applying a metrics filter.
// This is only returned when a non-empty filter is provided to
// GetInternalTimeseriesNamesFromServer; otherwise it is nil.
type FilterStats struct {
	// RegexMatchCounts maps each regex pattern to the number of metrics it matched.
	RegexMatchCounts map[string]int
	// UnmatchedLiterals contains literal metric names that were not found.
	UnmatchedLiterals []string
}

// Add adds values from ots to ts.
func (ts *TableStatsResponse) Add(ots *TableStatsResponse) {
	ts.RangeCount += ots.RangeCount
	ts.ReplicaCount += ots.ReplicaCount
	ts.ApproximateDiskBytes += ots.ApproximateDiskBytes
	ts.Stats.Add(ots.Stats)

	// The stats in TableStatsResponse were generated by getting separate stats
	// for each node, then aggregating them into TableStatsResponse.
	// So resulting NodeCount should be the same, unless ots contains nodeData
	// in MissingNodes that isn't already tracked in ts.MissingNodes.
	// Note: when comparing missingNode objects, there's a chance that the nodeId
	// could be the same, but that the error messages differ. Keeping the first
	// and dropping subsequent ones seems reasonable to do, and is what is done
	// here.
	missingNodeIds := make(map[string]struct{})
	for _, nodeData := range ts.MissingNodes {
		missingNodeIds[nodeData.NodeID] = struct{}{}
	}
	for _, nodeData := range ots.MissingNodes {
		if _, found := missingNodeIds[nodeData.NodeID]; !found {
			ts.MissingNodes = append(ts.MissingNodes, nodeData)
			ts.NodeCount--
		}
	}
}

func (r DecommissionPreCheckResponse_NodeReadiness) String() string {
	switch r {
	case DecommissionPreCheckResponse_UNKNOWN:
		return "unknown"
	case DecommissionPreCheckResponse_READY:
		return "ready"
	case DecommissionPreCheckResponse_ALREADY_DECOMMISSIONED:
		return "already decommissioned"
	case DecommissionPreCheckResponse_ALLOCATION_ERRORS:
		return "allocation errors"
	default:
		panic("unknown decommission node readiness")
	}
}

type TenantAdminServer interface {
	Liveness(context.Context, *LivenessRequest) (*LivenessResponse, error)
}

// Empty is true if there are no unavailable ranges and no error performing
// healthcheck.
func (r *RecoveryVerifyResponse_UnavailableRanges) Empty() bool {
	return len(r.Ranges) == 0 && len(r.Error) == 0
}

// GetInternalTimeseriesNamesFromServer is a helper that uses the provided
// ClientConn to query the AllMetricMetadata endpoint, and returns the set of
// all possible internal metric names as a sorted slice.
//
// This is *not* the list of timeseries names. Instead, it is that list but
// adding `cr.node.` and `cr.store.` prefixes (both copies are emitted, since we
// can't tell what the true prefix for each metric is). Additionally, for histograms
// we generate the names for the quantiles that are exported (internal TSDB does
// not support full histograms).
//
// If filter is non-empty, only metrics matching the filter criteria are returned.
// Filter entries can be literal metric names or regex patterns (indicated by
// IsRegex=true). Literal names are matched exactly against the base metric name
// (without cr.node./cr.store. prefix). Regex patterns are matched against all
// available metric names.
//
// When a filter is provided, stats contains match counts and unmatched literals.
// When no filter is provided, stats fields are empty/nil.
func GetInternalTimeseriesNamesFromServer(
	ctx context.Context, ac RPCAdminClient, filter []MetricsFilterEntry,
) (names []string, stats FilterStats, err error) {
	resp, err := ac.AllMetricMetadata(ctx, &MetricMetadataRequest{})
	if err != nil {
		return nil, FilterStats{}, err
	}

	// Determine which metric names to process
	var namesToProcess []string
	if len(filter) > 0 {
		// Apply filtering
		namesToProcess, stats, err = applyMetricsFilter(resp.Metadata, filter)
		if err != nil {
			return nil, FilterStats{}, err
		}
	} else {
		// No filter - use all metrics
		namesToProcess = make([]string, 0, len(resp.Metadata))
		for name := range resp.Metadata {
			namesToProcess = append(namesToProcess, name)
		}
	}

	// Expand metrics: for histograms add quantile suffixes, otherwise use as-is
	var expanded []string
	for _, name := range namesToProcess {
		meta, exists := resp.Metadata[name]
		if exists && meta.MetricType == io_prometheus_client.MetricType_HISTOGRAM {
			// See usage of HistogramMetricComputers in pkg/server/status/recorder.go.
			for _, q := range metric.HistogramMetricComputers {
				expanded = append(expanded, name+q.Suffix)
			}
		} else {
			expanded = append(expanded, name)
		}
	}

	out := make([]string, 0, 2*len(expanded))
	for _, prefix := range []string{"cr.node.", "cr.store."} {
		for _, name := range expanded {
			out = append(out, prefix+name)
		}
	}
	sort.Strings(out)
	return out, stats, nil
}

// applyMetricsFilter filters the available metrics based on the provided filter.
// Returns a list of base metric names (without prefixes) that match the filter criteria,
// along with FilterStats containing regex match counts and unmatched literal names.
func applyMetricsFilter(
	metadata map[string]metric.Metadata, filter []MetricsFilterEntry,
) ([]string, FilterStats, error) {
	// Build list of all available metric names for regex matching
	allMetricNames := make([]string, 0, len(metadata))
	for name := range metadata {
		allMetricNames = append(allMetricNames, name)
	}

	// Resolve entries to actual metric names (expand regex patterns)
	resolvedNames := make(map[string]struct{})
	var stats FilterStats
	stats.RegexMatchCounts = make(map[string]int)

	for _, entry := range filter {
		if entry.IsRegex {
			// Compile and match against all available metrics
			re, err := regexp.Compile(entry.Value)
			if err != nil {
				return nil, FilterStats{}, fmt.Errorf("invalid regex pattern: %s: %w", entry.Value, err)
			}
			matchCount := 0
			for _, name := range allMetricNames {
				if re.MatchString(name) {
					resolvedNames[name] = struct{}{}
					matchCount++
				}
			}
			stats.RegexMatchCounts[entry.Value] = matchCount
		} else {
			// Literal metric name - only add if it exists in metadata
			if _, exists := metadata[entry.Value]; exists {
				resolvedNames[entry.Value] = struct{}{}
			} else {
				stats.UnmatchedLiterals = append(stats.UnmatchedLiterals, entry.Value)
			}
		}
	}

	// Convert to slice
	result := make([]string, 0, len(resolvedNames))
	for name := range resolvedNames {
		result = append(result, name)
	}
	return result, stats, nil
}
