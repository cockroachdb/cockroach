// Copyright 2020 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

// This file generates batch_generated.go. It can be run via:
//    go run -tags gen-everynode gen_everynode.go
//
// It was mostly cargo culted from pkg/roachpb/gen_batch.go

// +build gen-everynode

package main

import (
	"fmt"
	"io"
	"os"
	"reflect"

	"github.com/cockroachdb/cockroach/pkg/server/serverpb"
)

type variantInfo struct {
	// variantType is the name of the variant type that implements
	// the union interface (isEveryNodeRequestUnion_Value,isEveryNodeResponseUnion_Value).
	variantType string
	// variantName is the unique suffix of variantType. It is also
	// the name of the single field in this type.
	variantName string
	// msgType is the name of the variant's corresponding Request/Response
	// type.
	msgType string
}

var errVariants []variantInfo
var reqVariants []variantInfo
var resVariants []variantInfo
var reqResVariantMapping map[variantInfo]variantInfo

func initVariant(varInstance interface{}) variantInfo {
	t := reflect.TypeOf(varInstance)
	f := t.Elem().Field(0) // variants always have 1 field
	return variantInfo{
		variantType: t.Elem().Name(),
		variantName: f.Name,
		msgType:     f.Type.Elem().Name(),
	}
}

func initVariants() {
	_, _, _, resVars := (&serverpb.EveryNodeResponseUnion{}).XXX_OneofFuncs()
	resVarInfos := make(map[string]variantInfo, len(resVars))
	for _, v := range resVars {
		resInfo := initVariant(v)
		resVariants = append(resVariants, resInfo)
		resVarInfos[resInfo.variantName] = resInfo
	}

	_, _, _, reqVars := (&serverpb.EveryNodeRequestUnion{}).XXX_OneofFuncs()
	reqResVariantMapping = make(map[variantInfo]variantInfo, len(reqVars))
	for _, v := range reqVars {
		reqInfo := initVariant(v)
		reqVariants = append(reqVariants, reqInfo)

		resName := reqInfo.variantName
		resInfo, ok := resVarInfos[resName]
		if !ok {
			panic(fmt.Sprintf("unknown response variant %q", resName))
		}
		reqResVariantMapping[reqInfo] = resInfo
	}
}

func genGetInner(w io.Writer, unionName, variantName string, variants []variantInfo) {
	fmt.Fprintf(w, `
// GetInner returns the %[2]s contained in the union.
func (ru %[1]s) GetInner() %[2]s {
	switch t := ru.GetValue().(type) {
`, unionName, variantName)

	for _, v := range variants {
		fmt.Fprintf(w, `	case *%s:
		return t.%s
`, v.variantType, v.variantName)
	}

	fmt.Fprint(w, `	default:
		return nil
	}
}
`)
}

func genSetInner(w io.Writer, unionName, variantName string, variants []variantInfo) {
	fmt.Fprintf(w, `
// SetInner sets the %[2]s in the union.
func (ru *%[1]s) SetInner(r %[2]s) bool {
	var union is%[1]s_Value
	switch t := r.(type) {
`, unionName, variantName)

	for _, v := range variants {
		fmt.Fprintf(w, `	case *%s:
		union = &%s{t}
`, v.msgType, v.variantType)
	}

	fmt.Fprint(w, `	default:
		return false
	}
	ru.Value = union
	return true
}
`)
}

func main() {
	initVariants()

	f, err := os.Create("everynode_generated.go")
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error opening file: ", err)
		os.Exit(1)
	}

	// First comment for github/Go; second for reviewable.
	// https://github.com/golang/go/issues/13560#issuecomment-277804473
	// https://github.com/Reviewable/Reviewable/wiki/FAQ#how-do-i-tell-reviewable-that-a-file-is-generated-and-should-not-be-reviewed
	fmt.Fprint(f, `// Code generated by gen_batch.go; DO NOT EDIT.
// GENERATED FILE DO NOT EDIT

package serverpb

`)

	// Generate GetInner methods.
	genGetInner(f, "EveryNodeRequestUnion", "EveryNodeOp", reqVariants)
	genGetInner(f, "EveryNodeResponseUnion", "EveryNodeOpResp", resVariants)

	// Generate SetInner methods.
	genSetInner(f, "EveryNodeRequestUnion", "EveryNodeOp", reqVariants)
	genSetInner(f, "EveryNodeResponseUnion", "EveryNodeOpResp", resVariants)

	if err := f.Close(); err != nil {
		fmt.Fprintln(os.Stderr, "Error closing file: ", err)
		os.Exit(1)
	}
}
