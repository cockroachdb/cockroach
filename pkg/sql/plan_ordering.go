// Copyright 2017 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package sql

import "github.com/cockroachdb/cockroach/pkg/sql/sqlbase"

// planOrdering describes known ordering information for the rows generated by
// this node. The ordering information includes columns the output is ordered
// by and columns for which we know all rows have the same value. See
// orderingInfo for more details.
//
// Stable after optimizePlan() (or makePlan).
// Available after newPlan(), but may change on intermediate plan
// nodes during optimizePlan() due to index selection.
func planOrdering(plan planNode) orderingInfo {
	switch n := plan.(type) {
	case *explainPlanNode:
		return planOrdering(n.results)
	case *distinctNode:
		return planOrdering(n.plan)
	case *filterNode:
		return planOrdering(n.source.plan)
	case *limitNode:
		return planOrdering(n.plan)
	case *indexJoinNode:
		return planOrdering(n.index)

	case *groupNode:
		// TODO(dt,knz,radu): aggregate buckets can be ordered if the source is
		// ordered on the aggregating column already.
	case *windowNode:
		// TODO: window partitions can be ordered if the source is ordered
		// appropriately.
	case *joinNode:
		// TODO(knz): this can be ordered when not using hash join.
	case *unionNode:
		// TODO(knz): this can be ordered if the source is ordered already.
	case *insertNode:
		// TODO(knz): RETURNING is ordered by the PK.
	case *deleteNode:
		// TODO(knz): RETURNING is ordered by the PK.
	case *updateNode:
		// TODO(knz): RETURNING is ordered by the PK.

	case *scanNode:
		return n.ordering
	case *ordinalityNode:
		return n.ordering
	case *renderNode:
		return n.ordering
	case *sortNode:
		return sortOrdering(n)
	}

	// Every other node simply has no ordering guarantees on its output
	// rows.

	return orderingInfo{}
}

func sortOrdering(n *sortNode) orderingInfo {
	underlying := planOrdering(n.plan)

	var ord orderingInfo
	if n.needSort {
		// We will sort and can guarantee the desired ordering.
		ord.ordering = make(sqlbase.ColumnOrdering, 0, len(n.ordering))
		for _, o := range n.ordering {
			// Skip any exact match columns.
			if _, ok := underlying.exactMatchCols[o.ColIdx]; !ok {
				ord.ordering = append(ord.ordering, o)
			}
		}
	} else {
		// If we aren't sorting, the underlying plan's ordering can be more specific
		// than the sortNode's ordering, so we want to use that. E.g:
		//   CREATE INDEX foo ON t (a, b);
		//   SELECT a, b, c FROM t ORDER BY a;
		// We want to use (a, b) instead of just (a).
		ord.ordering = underlying.ordering
	}

	// Preserve exact match columns.
	if len(underlying.exactMatchCols) != 0 {
		ord.exactMatchCols = make(map[int]struct{})
		for c := range underlying.exactMatchCols {
			// Skip columns not in the output.
			if c < len(n.columns) {
				ord.exactMatchCols[c] = struct{}{}
			}
		}
	}

	// Remove all the columns after the first one that's not present in
	// the result columns.
	for i, o := range ord.ordering {
		if o.ColIdx >= len(n.columns) {
			// If something is ordered by columns A, then B, then C, if I
			// don't have column B I can't say it's ordered by columns A,
			// then C. Example:
			// A | B | C          A | C
			// ---------          -----
			// 1 | 1 | 2   --->   1 | 2
			// 1 | 2 | 1          1 | 1
			// 1 | 2 | 3          1 | 3
			// So we need to break the orderingInfo here.
			ord.ordering = ord.ordering[:i]
			break
		}
	}
	return ord
}
