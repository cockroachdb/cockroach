// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/sqlerror/data.proto

package sqlerror

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import pgerror "github.com/cockroachdb/cockroach/pkg/sql/pgwire/pgerror"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// EncodedErrorWrapper is a generic representation for error wrappers.
type EncodedErrorWrapper struct {
	Cause                AnyErrorContainer   `protobuf:"bytes,1,opt,name=cause,proto3" json:"cause"`
	Payload              ErrorWrapperPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *EncodedErrorWrapper) Reset()         { *m = EncodedErrorWrapper{} }
func (m *EncodedErrorWrapper) String() string { return proto.CompactTextString(m) }
func (*EncodedErrorWrapper) ProtoMessage()    {}
func (*EncodedErrorWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_data_97bbea8d7cd379fb, []int{0}
}
func (m *EncodedErrorWrapper) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncodedErrorWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *EncodedErrorWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncodedErrorWrapper.Merge(dst, src)
}
func (m *EncodedErrorWrapper) XXX_Size() int {
	return m.Size()
}
func (m *EncodedErrorWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_EncodedErrorWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_EncodedErrorWrapper proto.InternalMessageInfo

// AnyErrorContainer is a container for a protobuf-encodable error.
type AnyErrorContainer struct {
	// Types that are valid to be assigned to Detail:
	//	*AnyErrorContainer_WrappedError
	//	*AnyErrorContainer_OtherError
	//	*AnyErrorContainer_PGError
	//	*AnyErrorContainer_RetryableTxnError
	//	*AnyErrorContainer_TxnRefreshError
	//	*AnyErrorContainer_AmbiguousError
	Detail               isAnyErrorContainer_Detail `protobuf_oneof:"detail"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *AnyErrorContainer) Reset()         { *m = AnyErrorContainer{} }
func (m *AnyErrorContainer) String() string { return proto.CompactTextString(m) }
func (*AnyErrorContainer) ProtoMessage()    {}
func (*AnyErrorContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_data_97bbea8d7cd379fb, []int{1}
}
func (m *AnyErrorContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnyErrorContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AnyErrorContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnyErrorContainer.Merge(dst, src)
}
func (m *AnyErrorContainer) XXX_Size() int {
	return m.Size()
}
func (m *AnyErrorContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_AnyErrorContainer.DiscardUnknown(m)
}

var xxx_messageInfo_AnyErrorContainer proto.InternalMessageInfo

type isAnyErrorContainer_Detail interface {
	isAnyErrorContainer_Detail()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AnyErrorContainer_WrappedError struct {
	WrappedError *EncodedErrorWrapper `protobuf:"bytes,1,opt,name=wrapped_error,json=wrappedError,proto3,oneof"`
}
type AnyErrorContainer_OtherError struct {
	OtherError *UnencodableError `protobuf:"bytes,2,opt,name=other_error,json=otherError,proto3,oneof"`
}
type AnyErrorContainer_PGError struct {
	PGError *pgerror.Error `protobuf:"bytes,3,opt,name=pg_error,json=pgError,proto3,oneof"`
}
type AnyErrorContainer_RetryableTxnError struct {
	RetryableTxnError *roachpb.UnhandledRetryableError `protobuf:"bytes,4,opt,name=retryable_txn_error,json=retryableTxnError,proto3,oneof"`
}
type AnyErrorContainer_TxnRefreshError struct {
	TxnRefreshError *roachpb.TransactionRetryWithProtoRefreshError `protobuf:"bytes,5,opt,name=txn_refresh_error,json=txnRefreshError,proto3,oneof"`
}
type AnyErrorContainer_AmbiguousError struct {
	AmbiguousError *roachpb.AmbiguousResultError `protobuf:"bytes,6,opt,name=ambiguous_error,json=ambiguousError,proto3,oneof"`
}

func (*AnyErrorContainer_WrappedError) isAnyErrorContainer_Detail()      {}
func (*AnyErrorContainer_OtherError) isAnyErrorContainer_Detail()        {}
func (*AnyErrorContainer_PGError) isAnyErrorContainer_Detail()           {}
func (*AnyErrorContainer_RetryableTxnError) isAnyErrorContainer_Detail() {}
func (*AnyErrorContainer_TxnRefreshError) isAnyErrorContainer_Detail()   {}
func (*AnyErrorContainer_AmbiguousError) isAnyErrorContainer_Detail()    {}

func (m *AnyErrorContainer) GetDetail() isAnyErrorContainer_Detail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *AnyErrorContainer) GetWrappedError() *EncodedErrorWrapper {
	if x, ok := m.GetDetail().(*AnyErrorContainer_WrappedError); ok {
		return x.WrappedError
	}
	return nil
}

func (m *AnyErrorContainer) GetOtherError() *UnencodableError {
	if x, ok := m.GetDetail().(*AnyErrorContainer_OtherError); ok {
		return x.OtherError
	}
	return nil
}

func (m *AnyErrorContainer) GetPGError() *pgerror.Error {
	if x, ok := m.GetDetail().(*AnyErrorContainer_PGError); ok {
		return x.PGError
	}
	return nil
}

func (m *AnyErrorContainer) GetRetryableTxnError() *roachpb.UnhandledRetryableError {
	if x, ok := m.GetDetail().(*AnyErrorContainer_RetryableTxnError); ok {
		return x.RetryableTxnError
	}
	return nil
}

func (m *AnyErrorContainer) GetTxnRefreshError() *roachpb.TransactionRetryWithProtoRefreshError {
	if x, ok := m.GetDetail().(*AnyErrorContainer_TxnRefreshError); ok {
		return x.TxnRefreshError
	}
	return nil
}

func (m *AnyErrorContainer) GetAmbiguousError() *roachpb.AmbiguousResultError {
	if x, ok := m.GetDetail().(*AnyErrorContainer_AmbiguousError); ok {
		return x.AmbiguousError
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AnyErrorContainer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AnyErrorContainer_OneofMarshaler, _AnyErrorContainer_OneofUnmarshaler, _AnyErrorContainer_OneofSizer, []interface{}{
		(*AnyErrorContainer_WrappedError)(nil),
		(*AnyErrorContainer_OtherError)(nil),
		(*AnyErrorContainer_PGError)(nil),
		(*AnyErrorContainer_RetryableTxnError)(nil),
		(*AnyErrorContainer_TxnRefreshError)(nil),
		(*AnyErrorContainer_AmbiguousError)(nil),
	}
}

func _AnyErrorContainer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AnyErrorContainer)
	// detail
	switch x := m.Detail.(type) {
	case *AnyErrorContainer_WrappedError:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WrappedError); err != nil {
			return err
		}
	case *AnyErrorContainer_OtherError:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OtherError); err != nil {
			return err
		}
	case *AnyErrorContainer_PGError:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PGError); err != nil {
			return err
		}
	case *AnyErrorContainer_RetryableTxnError:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RetryableTxnError); err != nil {
			return err
		}
	case *AnyErrorContainer_TxnRefreshError:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TxnRefreshError); err != nil {
			return err
		}
	case *AnyErrorContainer_AmbiguousError:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AmbiguousError); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AnyErrorContainer.Detail has unexpected type %T", x)
	}
	return nil
}

func _AnyErrorContainer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AnyErrorContainer)
	switch tag {
	case 1: // detail.wrapped_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EncodedErrorWrapper)
		err := b.DecodeMessage(msg)
		m.Detail = &AnyErrorContainer_WrappedError{msg}
		return true, err
	case 2: // detail.other_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UnencodableError)
		err := b.DecodeMessage(msg)
		m.Detail = &AnyErrorContainer_OtherError{msg}
		return true, err
	case 3: // detail.pg_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(pgerror.Error)
		err := b.DecodeMessage(msg)
		m.Detail = &AnyErrorContainer_PGError{msg}
		return true, err
	case 4: // detail.retryable_txn_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(roachpb.UnhandledRetryableError)
		err := b.DecodeMessage(msg)
		m.Detail = &AnyErrorContainer_RetryableTxnError{msg}
		return true, err
	case 5: // detail.txn_refresh_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(roachpb.TransactionRetryWithProtoRefreshError)
		err := b.DecodeMessage(msg)
		m.Detail = &AnyErrorContainer_TxnRefreshError{msg}
		return true, err
	case 6: // detail.ambiguous_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(roachpb.AmbiguousResultError)
		err := b.DecodeMessage(msg)
		m.Detail = &AnyErrorContainer_AmbiguousError{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AnyErrorContainer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AnyErrorContainer)
	// detail
	switch x := m.Detail.(type) {
	case *AnyErrorContainer_WrappedError:
		s := proto.Size(x.WrappedError)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnyErrorContainer_OtherError:
		s := proto.Size(x.OtherError)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnyErrorContainer_PGError:
		s := proto.Size(x.PGError)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnyErrorContainer_RetryableTxnError:
		s := proto.Size(x.RetryableTxnError)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnyErrorContainer_TxnRefreshError:
		s := proto.Size(x.TxnRefreshError)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnyErrorContainer_AmbiguousError:
		s := proto.Size(x.AmbiguousError)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// UnencodableError is used to encode error objects that do not have a
// variant in AnyErrorContainer.
type UnencodableError struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnencodableError) Reset()         { *m = UnencodableError{} }
func (m *UnencodableError) String() string { return proto.CompactTextString(m) }
func (*UnencodableError) ProtoMessage()    {}
func (*UnencodableError) Descriptor() ([]byte, []int) {
	return fileDescriptor_data_97bbea8d7cd379fb, []int{2}
}
func (m *UnencodableError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnencodableError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *UnencodableError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnencodableError.Merge(dst, src)
}
func (m *UnencodableError) XXX_Size() int {
	return m.Size()
}
func (m *UnencodableError) XXX_DiscardUnknown() {
	xxx_messageInfo_UnencodableError.DiscardUnknown(m)
}

var xxx_messageInfo_UnencodableError proto.InternalMessageInfo

// ErrorWrapperPayload encodes the payload for an error wrapper.
type ErrorWrapperPayload struct {
	// Types that are valid to be assigned to Payload:
	//	*ErrorWrapperPayload_WithCode
	//	*ErrorWrapperPayload_WithMessage
	//	*ErrorWrapperPayload_WithHint
	//	*ErrorWrapperPayload_WithDetail
	//	*ErrorWrapperPayload_WithTelemetryKey
	//	*ErrorWrapperPayload_WithSource
	//	*ErrorWrapperPayload_WithSafeDetail
	//	*ErrorWrapperPayload_WithUnknownErrorPayload
	//	*ErrorWrapperPayload_WithInternalError
	Payload              isErrorWrapperPayload_Payload `protobuf_oneof:"payload"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ErrorWrapperPayload) Reset()         { *m = ErrorWrapperPayload{} }
func (m *ErrorWrapperPayload) String() string { return proto.CompactTextString(m) }
func (*ErrorWrapperPayload) ProtoMessage()    {}
func (*ErrorWrapperPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_data_97bbea8d7cd379fb, []int{3}
}
func (m *ErrorWrapperPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorWrapperPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ErrorWrapperPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorWrapperPayload.Merge(dst, src)
}
func (m *ErrorWrapperPayload) XXX_Size() int {
	return m.Size()
}
func (m *ErrorWrapperPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorWrapperPayload.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorWrapperPayload proto.InternalMessageInfo

type isErrorWrapperPayload_Payload interface {
	isErrorWrapperPayload_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ErrorWrapperPayload_WithCode struct {
	WithCode *TextErrorPayload `protobuf:"bytes,1,opt,name=with_code,json=withCode,proto3,oneof"`
}
type ErrorWrapperPayload_WithMessage struct {
	WithMessage *TextErrorPayload `protobuf:"bytes,2,opt,name=with_message,json=withMessage,proto3,oneof"`
}
type ErrorWrapperPayload_WithHint struct {
	WithHint *TextErrorPayload `protobuf:"bytes,3,opt,name=with_hint,json=withHint,proto3,oneof"`
}
type ErrorWrapperPayload_WithDetail struct {
	WithDetail *TextErrorPayload `protobuf:"bytes,4,opt,name=with_detail,json=withDetail,proto3,oneof"`
}
type ErrorWrapperPayload_WithTelemetryKey struct {
	WithTelemetryKey *TextErrorPayload `protobuf:"bytes,5,opt,name=with_telemetry_key,json=withTelemetryKey,proto3,oneof"`
}
type ErrorWrapperPayload_WithSource struct {
	WithSource *pgerror.Error_Source `protobuf:"bytes,6,opt,name=with_source,json=withSource,proto3,oneof"`
}
type ErrorWrapperPayload_WithSafeDetail struct {
	WithSafeDetail *SafeDetailPayload `protobuf:"bytes,7,opt,name=with_safe_detail,json=withSafeDetail,proto3,oneof"`
}
type ErrorWrapperPayload_WithUnknownErrorPayload struct {
	WithUnknownErrorPayload *TextErrorPayload `protobuf:"bytes,8,opt,name=with_unknown_error_payload,json=withUnknownErrorPayload,proto3,oneof"`
}
type ErrorWrapperPayload_WithInternalError struct {
	WithInternalError *TextErrorPayload `protobuf:"bytes,9,opt,name=with_internal_error,json=withInternalError,proto3,oneof"`
}

func (*ErrorWrapperPayload_WithCode) isErrorWrapperPayload_Payload()                {}
func (*ErrorWrapperPayload_WithMessage) isErrorWrapperPayload_Payload()             {}
func (*ErrorWrapperPayload_WithHint) isErrorWrapperPayload_Payload()                {}
func (*ErrorWrapperPayload_WithDetail) isErrorWrapperPayload_Payload()              {}
func (*ErrorWrapperPayload_WithTelemetryKey) isErrorWrapperPayload_Payload()        {}
func (*ErrorWrapperPayload_WithSource) isErrorWrapperPayload_Payload()              {}
func (*ErrorWrapperPayload_WithSafeDetail) isErrorWrapperPayload_Payload()          {}
func (*ErrorWrapperPayload_WithUnknownErrorPayload) isErrorWrapperPayload_Payload() {}
func (*ErrorWrapperPayload_WithInternalError) isErrorWrapperPayload_Payload()       {}

func (m *ErrorWrapperPayload) GetPayload() isErrorWrapperPayload_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithCode() *TextErrorPayload {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithCode); ok {
		return x.WithCode
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithMessage() *TextErrorPayload {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithMessage); ok {
		return x.WithMessage
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithHint() *TextErrorPayload {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithHint); ok {
		return x.WithHint
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithDetail() *TextErrorPayload {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithDetail); ok {
		return x.WithDetail
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithTelemetryKey() *TextErrorPayload {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithTelemetryKey); ok {
		return x.WithTelemetryKey
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithSource() *pgerror.Error_Source {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithSource); ok {
		return x.WithSource
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithSafeDetail() *SafeDetailPayload {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithSafeDetail); ok {
		return x.WithSafeDetail
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithUnknownErrorPayload() *TextErrorPayload {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithUnknownErrorPayload); ok {
		return x.WithUnknownErrorPayload
	}
	return nil
}

func (m *ErrorWrapperPayload) GetWithInternalError() *TextErrorPayload {
	if x, ok := m.GetPayload().(*ErrorWrapperPayload_WithInternalError); ok {
		return x.WithInternalError
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ErrorWrapperPayload) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ErrorWrapperPayload_OneofMarshaler, _ErrorWrapperPayload_OneofUnmarshaler, _ErrorWrapperPayload_OneofSizer, []interface{}{
		(*ErrorWrapperPayload_WithCode)(nil),
		(*ErrorWrapperPayload_WithMessage)(nil),
		(*ErrorWrapperPayload_WithHint)(nil),
		(*ErrorWrapperPayload_WithDetail)(nil),
		(*ErrorWrapperPayload_WithTelemetryKey)(nil),
		(*ErrorWrapperPayload_WithSource)(nil),
		(*ErrorWrapperPayload_WithSafeDetail)(nil),
		(*ErrorWrapperPayload_WithUnknownErrorPayload)(nil),
		(*ErrorWrapperPayload_WithInternalError)(nil),
	}
}

func _ErrorWrapperPayload_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ErrorWrapperPayload)
	// payload
	switch x := m.Payload.(type) {
	case *ErrorWrapperPayload_WithCode:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithCode); err != nil {
			return err
		}
	case *ErrorWrapperPayload_WithMessage:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithMessage); err != nil {
			return err
		}
	case *ErrorWrapperPayload_WithHint:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithHint); err != nil {
			return err
		}
	case *ErrorWrapperPayload_WithDetail:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithDetail); err != nil {
			return err
		}
	case *ErrorWrapperPayload_WithTelemetryKey:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithTelemetryKey); err != nil {
			return err
		}
	case *ErrorWrapperPayload_WithSource:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithSource); err != nil {
			return err
		}
	case *ErrorWrapperPayload_WithSafeDetail:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithSafeDetail); err != nil {
			return err
		}
	case *ErrorWrapperPayload_WithUnknownErrorPayload:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithUnknownErrorPayload); err != nil {
			return err
		}
	case *ErrorWrapperPayload_WithInternalError:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WithInternalError); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ErrorWrapperPayload.Payload has unexpected type %T", x)
	}
	return nil
}

func _ErrorWrapperPayload_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ErrorWrapperPayload)
	switch tag {
	case 1: // payload.with_code
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextErrorPayload)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithCode{msg}
		return true, err
	case 2: // payload.with_message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextErrorPayload)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithMessage{msg}
		return true, err
	case 3: // payload.with_hint
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextErrorPayload)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithHint{msg}
		return true, err
	case 4: // payload.with_detail
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextErrorPayload)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithDetail{msg}
		return true, err
	case 5: // payload.with_telemetry_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextErrorPayload)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithTelemetryKey{msg}
		return true, err
	case 6: // payload.with_source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(pgerror.Error_Source)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithSource{msg}
		return true, err
	case 7: // payload.with_safe_detail
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SafeDetailPayload)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithSafeDetail{msg}
		return true, err
	case 8: // payload.with_unknown_error_payload
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextErrorPayload)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithUnknownErrorPayload{msg}
		return true, err
	case 9: // payload.with_internal_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextErrorPayload)
		err := b.DecodeMessage(msg)
		m.Payload = &ErrorWrapperPayload_WithInternalError{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ErrorWrapperPayload_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ErrorWrapperPayload)
	// payload
	switch x := m.Payload.(type) {
	case *ErrorWrapperPayload_WithCode:
		s := proto.Size(x.WithCode)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ErrorWrapperPayload_WithMessage:
		s := proto.Size(x.WithMessage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ErrorWrapperPayload_WithHint:
		s := proto.Size(x.WithHint)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ErrorWrapperPayload_WithDetail:
		s := proto.Size(x.WithDetail)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ErrorWrapperPayload_WithTelemetryKey:
		s := proto.Size(x.WithTelemetryKey)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ErrorWrapperPayload_WithSource:
		s := proto.Size(x.WithSource)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ErrorWrapperPayload_WithSafeDetail:
		s := proto.Size(x.WithSafeDetail)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ErrorWrapperPayload_WithUnknownErrorPayload:
		s := proto.Size(x.WithUnknownErrorPayload)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ErrorWrapperPayload_WithInternalError:
		s := proto.Size(x.WithInternalError)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TextErrorPayload encapsulates a single string in an error wrapper.
type TextErrorPayload struct {
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TextErrorPayload) Reset()         { *m = TextErrorPayload{} }
func (m *TextErrorPayload) String() string { return proto.CompactTextString(m) }
func (*TextErrorPayload) ProtoMessage()    {}
func (*TextErrorPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_data_97bbea8d7cd379fb, []int{4}
}
func (m *TextErrorPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextErrorPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TextErrorPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextErrorPayload.Merge(dst, src)
}
func (m *TextErrorPayload) XXX_Size() int {
	return m.Size()
}
func (m *TextErrorPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_TextErrorPayload.DiscardUnknown(m)
}

var xxx_messageInfo_TextErrorPayload proto.InternalMessageInfo

// SafeDetailPayload encapsulates safe (PII-free) additional details.
type SafeDetailPayload struct {
	// safe_message encodes the message as per log.ReportablesToSafeError.
	SafeMessage string `protobuf:"bytes,1,opt,name=safe_message,json=safeMessage,proto3" json:"safe_message,omitempty"`
	// encoded_stack_trace encodes the stack trace as per log.EncodeStackTrace.
	EncodedStackTrace string `protobuf:"bytes,2,opt,name=encoded_stack_trace,json=encodedStackTrace,proto3" json:"encoded_stack_trace,omitempty"`
	// source is the head of the stack trace.
	Source               *pgerror.Error_Source `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SafeDetailPayload) Reset()         { *m = SafeDetailPayload{} }
func (m *SafeDetailPayload) String() string { return proto.CompactTextString(m) }
func (*SafeDetailPayload) ProtoMessage()    {}
func (*SafeDetailPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_data_97bbea8d7cd379fb, []int{5}
}
func (m *SafeDetailPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SafeDetailPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SafeDetailPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SafeDetailPayload.Merge(dst, src)
}
func (m *SafeDetailPayload) XXX_Size() int {
	return m.Size()
}
func (m *SafeDetailPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SafeDetailPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SafeDetailPayload proto.InternalMessageInfo

func init() {
	proto.RegisterType((*EncodedErrorWrapper)(nil), "cockroach.sql.sqlerror.EncodedErrorWrapper")
	proto.RegisterType((*AnyErrorContainer)(nil), "cockroach.sql.sqlerror.AnyErrorContainer")
	proto.RegisterType((*UnencodableError)(nil), "cockroach.sql.sqlerror.UnencodableError")
	proto.RegisterType((*ErrorWrapperPayload)(nil), "cockroach.sql.sqlerror.ErrorWrapperPayload")
	proto.RegisterType((*TextErrorPayload)(nil), "cockroach.sql.sqlerror.TextErrorPayload")
	proto.RegisterType((*SafeDetailPayload)(nil), "cockroach.sql.sqlerror.SafeDetailPayload")
}
func (m *EncodedErrorWrapper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncodedErrorWrapper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Cause.Size()))
	n1, err := m.Cause.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Payload.Size()))
	n2, err := m.Payload.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *AnyErrorContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnyErrorContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		nn3, err := m.Detail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *AnyErrorContainer_WrappedError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WrappedError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WrappedError.Size()))
		n4, err := m.WrappedError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *AnyErrorContainer_OtherError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OtherError != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(m.OtherError.Size()))
		n5, err := m.OtherError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *AnyErrorContainer_PGError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PGError != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.PGError.Size()))
		n6, err := m.PGError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *AnyErrorContainer_RetryableTxnError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RetryableTxnError != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintData(dAtA, i, uint64(m.RetryableTxnError.Size()))
		n7, err := m.RetryableTxnError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *AnyErrorContainer_TxnRefreshError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TxnRefreshError != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.TxnRefreshError.Size()))
		n8, err := m.TxnRefreshError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *AnyErrorContainer_AmbiguousError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AmbiguousError != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintData(dAtA, i, uint64(m.AmbiguousError.Size()))
		n9, err := m.AmbiguousError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *UnencodableError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnencodableError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *ErrorWrapperPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorWrapperPayload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		nn10, err := m.Payload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *ErrorWrapperPayload_WithCode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithCode != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithCode.Size()))
		n11, err := m.WithCode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *ErrorWrapperPayload_WithMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithMessage != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithMessage.Size()))
		n12, err := m.WithMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *ErrorWrapperPayload_WithHint) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithHint != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithHint.Size()))
		n13, err := m.WithHint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *ErrorWrapperPayload_WithDetail) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithDetail != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithDetail.Size()))
		n14, err := m.WithDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *ErrorWrapperPayload_WithTelemetryKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithTelemetryKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithTelemetryKey.Size()))
		n15, err := m.WithTelemetryKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *ErrorWrapperPayload_WithSource) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithSource != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithSource.Size()))
		n16, err := m.WithSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *ErrorWrapperPayload_WithSafeDetail) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithSafeDetail != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithSafeDetail.Size()))
		n17, err := m.WithSafeDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *ErrorWrapperPayload_WithUnknownErrorPayload) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithUnknownErrorPayload != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithUnknownErrorPayload.Size()))
		n18, err := m.WithUnknownErrorPayload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *ErrorWrapperPayload_WithInternalError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WithInternalError != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.WithInternalError.Size()))
		n19, err := m.WithInternalError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *TextErrorPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextErrorPayload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func (m *SafeDetailPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SafeDetailPayload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SafeMessage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.SafeMessage)))
		i += copy(dAtA[i:], m.SafeMessage)
	}
	if len(m.EncodedStackTrace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.EncodedStackTrace)))
		i += copy(dAtA[i:], m.EncodedStackTrace)
	}
	if m.Source != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Source.Size()))
		n20, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func encodeVarintData(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EncodedErrorWrapper) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Cause.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Payload.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *AnyErrorContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Detail != nil {
		n += m.Detail.Size()
	}
	return n
}

func (m *AnyErrorContainer_WrappedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WrappedError != nil {
		l = m.WrappedError.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *AnyErrorContainer_OtherError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OtherError != nil {
		l = m.OtherError.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *AnyErrorContainer_PGError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PGError != nil {
		l = m.PGError.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *AnyErrorContainer_RetryableTxnError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetryableTxnError != nil {
		l = m.RetryableTxnError.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *AnyErrorContainer_TxnRefreshError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxnRefreshError != nil {
		l = m.TxnRefreshError.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *AnyErrorContainer_AmbiguousError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AmbiguousError != nil {
		l = m.AmbiguousError.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *UnencodableError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ErrorWrapperPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	return n
}

func (m *ErrorWrapperPayload_WithCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithCode != nil {
		l = m.WithCode.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *ErrorWrapperPayload_WithMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithMessage != nil {
		l = m.WithMessage.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *ErrorWrapperPayload_WithHint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithHint != nil {
		l = m.WithHint.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *ErrorWrapperPayload_WithDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithDetail != nil {
		l = m.WithDetail.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *ErrorWrapperPayload_WithTelemetryKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithTelemetryKey != nil {
		l = m.WithTelemetryKey.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *ErrorWrapperPayload_WithSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithSource != nil {
		l = m.WithSource.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *ErrorWrapperPayload_WithSafeDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithSafeDetail != nil {
		l = m.WithSafeDetail.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *ErrorWrapperPayload_WithUnknownErrorPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithUnknownErrorPayload != nil {
		l = m.WithUnknownErrorPayload.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *ErrorWrapperPayload_WithInternalError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithInternalError != nil {
		l = m.WithInternalError.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *TextErrorPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *SafeDetailPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SafeMessage)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.EncodedStackTrace)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func sovData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EncodedErrorWrapper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncodedErrorWrapper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncodedErrorWrapper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cause.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyErrorContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyErrorContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyErrorContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrappedError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EncodedErrorWrapper{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &AnyErrorContainer_WrappedError{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnencodableError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &AnyErrorContainer_OtherError{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PGError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &pgerror.Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &AnyErrorContainer_PGError{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryableTxnError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &roachpb.UnhandledRetryableError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &AnyErrorContainer_RetryableTxnError{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRefreshError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &roachpb.TransactionRetryWithProtoRefreshError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &AnyErrorContainer_TxnRefreshError{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmbiguousError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &roachpb.AmbiguousResultError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &AnyErrorContainer_AmbiguousError{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnencodableError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnencodableError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnencodableError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorWrapperPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorWrapperPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorWrapperPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextErrorPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithCode{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextErrorPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithMessage{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithHint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextErrorPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithHint{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextErrorPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithDetail{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithTelemetryKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextErrorPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithTelemetryKey{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &pgerror.Error_Source{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithSource{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSafeDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SafeDetailPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithSafeDetail{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithUnknownErrorPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextErrorPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithUnknownErrorPayload{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithInternalError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextErrorPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ErrorWrapperPayload_WithInternalError{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextErrorPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextErrorPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextErrorPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SafeDetailPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SafeDetailPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SafeDetailPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SafeMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedStackTrace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedStackTrace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &pgerror.Error_Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipData(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sql/sqlerror/data.proto", fileDescriptor_data_97bbea8d7cd379fb) }

var fileDescriptor_data_97bbea8d7cd379fb = []byte{
	// 763 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x95, 0xcd, 0x6e, 0x1a, 0x3b,
	0x14, 0xc7, 0x99, 0x84, 0xf0, 0x61, 0x72, 0x13, 0x30, 0xd1, 0x0d, 0xca, 0x02, 0xee, 0x65, 0xd1,
	0xa6, 0x1f, 0x1a, 0xa4, 0x76, 0xd1, 0x6e, 0x43, 0x1a, 0x85, 0x2a, 0x8a, 0x14, 0x4d, 0x40, 0xa9,
	0xa2, 0x4a, 0xc8, 0xcc, 0x98, 0x99, 0x11, 0x13, 0x7b, 0xe2, 0x31, 0x02, 0xde, 0xa0, 0xcb, 0x3e,
	0x40, 0xa5, 0xae, 0xfb, 0x26, 0x59, 0x76, 0xd9, 0x55, 0xd4, 0xd2, 0x17, 0xa9, 0xfc, 0x45, 0x49,
	0x02, 0x55, 0xd9, 0x8d, 0xed, 0xf3, 0xff, 0x9d, 0x63, 0xfb, 0x7f, 0x3c, 0x60, 0x37, 0xb9, 0x8e,
	0x1a, 0xc9, 0x75, 0x84, 0x19, 0xa3, 0xac, 0xe1, 0x21, 0x8e, 0xec, 0x98, 0x51, 0x4e, 0xe1, 0xbf,
	0x2e, 0x75, 0x07, 0x8c, 0x22, 0x37, 0xb0, 0x93, 0xeb, 0xc8, 0x36, 0x21, 0x7b, 0x3b, 0x72, 0x2e,
	0xee, 0x35, 0xe4, 0x30, 0x51, 0xd1, 0x7b, 0x35, 0x81, 0x89, 0xfd, 0x51, 0xc8, 0x70, 0x23, 0xf6,
	0x15, 0xec, 0x4e, 0xc0, 0x8e, 0x4f, 0x7d, 0x2a, 0x3f, 0x1b, 0xe2, 0x4b, 0xcd, 0xd6, 0xbf, 0x58,
	0xa0, 0x7c, 0x44, 0x5c, 0xea, 0x61, 0xef, 0x48, 0x44, 0x5f, 0x30, 0x14, 0xc7, 0x98, 0xc1, 0x23,
	0xb0, 0xe1, 0xa2, 0x61, 0x82, 0x2b, 0xd6, 0x7f, 0xd6, 0x7e, 0xe1, 0xc5, 0x13, 0x7b, 0x71, 0x31,
	0xf6, 0x01, 0x99, 0x48, 0xdd, 0x21, 0x25, 0x1c, 0x85, 0x04, 0xb3, 0x66, 0xfa, 0xe6, 0xb6, 0x96,
	0x72, 0x94, 0x1a, 0x9e, 0x80, 0x6c, 0x8c, 0x26, 0x11, 0x45, 0x5e, 0x65, 0x4d, 0x82, 0x9e, 0x2d,
	0x03, 0xcd, 0x67, 0x3f, 0x53, 0x12, 0x8d, 0x32, 0x84, 0xfa, 0xa7, 0x34, 0x28, 0x3d, 0xc8, 0x07,
	0x1d, 0xf0, 0xcf, 0x48, 0xca, 0xbc, 0xae, 0x24, 0xe9, 0x8a, 0x97, 0x27, 0x7a, 0xb8, 0xdb, 0x56,
	0xca, 0xd9, 0xd4, 0x0c, 0x39, 0x0d, 0x4f, 0x40, 0x81, 0xf2, 0x00, 0x33, 0x4d, 0x54, 0xa5, 0xef,
	0x2f, 0x23, 0x76, 0x08, 0x16, 0x4c, 0xd4, 0x8b, 0xb0, 0x94, 0xb7, 0x52, 0x0e, 0x90, 0x72, 0x05,
	0x6b, 0x82, 0x5c, 0xec, 0x6b, 0xd2, 0xba, 0x24, 0x55, 0xe6, 0x48, 0xfa, 0xae, 0xd4, 0xfe, 0x9b,
	0x85, 0xe9, 0x6d, 0x2d, 0x7b, 0x76, 0x6c, 0x30, 0xd9, 0xd8, 0x57, 0x8c, 0xf7, 0xa0, 0xcc, 0x30,
	0x67, 0x13, 0x91, 0xa3, 0xcb, 0xc7, 0x44, 0xe3, 0xd2, 0x12, 0xf7, 0x74, 0x0e, 0xa7, 0xbd, 0x61,
	0x77, 0x48, 0x80, 0x88, 0x17, 0x61, 0xcf, 0x31, 0x32, 0xc3, 0x2c, 0xcd, 0x40, 0xed, 0x31, 0x51,
	0xf4, 0x3e, 0x28, 0x09, 0x26, 0xc3, 0x7d, 0x86, 0x93, 0x40, 0xb3, 0x37, 0x24, 0xfb, 0xf5, 0x02,
	0x76, 0x9b, 0x21, 0x92, 0x20, 0x97, 0x87, 0x94, 0x48, 0xfa, 0x45, 0xc8, 0x83, 0x33, 0xe1, 0x26,
	0x47, 0x01, 0x4c, 0xa6, 0x6d, 0x3e, 0x26, 0xf3, 0x53, 0xd0, 0x01, 0xdb, 0xe8, 0xaa, 0x17, 0xfa,
	0x43, 0x3a, 0x4c, 0x74, 0x96, 0x8c, 0xcc, 0xf2, 0x78, 0x41, 0x96, 0x03, 0x13, 0xe9, 0xe0, 0x64,
	0x18, 0x71, 0x03, 0xdd, 0x9a, 0x11, 0xd4, 0x89, 0xe5, 0x40, 0xc6, 0xc3, 0x1c, 0x85, 0x51, 0xfd,
	0x39, 0x28, 0xde, 0xbf, 0x09, 0x58, 0x01, 0xd9, 0x2b, 0x9c, 0x24, 0xc8, 0x57, 0x46, 0xce, 0x3b,
	0x66, 0x58, 0xff, 0x90, 0x01, 0xe5, 0x05, 0x9e, 0x83, 0xc7, 0x20, 0x3f, 0x0a, 0x79, 0xd0, 0x15,
	0x26, 0xd1, 0x56, 0x5a, 0x7a, 0xf1, 0x6d, 0x3c, 0x56, 0x75, 0x69, 0x71, 0x2b, 0xe5, 0xe4, 0x84,
	0xf8, 0x90, 0x7a, 0x18, 0x9e, 0x82, 0x4d, 0x09, 0x32, 0xf9, 0xd7, 0x56, 0x66, 0x15, 0x84, 0xfe,
	0x54, 0xc9, 0x67, 0x75, 0x05, 0x21, 0xe1, 0xda, 0x46, 0x2b, 0xd7, 0xd5, 0x0a, 0x09, 0x17, 0xde,
	0x96, 0x20, 0x75, 0x6a, 0xda, 0x42, 0xab, 0xa0, 0x80, 0x90, 0xbf, 0x91, 0x6a, 0xf8, 0x0e, 0x40,
	0x09, 0xe3, 0x38, 0xc2, 0x57, 0xc2, 0x0b, 0xdd, 0x01, 0x9e, 0x68, 0xeb, 0xac, 0xc2, 0x2c, 0x0a,
	0x4a, 0xdb, 0x40, 0x4e, 0xf0, 0x04, 0x36, 0x75, 0x99, 0x09, 0x1d, 0x32, 0x17, 0x6b, 0x9f, 0xd4,
	0x96, 0x35, 0x8e, 0x7d, 0x2e, 0xc3, 0x4c, 0x75, 0x6a, 0x04, 0x3b, 0xa0, 0xa8, 0x18, 0xa8, 0x8f,
	0xcd, 0x7e, 0xb3, 0x7f, 0x7e, 0xcf, 0xce, 0x51, 0x1f, 0xab, 0xbd, 0xfd, 0x2e, 0x6e, 0x4b, 0x22,
	0x67, 0x0b, 0xd0, 0x07, 0x7b, 0x12, 0x3b, 0x24, 0x03, 0x42, 0x47, 0xba, 0x17, 0xbb, 0xe6, 0x9d,
	0xcb, 0xad, 0xbc, 0xf9, 0x5d, 0x41, 0xeb, 0x28, 0xd8, 0xfc, 0x12, 0xbc, 0x04, 0x65, 0x99, 0x28,
	0x24, 0x1c, 0x33, 0x82, 0x22, 0xdd, 0x33, 0xf9, 0x95, 0x33, 0x94, 0x04, 0xe6, 0xad, 0xa6, 0xa8,
	0xbe, 0xc9, 0xcf, 0x5e, 0xe6, 0xfa, 0x23, 0x50, 0xbc, 0xaf, 0x81, 0x10, 0xa4, 0x39, 0x1e, 0x73,
	0xdd, 0x35, 0xf2, 0xbb, 0xfe, 0xd9, 0x02, 0xa5, 0x07, 0xe7, 0x03, 0xff, 0x07, 0x9b, 0xf2, 0x7c,
	0xef, 0xf6, 0x59, 0x41, 0xcc, 0x19, 0xef, 0xda, 0xa0, 0x8c, 0xd5, 0xab, 0xdb, 0x4d, 0x38, 0x72,
	0x07, 0x5d, 0xce, 0x90, 0xab, 0x3a, 0x22, 0xef, 0x94, 0xf4, 0xd2, 0xb9, 0x58, 0x69, 0x8b, 0x05,
	0xf8, 0x0a, 0x64, 0xf4, 0xb5, 0xaf, 0xff, 0xd5, 0xb5, 0x3b, 0x3a, 0xbc, 0x59, 0xbf, 0xf9, 0x51,
	0x4d, 0xdd, 0x4c, 0xab, 0xd6, 0xd7, 0x69, 0xd5, 0xfa, 0x36, 0xad, 0x5a, 0xdf, 0xa7, 0x55, 0xeb,
	0xe3, 0xcf, 0x6a, 0xea, 0x32, 0x67, 0x8e, 0xa7, 0x97, 0x91, 0x3f, 0xbe, 0x97, 0xbf, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x11, 0x1b, 0xca, 0x69, 0x78, 0x07, 0x00, 0x00,
}
