// Copyright 2018 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package hba

import (
	"net"
	"strings"
	"unicode/utf8"

	"github.com/pkg/errors"
)

func Parse(input string) (*Conf, error) {
	if !utf8.ValidString(input) {
		return nil, errors.New("invalid UTF-8")
	}
	// To ease parsing, ensure a newline at EOF.
	data := []rune(input + "\n")

	%% machine scanner;
	%% alphtype rune;
	%% write data;

	// These are generated by ragel. Reference them to avoid unused lint errors.
	_, _, _ = scanner_first_final, scanner_error, scanner_en_main

	cs, p, pe, eof := 0, 0, len(data), len(data)

	var (
		mark   int
		ms     []tree.Name
		mall   bool
		s      tree.Name
		all    bool
		ipn    *net.IPNet
		e      Entry
		err    error
		d      string
		option [2]string
		conf   Conf
	)

	%%{
		ws = (' ' | '\t')+;
		comment = '#' ^'\n'* '\n';

		action mark { mark = p }

		action quotedString {
			all = false
			s = tree.Name(data[mark:p-1])
		}
		action string {
			s = tree.Name(string(data[mark:p]))
			all = false
			if s == "all" {
			   s = ""
			   ms = nil
			   all = true
			}
		}
		quotedString =
			('"' @{ mark = p+1 })
			^('"' | '\n' )*
			'"' %quotedString
			;
		string =
		  ^('"' | space | '#' | ',') @mark
		  ^(space | ',' | '#')* %string;
		stringer =
		    string | quotedString
			;
		multiString =
			(stringer     %{ mall = all; if !mall { ms = []tree.Name{s} } })
			(',' stringer %{ mall = mall || all; if !mall { ms = append(ms, s); } })*
			;

		action addressSlash {
			d = string(data[mark:p])
		}
		action addressSpace {
			d = strings.Join(strings.Fields(string(data[mark:p])), "/")
		}
		action addressIP {
			_, ipn, err = net.ParseCIDR(d)
			if err != nil {
				return nil, err
			}
			e.Address = ipn
		}
		action addressString {
			if all {
			   e.Address = AnyAddr{}
			} else {
			   e.Address = s
			}
		}
		address =
				(xdigit | '.' | ':')+
				(
					'/' digit+ %addressSlash
					| ws digit+ %addressSpace
				)
				%addressIP
			|
				# partial support (to avoid parsing ambiguity) for hostname parsing; enough to get 'all'
				(alpha | '-')+ %string %addressString
			;
		method = string;

		action newHost {
			e = Entry{Type: "host"}
		}
		action database {
			e.AnyDatabase = mall
			e.Database = ms
		}
		action user {
			e.AnyUser = mall
			e.User = ms
		}
		action method {
			e.Method = string(data[mark:p])
		}
		action option {
			copy(option[:], strings.Split(string(data[mark:p]), "="))
			e.Options = append(e.Options, option)
		}
		token = alnum | '.' | '_' | '-';
		option =
			token+ >mark
			'='
			token+ %option
			;
		action host {
			conf.Entries = append(conf.Entries, e)
		}
		host =
			'host' %newHost ws
			@{mall=false} multiString %database ws
			@{mall=false} multiString %user ws
			address >mark ws
			method >mark %method
			(
				ws
				option >mark %option
			)*
			ws? (comment | '\n')
			;
		action invalidHost { return nil, errors.Errorf("entry %d invalid", len(conf.Entries) + 1) }
		top =
			space
			| comment
			| host %host @err(invalidHost)
			;
		action invalid { return nil, errors.New("invalid") }
		main :=
			top**
			%err(invalid)
			;

		write init;
		write exec;
	}%%

	return &conf, nil
}
