# Prepare a statement and make sure it works.

send
Query {"String": "DROP TABLE IF EXISTS drop_cols;"}
Query {"String": "CREATE TABLE drop_cols (id int PRIMARY KEY NOT NULL, f1 int NOT NULL, f2 int NOT NULL);"}
Query {"String": "INSERT INTO drop_cols (id, f1, f2) VALUES (1, 1, 2)"}
Query {"String": "BEGIN"}
Parse {"Name": "s1", "Query": "SELECT * FROM drop_cols WHERE id = $1"}
Bind {"PreparedStatement": "s1", "Parameters": [{"text": "1"}]}
Execute
Sync
----

until ignore=NoticeResponse
ReadyForQuery
ReadyForQuery
ReadyForQuery
ReadyForQuery
ReadyForQuery
----
{"Type":"CommandComplete","CommandTag":"DROP TABLE"}
{"Type":"ReadyForQuery","TxStatus":"I"}
{"Type":"CommandComplete","CommandTag":"CREATE TABLE"}
{"Type":"ReadyForQuery","TxStatus":"I"}
{"Type":"CommandComplete","CommandTag":"INSERT 0 1"}
{"Type":"ReadyForQuery","TxStatus":"I"}
{"Type":"CommandComplete","CommandTag":"BEGIN"}
{"Type":"ReadyForQuery","TxStatus":"T"}
{"Type":"ParseComplete"}
{"Type":"BindComplete"}
{"Type":"DataRow","Values":[{"text":"1"},{"text":"1"},{"text":"2"}]}
{"Type":"CommandComplete","CommandTag":"SELECT 1"}
{"Type":"ReadyForQuery","TxStatus":"T"}

# Make a schema change that breaks the prepared statement.

send
Query {"String": "ALTER TABLE drop_cols DROP COLUMN f1"}
Bind {"PreparedStatement": "s1", "Parameters": [{"text": "1"}]}
Execute
Sync
----

until ignore=BindComplete
ReadyForQuery
ErrorResponse
ReadyForQuery
----
{"Type":"CommandComplete","CommandTag":"ALTER TABLE"}
{"Type":"ReadyForQuery","TxStatus":"T"}
{"Type":"ErrorResponse","Code":"0A000"}
{"Type":"ReadyForQuery","TxStatus":"E"}

# Parse should fail in an aborted transaction.

send
Parse {"Name": "s2", "Query": "SELECT * FROM drop_cols WHERE id = $1"}
Sync
----

until
ErrorResponse
ReadyForQuery
----
{"Type":"ErrorResponse","Code":"25P02"}
{"Type":"ReadyForQuery","TxStatus":"E"}

# Describe should fail in an aborted transaction.

send
Describe {"Name": "s1", "ObjectType": "S"}
Sync
----

until
ErrorResponse
ReadyForQuery
----
{"Type":"ErrorResponse","Code":"25P02"}
{"Type":"ReadyForQuery","TxStatus":"E"}

# Flush should *not* fail in an aborted transaction.

send
Flush
Sync
----

until
ReadyForQuery
----
{"Type":"ReadyForQuery","TxStatus":"E"}

# Bind should fail in an aborted transaction.

send
Bind {"PreparedStatement": "s1", "Parameters": [{"text": "1"}]}
Sync
----

until
ErrorResponse
ReadyForQuery
----
{"Type":"ErrorResponse","Code":"25P02"}
{"Type":"ReadyForQuery","TxStatus":"E"}

# Rollback the transaction, and make sure prepared statement works.

send
Query {"String": "ROLLBACK"}
Parse {"Name": "s3", "Query": "SELECT * FROM drop_cols WHERE id = $1"}
Bind {"PreparedStatement": "s3", "Parameters": [{"text": "1"}]}
Execute
Sync
----

until
ReadyForQuery
ReadyForQuery
----
{"Type":"CommandComplete","CommandTag":"ROLLBACK"}
{"Type":"ReadyForQuery","TxStatus":"I"}
{"Type":"ParseComplete"}
{"Type":"BindComplete"}
{"Type":"DataRow","Values":[{"text":"1"},{"text":"1"},{"text":"2"}]}
{"Type":"CommandComplete","CommandTag":"SELECT 1"}
{"Type":"ReadyForQuery","TxStatus":"I"}
