// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/types/types.proto

package types

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_lib_pq_oid "github.com/lib/pq/oid"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// See the comment header for the T.Family method for more details.
type Family int32

const (
	// BoolFamily is the family of boolean true/false types.
	//
	//   Canonical: types.Bool
	//   Oid      : T_bool
	//
	// Examples:
	//   BOOL
	//
	BoolFamily Family = 0
	// IntFamily is the family of signed integer types.
	//
	//   Canonical: types.Int
	//   Oid      : T_int8, T_int4, T_int2
	//   Width    : 64, 32, 16
	//
	// Examples:
	//   INT
	//   INT8
	//   INT4
	//
	IntFamily Family = 1
	// FloatFamily is the family of base-2 floating-point types (IEEE 754).
	//
	//   Canonical: types.Float
	//   Oid      : T_float8, T_float4
	//   Width    : 64, 32
	//
	// Examples:
	//   FLOAT8
	//   FLOAT4
	//
	FloatFamily Family = 2
	// DecimalFamily is the family of base-10 floating and fixed point types.
	//
	//   Canonical    : types.Decimal
	//   Oid          : T_numeric
	//   Precision    : max # decimal digits (0 = no specified limit)
	//   Width (Scale): # digits after decimal point (0 = no specified limit)
	//
	// Examples:
	//   DECIMAL
	//   DECIMAL(10)
	//   DECIMAL(10,3)
	//
	DecimalFamily Family = 3
	// DateFamily is the family of date types that store only year/month/day with
	// no time component.
	//
	//   Canonical: types.Date
	//   Oid      : T_date
	//
	// Examples:
	//   DATE
	//
	DateFamily Family = 4
	// TimestampFamily is the family of date types that store a year/month/day
	// date component, as well as an hour/minute/second time component. There is
	// no timezone component (see TIMESTAMPTZ). Seconds can have varying precision
	// (defaults to microsecond precision). Currently, only microsecond precision
	// is supported.
	//
	//   Canonical: types.Timestamp
	//   Oid      : T_timestamp
	//   Precision: fractional seconds (3 = ms, 0,6 = us, 9 = ns, etc.)
	//
	// Examples:
	//   TIMESTAMP
	//   TIMESTAMP(6)
	//
	TimestampFamily Family = 5
	// IntervalFamily is the family of types describing a duration of time.
	// Currently, only microsecond precision is supported.
	//
	//   Canonical: types.Interval
	//   Oid      : T_interval
	//
	// Examples:
	//   INTERVAL
	//
	IntervalFamily Family = 6
	// StringFamily is the family of types containing Unicode textual strings.
	// This family includes types constructed by STRING, VARCHAR, CHAR, and "char"
	// column type definitions (CHAR and "char" are distinct PG types). Note
	// that while STRING and VARCHAR have no default width limit, CHAR has a
	// default width of 1.
	// TODO(andyk): "char" should have default width of 1 as well, but doesn't.
	//
	//   Canonical: types.String
	//   Oid      : T_text, T_varchar, T_bpchar, T_char
	//   Width    : max # characters (0 = no specified limit)
	//
	// Examples:
	//   STRING
	//   TEXT
	//   VARCHAR(10)
	//   CHAR
	//
	StringFamily Family = 7
	// BytesFamily is the family of types containing a list of raw byte values.
	//
	//   Canonical: types.BYTES
	//   Oid      : T_bytea
	//
	// Examples:
	//   BYTES
	//
	BytesFamily Family = 8
	// TimestampTZFamily is the family of date types that store a year/month/day
	// date component, as well as an hour/minute/second time component, along with
	// a timezone. Seconds can have varying precision (defaults to microsecond
	// precision). Currently, only microsecond precision is supported.
	//
	//   Canonical: types.TimestampTZ
	//   Oid      : T_timestamptz
	//   Precision: fractional seconds (3 = ms, 0,6 = us, 9 = ns, etc.)
	//
	// Examples:
	//   TIMESTAMPTZ
	//   TIMESTAMPTZ(6)
	//
	TimestampTZFamily Family = 9
	// CollatedStringFamily is the family of types containing Unicode textual
	// strings with an associated COLLATE value that specifies the locale used
	// for various character-based operations such as sorting, pattern matching,
	// and builtin functions like lower and upper.
	//
	//   Oid      : T_text, T_varchar, T_bpchar, T_char
	//   Width    : max # characters (0 = no specified limit)
	//   Locale   : name of locale (e.g. EN or DE)
	//
	// Examples:
	//   STRING COLLATE en
	//   VARCHAR(10) COLLATE de
	//
	CollatedStringFamily Family = 10
	// OidFamily is the family of types containing Postgres Object ID (Oid)
	// values. Oids are integer values that identify some object in the database,
	// like a type, relation, or procedure.
	//
	//   Canonical: types.Oid
	//   Oid      : T_oid, T_regclass, T_regproc, T_regprocedure, T_regtype,
	//              T_regnamespace
	//
	// Examples:
	//   OID
	//   REGCLASS
	//   REGPROC
	//
	// TODO(andyk): Oids should be part of the IntFamily, since they are treated
	//              as equivalent to ints by PG.
	OidFamily Family = 12
	// UnknownFamily is a special type family that tags expressions that
	// statically evaluate to NULL. An UnknownFamily expression *must* be NULL.
	// But the inverse is not true, since other types allow NULL values as well.
	// UnknownFamily types are not supported as a table column type, but can be
	// transferred through DistSQL streams.
	//
	//   Canonical: types.Unknown
	//   Oid      : T_unknown
	//
	UnknownFamily Family = 13
	// UuidFamily is the family of types containing universally unique
	// identifiers. A UUID is a 128-bit quantity that is very unlikely to ever be
	// generated again, and so can be relied on to be distinct from all other UUID
	// values.
	//
	//   Canonical: types.Uuid
	//   Oid      : T_uuid
	//
	// Examples:
	//   UUID
	//
	UuidFamily Family = 14
	// ArrayFamily is a family of non-scalar types that contain an ordered list of
	// elements. The elements of an array must all share the same type. Elements
	// can have have any type, including ARRAY. However, while the types package
	// supports nested arrays, other parts of CRDB do not currently support them.
	// Also, the length of array dimension(s) are ignored by PG and CRDB (e.g.
	// an array of length 11 could be inserted into a column declared as INT[11]).
	//
	// Array OID values are special. Rather than having a single T_array OID,
	// Postgres defines a separate OID for each possible array element type.
	// Here are some examples:
	//
	//   T__int8: array of int8 values
	//   T__text: array of text values
	//
	// Notice that each array OID has double underscores to distinguish it from
	// the OID of the scalar type it contains.
	//
	//   Oid          : T__int, T__text, T__numeric, etc.
	//   ArrayContents: types.T of the array element type
	//
	// Examples:
	//   INT[]
	//   VARCHAR(10)[] COLLATE EN
	//   DECIMAL(10,1)[]
	//   TIMESTAMP[5]
	//
	ArrayFamily Family = 15
	// INetFamily is the family of types containing IPv4 or IPv6 network address
	// identifiers (e.g. 192.168.100.128/25 or FE80:CD00:0:CDE:1257:0:211E:729C).
	//
	//   Canonical: types.INet
	//   Oid      : T_inet
	//
	// Examples:
	//   INET
	//
	INetFamily Family = 16
	// TimeFamily is the family of date types that store only hour/minute/second
	// with no date component. There is no timezone component. Seconds can have
	// varying precision (defaults to microsecond precision). Currently, only
	// microsecond precision is supported.
	//
	//   Canonical: types.Time
	//   Oid      : T_time
	//   Precision: fractional seconds (3 = ms, 0,6 = us, 9 = ns, etc.)
	//
	// Examples:
	//   TIME
	//   TIME(6)
	//
	TimeFamily Family = 17
	// JsonFamily is the family of types containing JavaScript Object Notation
	// (JSON) values. Currently, CRDB only supports JSONB values, which are stored
	// in a decomposed binary format.
	//
	//   Canonical: types.Jsonb
	//   Oid      : T_jsonb
	//
	// Examples:
	//   JSON
	//   JSONB
	//
	JsonFamily Family = 18
	// TupleFamily is a family of non-scalar structural types that describes the
	// fields of a row or record. The fields can be of any type, including nested
	// tuple and array types. Fields can also have optional labels. Currently,
	// CRDB does not support tuple types as column types, but it is possible to
	// construct tuples using the ROW function or tuple construction syntax.
	//
	//   Oid          : T_record
	//   TupleContents: []types.T of each tuple field
	//   TupleLabels  : []string of each tuple label
	//
	// Examples:
	//   (1, 'foo')
	//   ((1, 'foo') AS num, str)
	//   ROW(1, 'foo')
	//   (ROW(1, 'foo') AS num, str)
	//
	TupleFamily Family = 20
	// BitFamily is the family of types containing ordered lists of bit values
	// (0 or 1). Note that while VARBIT has no default width limit, BIT has a
	// default width limit of 1.
	//
	//   Canonical: types.VarBit
	//   Oid      : T_varbit, T_bit
	//   Width    : max # of bits (0 = no specified limit)
	//
	// Examples:
	//   VARBIT
	//   VARBIT(10)
	//   BIT
	//   BIT(10)
	//
	BitFamily Family = 21
	// AnyFamily is a special type family used during static analysis as a
	// wildcard type that matches any other type, including scalar, array, and
	// tuple types. Execution-time values should never have this type. As an
	// example of its use, many SQL builtin functions allow an input value to be
	// of any type, and so use this type in their static definitions.
	//
	//   Canonical: types.Any
	//   Oid      : T_anyelement
	//
	AnyFamily Family = 100
)

var Family_name = map[int32]string{
	0:   "BoolFamily",
	1:   "IntFamily",
	2:   "FloatFamily",
	3:   "DecimalFamily",
	4:   "DateFamily",
	5:   "TimestampFamily",
	6:   "IntervalFamily",
	7:   "StringFamily",
	8:   "BytesFamily",
	9:   "TimestampTZFamily",
	10:  "CollatedStringFamily",
	12:  "OidFamily",
	13:  "UnknownFamily",
	14:  "UuidFamily",
	15:  "ArrayFamily",
	16:  "INetFamily",
	17:  "TimeFamily",
	18:  "JsonFamily",
	20:  "TupleFamily",
	21:  "BitFamily",
	100: "AnyFamily",
}
var Family_value = map[string]int32{
	"BoolFamily":           0,
	"IntFamily":            1,
	"FloatFamily":          2,
	"DecimalFamily":        3,
	"DateFamily":           4,
	"TimestampFamily":      5,
	"IntervalFamily":       6,
	"StringFamily":         7,
	"BytesFamily":          8,
	"TimestampTZFamily":    9,
	"CollatedStringFamily": 10,
	"OidFamily":            12,
	"UnknownFamily":        13,
	"UuidFamily":           14,
	"ArrayFamily":          15,
	"INetFamily":           16,
	"TimeFamily":           17,
	"JsonFamily":           18,
	"TupleFamily":          20,
	"BitFamily":            21,
	"AnyFamily":            100,
}

func (x Family) Enum() *Family {
	p := new(Family)
	*p = x
	return p
}
func (x Family) String() string {
	return proto.EnumName(Family_name, int32(x))
}
func (x *Family) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Family_value, data, "Family")
	if err != nil {
		return err
	}
	*x = Family(value)
	return nil
}
func (Family) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_0cfd95d968502097, []int{0}
}

// InternalType is the protobuf encoding for SQL types. It is always wrapped by
// a T struct, and should never be used directly by outside packages. See the
// comment header for the T struct for more details.
type InternalType struct {
	// Family specifies a group of types that are compatible with one another.
	// See the header for the T.Family method for more details.
	Family Family `protobuf:"varint,1,opt,name=family,enum=cockroach.sql.sem.types.Family" json:"family"`
	// Width is the size or scale of the type, such as number of bits or
	// characters. See the T.Width method for more details.
	Width int32 `protobuf:"varint,2,opt,name=width" json:"width"`
	// Precision is the accuracy of the data type. See the T.Precision method for
	// more details. This field was also by FLOAT pre-2.1 (this was incorrect.)
	Precision int32 `protobuf:"varint,3,opt,name=precision" json:"precision"`
	// ArrayDimensions is deprecated in 19.2, since it was never used. It
	// previously contained the length of each dimension in the array. A
	// dimension of -1 meant that no bound was specified for that dimension. If
	// arrayDimensions was nil, then the array had one unbounded dimension.
	ArrayDimensions []int32 `protobuf:"varint,4,rep,name=array_dimensions,json=arrayDimensions" json:"array_dimensions,omitempty"`
	// Locale identifies a specific geographical, political, or cultural region that
	// impacts various character-based operations such as sorting, pattern matching,
	// and builtin functions like lower and upper. See the T.Locale method for
	// more details.
	Locale *string `protobuf:"bytes,5,opt,name=locale" json:"locale,omitempty"`
	// VisibleType is deprecated in 19.2, since it is now superseded by the Oid
	// field. It previously contained an alias for any types where our internal
	// representation is different than the user specification. Examples are INT4,
	// FLOAT4, etc. Mostly for Postgres compatibility.
	VisibleType int32 `protobuf:"varint,6,opt,name=visible_type,json=visibleType" json:"visible_type"`
	// ArrayElemType is deprecated in 19.2, since it is now superseded by the
	// ArrayContents field. It previously contained the type family of array
	// elements. The other array fields (width/precision/locale/etc) were used
	// to store the other attributes of the array's element type.
	ArrayElemType *Family `protobuf:"varint,7,opt,name=array_elem_type,json=arrayElemType,enum=cockroach.sql.sem.types.Family" json:"array_elem_type,omitempty"`
	// TupleContents returns a slice containing the type of each tuple field. This
	// is nil for non-TUPLE types.
	TupleContents []T `protobuf:"bytes,8,rep,name=tuple_contents,json=tupleContents,customtype=T" json:"tuple_contents"`
	// TupleLabels returns a slice containing the labels of each tuple field. This
	// is nil for non-TUPLE types, or if the TUPLE type does not specify labels.
	TupleLabels []string `protobuf:"bytes,9,rep,name=tuple_labels,json=tupleLabels" json:"tuple_labels,omitempty"`
	// Oid returns the type's Postgres Object ID. See the header for the T.Oid
	// method for more details.
	Oid github_com_lib_pq_oid.Oid `protobuf:"varint,10,opt,name=oid,customtype=github.com/lib/pq/oid.Oid" json:"oid"`
	// ArrayContents returns the type of array elements. This is nil for non-ARRAY
	// types.
	ArrayContents *T `protobuf:"bytes,11,opt,name=array_contents,json=arrayContents,customtype=T" json:"array_contents,omitempty"`
}

func (m *InternalType) Reset()         { *m = InternalType{} }
func (m *InternalType) String() string { return proto.CompactTextString(m) }
func (*InternalType) ProtoMessage()    {}
func (*InternalType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_0cfd95d968502097, []int{0}
}
func (m *InternalType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InternalType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalType.Merge(dst, src)
}
func (m *InternalType) XXX_Size() int {
	return m.Size()
}
func (m *InternalType) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalType.DiscardUnknown(m)
}

var xxx_messageInfo_InternalType proto.InternalMessageInfo

func init() {
	proto.RegisterType((*InternalType)(nil), "cockroach.sql.sem.types.InternalType")
	proto.RegisterEnum("cockroach.sql.sem.types.Family", Family_name, Family_value)
}
func (m *InternalType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Family))
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Width))
	dAtA[i] = 0x18
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Precision))
	if len(m.ArrayDimensions) > 0 {
		for _, num := range m.ArrayDimensions {
			dAtA[i] = 0x20
			i++
			i = encodeVarintTypes(dAtA, i, uint64(num))
		}
	}
	if m.Locale != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.Locale)))
		i += copy(dAtA[i:], *m.Locale)
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.VisibleType))
	if m.ArrayElemType != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.ArrayElemType))
	}
	if len(m.TupleContents) > 0 {
		for _, msg := range m.TupleContents {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TupleLabels) > 0 {
		for _, s := range m.TupleLabels {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x50
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Oid))
	if m.ArrayContents != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ArrayContents.Size()))
		n1, err := m.ArrayContents.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *InternalType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Family))
	n += 1 + sovTypes(uint64(m.Width))
	n += 1 + sovTypes(uint64(m.Precision))
	if len(m.ArrayDimensions) > 0 {
		for _, e := range m.ArrayDimensions {
			n += 1 + sovTypes(uint64(e))
		}
	}
	if m.Locale != nil {
		l = len(*m.Locale)
		n += 1 + l + sovTypes(uint64(l))
	}
	n += 1 + sovTypes(uint64(m.VisibleType))
	if m.ArrayElemType != nil {
		n += 1 + sovTypes(uint64(*m.ArrayElemType))
	}
	if len(m.TupleContents) > 0 {
		for _, e := range m.TupleContents {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TupleLabels) > 0 {
		for _, s := range m.TupleLabels {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	n += 1 + sovTypes(uint64(m.Oid))
	if m.ArrayContents != nil {
		l = m.ArrayContents.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InternalType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (Family(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArrayDimensions = append(m.ArrayDimensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArrayDimensions) == 0 {
					m.ArrayDimensions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArrayDimensions = append(m.ArrayDimensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayDimensions", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Locale = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleType", wireType)
			}
			m.VisibleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VisibleType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayElemType", wireType)
			}
			var v Family
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Family(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArrayElemType = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TupleContents", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v T
			m.TupleContents = append(m.TupleContents, v)
			if err := m.TupleContents[len(m.TupleContents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TupleLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TupleLabels = append(m.TupleLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (github_com_lib_pq_oid.Oid(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayContents", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v T
			m.ArrayContents = &v
			if err := m.ArrayContents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sql/types/types.proto", fileDescriptor_types_0cfd95d968502097) }

var fileDescriptor_types_0cfd95d968502097 = []byte{
	// 639 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xcf, 0x4e, 0xdb, 0x4a,
	0x14, 0xc6, 0x33, 0xf8, 0x0f, 0xf1, 0xc4, 0x49, 0xcc, 0x00, 0xf7, 0xfa, 0xb2, 0x70, 0x7c, 0xb3,
	0xc1, 0xf7, 0xaa, 0x72, 0xaa, 0x2e, 0x2b, 0x75, 0x81, 0xa1, 0x54, 0x54, 0x55, 0x91, 0xdc, 0xb0,
	0x61, 0x13, 0x39, 0xf6, 0x34, 0x8c, 0x18, 0x7b, 0x8c, 0x3d, 0x80, 0xb2, 0xec, 0xae, 0xcb, 0x3e,
	0x40, 0x77, 0x7d, 0x99, 0xb0, 0x63, 0x89, 0xba, 0x40, 0x6d, 0x78, 0x91, 0x6a, 0xec, 0x71, 0x4a,
	0x17, 0x95, 0xba, 0x89, 0xf2, 0xfd, 0xce, 0x39, 0xdf, 0xf9, 0x4e, 0x32, 0x70, 0xbb, 0xbc, 0xa0,
	0x23, 0x3e, 0xcf, 0x71, 0x59, 0x7f, 0xfa, 0x79, 0xc1, 0x38, 0x43, 0x7f, 0xc7, 0x2c, 0x3e, 0x2f,
	0x58, 0x14, 0x9f, 0xf9, 0xe5, 0x05, 0xf5, 0x4b, 0x9c, 0xfa, 0x55, 0x79, 0x67, 0x6b, 0xc6, 0x66,
	0xac, 0xea, 0x19, 0x89, 0x6f, 0x75, 0xfb, 0xf0, 0x83, 0x0a, 0xcd, 0xa3, 0x8c, 0xe3, 0x22, 0x8b,
	0xe8, 0x78, 0x9e, 0x63, 0xf4, 0x02, 0xea, 0xef, 0xa3, 0x94, 0xd0, 0xb9, 0x0d, 0x5c, 0xe0, 0xf5,
	0x9e, 0x0d, 0xfc, 0xdf, 0x18, 0xfa, 0x87, 0x55, 0x5b, 0xa0, 0x2e, 0xee, 0x07, 0xad, 0x50, 0x0e,
	0xa1, 0x1d, 0xa8, 0x5d, 0x93, 0x84, 0x9f, 0xd9, 0x6b, 0x2e, 0xf0, 0x34, 0x59, 0xac, 0x11, 0x1a,
	0x42, 0x23, 0x2f, 0x70, 0x4c, 0x4a, 0xc2, 0x32, 0x5b, 0x79, 0x54, 0xff, 0x89, 0xd1, 0x7f, 0xd0,
	0x8a, 0x8a, 0x22, 0x9a, 0x4f, 0x12, 0x92, 0xe2, 0x4c, 0xa0, 0xd2, 0x56, 0x5d, 0xc5, 0xd3, 0xc2,
	0x7e, 0xc5, 0x0f, 0x56, 0x18, 0xfd, 0x05, 0x75, 0xca, 0xe2, 0x88, 0x62, 0x5b, 0x73, 0x81, 0x67,
	0x84, 0x52, 0xa1, 0x5d, 0x68, 0x5e, 0x91, 0x92, 0x4c, 0x29, 0x9e, 0x88, 0xa0, 0xb6, 0xfe, 0x68,
	0x53, 0x47, 0x56, 0xaa, 0x53, 0x5f, 0xc1, 0xda, 0x73, 0x82, 0x29, 0x4e, 0xeb, 0xde, 0xf5, 0x3f,
	0xba, 0x39, 0xec, 0x56, 0x73, 0x2f, 0x29, 0x4e, 0x2b, 0xa3, 0xa7, 0xb0, 0xc7, 0x2f, 0x73, 0x8a,
	0x27, 0x31, 0xcb, 0x38, 0xce, 0x78, 0x69, 0xb7, 0x5d, 0xc5, 0x33, 0x03, 0x43, 0xec, 0xfc, 0x7a,
	0x3f, 0x00, 0xe3, 0xb0, 0x5b, 0x35, 0xec, 0xcb, 0x3a, 0xfa, 0x17, 0x9a, 0xf5, 0x04, 0x8d, 0xa6,
	0x98, 0x96, 0xb6, 0xe1, 0x2a, 0x9e, 0x11, 0x76, 0x2a, 0xf6, 0xa6, 0x42, 0xe8, 0x39, 0x54, 0x18,
	0x49, 0x6c, 0xe8, 0x02, 0xaf, 0x1b, 0x78, 0xd2, 0xe9, 0x9f, 0x19, 0xe1, 0x67, 0x97, 0x53, 0x3f,
	0x66, 0xe9, 0x88, 0x92, 0xe9, 0x28, 0xbf, 0x18, 0x31, 0x92, 0xf8, 0xc7, 0x24, 0x59, 0xde, 0x0f,
	0x94, 0x63, 0x92, 0x84, 0x62, 0x08, 0x3d, 0x81, 0xbd, 0xfa, 0xb2, 0x55, 0xa0, 0x8e, 0x0b, 0x3c,
	0x33, 0xd0, 0x64, 0x98, 0xaa, 0xd8, 0x84, 0xf9, 0xff, 0xb3, 0x02, 0xf5, 0xfa, 0x30, 0xd4, 0x83,
	0x30, 0x60, 0x8c, 0xd6, 0xca, 0x6a, 0xa1, 0x2e, 0x34, 0x8e, 0x32, 0x2e, 0x25, 0x40, 0x7d, 0xd8,
	0x39, 0xa4, 0x2c, 0x6a, 0xc0, 0x1a, 0xda, 0x80, 0xdd, 0x03, 0x1c, 0x93, 0x34, 0x6a, 0x46, 0x14,
	0x61, 0x71, 0x10, 0x71, 0x2c, 0xb5, 0x8a, 0x36, 0x61, 0x7f, 0x4c, 0x52, 0x5c, 0xf2, 0x28, 0xcd,
	0x25, 0xd4, 0x10, 0x82, 0xbd, 0xea, 0xd5, 0x5d, 0xad, 0x06, 0x75, 0x64, 0x41, 0xf3, 0x1d, 0x2f,
	0x48, 0x36, 0x93, 0x64, 0x5d, 0xac, 0x0b, 0xe6, 0x1c, 0x97, 0x12, 0xb4, 0xd1, 0x36, 0xdc, 0x58,
	0x79, 0x8d, 0x4f, 0x25, 0x36, 0x90, 0x0d, 0xb7, 0xf6, 0x19, 0xa5, 0x11, 0xc7, 0xc9, 0x2f, 0x0e,
	0x50, 0xe4, 0x3f, 0x26, 0x89, 0x94, 0xa6, 0x88, 0x7b, 0x92, 0x9d, 0x67, 0xec, 0x3a, 0x93, 0xa8,
	0x2b, 0xe2, 0x9e, 0x5c, 0xae, 0x5a, 0x7a, 0x62, 0xe7, 0x9e, 0xf8, 0x75, 0x24, 0xe8, 0x8b, 0x86,
	0xa3, 0xb7, 0xb8, 0x39, 0xd9, 0x12, 0x5a, 0x64, 0x90, 0x7a, 0x43, 0xe8, 0xd7, 0x25, 0x6b, 0x0c,
	0x91, 0x30, 0x18, 0x8b, 0xbf, 0x51, 0x82, 0x2d, 0x91, 0x21, 0x20, 0xcd, 0xfc, 0xb6, 0x90, 0x7b,
	0x59, 0x63, 0x9f, 0xec, 0xa8, 0x1f, 0xbf, 0x38, 0xad, 0xa1, 0xda, 0xee, 0x58, 0x9d, 0xa1, 0xda,
	0xde, 0xb4, 0x36, 0x87, 0x7a, 0x7b, 0x01, 0xac, 0x05, 0x18, 0xea, 0xed, 0x1b, 0x60, 0xdd, 0x80,
	0x60, 0x77, 0xf1, 0xdd, 0x69, 0x2d, 0x96, 0x0e, 0xb8, 0x5d, 0x3a, 0xe0, 0x6e, 0xe9, 0x80, 0x6f,
	0x4b, 0x07, 0x7c, 0x7a, 0x70, 0x5a, 0xb7, 0x0f, 0x4e, 0xeb, 0xee, 0xc1, 0x69, 0x9d, 0x6a, 0xd5,
	0xe3, 0xfc, 0x11, 0x00, 0x00, 0xff, 0xff, 0xc5, 0x43, 0xc5, 0xfc, 0x12, 0x04, 0x00, 0x00,
}
