// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/types/types.proto

package types

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import geopb "github.com/cockroachdb/cockroach/pkg/geo/geopb"

import github_com_cockroachdb_cockroach_pkg_geo_geopb "github.com/cockroachdb/cockroach/pkg/geo/geopb"
import github_com_lib_pq_oid "github.com/lib/pq/oid"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// See the comment header for the T.Family method for more details.
type Family int32

const (
	// BoolFamily is the family of boolean true/false types.
	//
	//   Canonical: types.Bool
	//   Oid      : T_bool
	//
	// Examples:
	//   BOOL
	//
	BoolFamily Family = 0
	// IntFamily is the family of signed integer types.
	//
	//   Canonical: types.Int
	//   Oid      : T_int8, T_int4, T_int2
	//   Width    : 64, 32, 16
	//
	// Examples:
	//   INT
	//   INT8
	//   INT4
	//
	IntFamily Family = 1
	// FloatFamily is the family of base-2 floating-point types (IEEE 754).
	//
	//   Canonical: types.Float
	//   Oid      : T_float8, T_float4
	//   Width    : 64, 32
	//
	// Examples:
	//   FLOAT8
	//   FLOAT4
	//
	FloatFamily Family = 2
	// DecimalFamily is the family of base-10 floating and fixed point types.
	//
	//   Canonical    : types.Decimal
	//   Oid          : T_numeric
	//   Precision    : max # decimal digits (0 = no specified limit)
	//   Width (Scale): # digits after decimal point (0 = no specified limit)
	//
	// Examples:
	//   DECIMAL
	//   DECIMAL(10)
	//   DECIMAL(10,3)
	//
	DecimalFamily Family = 3
	// DateFamily is the family of date types that store only year/month/day with
	// no time component.
	//
	//   Canonical: types.Date
	//   Oid      : T_date
	//
	// Examples:
	//   DATE
	//
	DateFamily Family = 4
	// TimestampFamily is the family of date types that store a year/month/day
	// date component, as well as an hour/minute/second time component. There is
	// no timezone component (see TIMESTAMPTZ). Seconds can have varying precision
	// (defaults to microsecond precision). Currently, only microsecond precision
	// is supported.
	//
	//   Canonical: types.Timestamp
	//   Oid      : T_timestamp
	//   Precision: fractional seconds (3 = ms, 0,6 = us, 9 = ns, etc.)
	//
	// Examples:
	//   TIMESTAMP
	//   TIMESTAMP(6)
	//
	TimestampFamily Family = 5
	// IntervalFamily is the family of types describing a duration of time.
	// Currently, only microsecond precision is supported.
	//
	//   Canonical: types.Interval
	//   Oid      : T_interval
	//
	// Examples:
	//   INTERVAL
	//
	IntervalFamily Family = 6
	// StringFamily is the family of types containing Unicode textual strings.
	// This family includes types constructed by STRING, VARCHAR, CHAR, and "char"
	// column type definitions (CHAR and "char" are distinct PG types). Note
	// that while STRING and VARCHAR have no default width limit, CHAR has a
	// default width of 1.
	// TODO(andyk): "char" should have default width of 1 as well, but doesn't.
	//
	//   Canonical: types.String
	//   Oid      : T_text, T_varchar, T_bpchar, T_char
	//   Width    : max # characters (0 = no specified limit)
	//
	// Examples:
	//   STRING
	//   TEXT
	//   VARCHAR(10)
	//   CHAR
	//
	StringFamily Family = 7
	// BytesFamily is the family of types containing a list of raw byte values.
	//
	//   Canonical: types.BYTES
	//   Oid      : T_bytea
	//
	// Examples:
	//   BYTES
	//
	BytesFamily Family = 8
	// TimestampTZFamily is the family of date types that store a year/month/day
	// date component, as well as an hour/minute/second time component, along with
	// a timezone. Seconds can have varying precision (defaults to microsecond
	// precision). Currently, only microsecond precision is supported.
	//
	//   Canonical: types.TimestampTZ
	//   Oid      : T_timestamptz
	//   Precision: fractional seconds (3 = ms, 0,6 = us, 9 = ns, etc.)
	//
	// Examples:
	//   TIMESTAMPTZ
	//   TIMESTAMPTZ(6)
	//
	TimestampTZFamily Family = 9
	// CollatedStringFamily is the family of types containing Unicode textual
	// strings with an associated COLLATE value that specifies the locale used
	// for various character-based operations such as sorting, pattern matching,
	// and builtin functions like lower and upper.
	//
	//   Oid      : T_text, T_varchar, T_bpchar, T_char
	//   Width    : max # characters (0 = no specified limit)
	//   Locale   : name of locale (e.g. EN or DE)
	//
	// Examples:
	//   STRING COLLATE en
	//   VARCHAR(10) COLLATE de
	//
	CollatedStringFamily Family = 10
	// OidFamily is the family of types containing Postgres Object ID (Oid)
	// values. Oids are integer values that identify some object in the database,
	// like a type, relation, or procedure.
	//
	//   Canonical: types.Oid
	//   Oid      : T_oid, T_regclass, T_regproc, T_regprocedure, T_regtype,
	//              T_regnamespace
	//
	// Examples:
	//   OID
	//   REGCLASS
	//   REGPROC
	//
	// TODO(andyk): Oids should be part of the IntFamily, since they are treated
	//              as equivalent to ints by PG.
	OidFamily Family = 12
	// UnknownFamily is a special type family that tags expressions that
	// statically evaluate to NULL. An UnknownFamily expression *must* be NULL.
	// But the inverse is not true, since other types allow NULL values as well.
	// UnknownFamily types are not supported as a table column type, but can be
	// transferred through DistSQL streams.
	//
	//   Canonical: types.Unknown
	//   Oid      : T_unknown
	//
	UnknownFamily Family = 13
	// UuidFamily is the family of types containing universally unique
	// identifiers. A UUID is a 128-bit quantity that is very unlikely to ever be
	// generated again, and so can be relied on to be distinct from all other UUID
	// values.
	//
	//   Canonical: types.Uuid
	//   Oid      : T_uuid
	//
	// Examples:
	//   UUID
	//
	UuidFamily Family = 14
	// ArrayFamily is a family of non-scalar types that contain an ordered list of
	// elements. The elements of an array must all share the same type. Elements
	// can have have any type, including ARRAY. However, while the types package
	// supports nested arrays, other parts of CRDB do not currently support them.
	// Also, the length of array dimension(s) are ignored by PG and CRDB (e.g.
	// an array of length 11 could be inserted into a column declared as INT[11]).
	//
	// Array OID values are special. Rather than having a single T_array OID,
	// Postgres defines a separate OID for each possible array element type.
	// Here are some examples:
	//
	//   T__int8: array of int8 values
	//   T__text: array of text values
	//
	// Notice that each array OID has double underscores to distinguish it from
	// the OID of the scalar type it contains.
	//
	//   Oid          : T__int, T__text, T__numeric, etc.
	//   ArrayContents: types.T of the array element type
	//
	// Examples:
	//   INT[]
	//   VARCHAR(10)[] COLLATE EN
	//   DECIMAL(10,1)[]
	//   TIMESTAMP[5]
	//
	ArrayFamily Family = 15
	// INetFamily is the family of types containing IPv4 or IPv6 network address
	// identifiers (e.g. 192.168.100.128/25 or FE80:CD00:0:CDE:1257:0:211E:729C).
	//
	//   Canonical: types.INet
	//   Oid      : T_inet
	//
	// Examples:
	//   INET
	//
	INetFamily Family = 16
	// TimeFamily is the family of date types that store only hour/minute/second
	// with no date component. There is no timezone component. Seconds can have
	// varying precision (defaults to microsecond precision). Currently, only
	// microsecond precision is supported.
	//
	//   Canonical: types.Time
	//   Oid      : T_time
	//   Precision: fractional seconds (3 = ms, 0,6 = us, 9 = ns, etc.)
	//
	// Examples:
	//   TIME
	//   TIME(6)
	//
	TimeFamily Family = 17
	// JsonFamily is the family of types containing JavaScript Object Notation
	// (JSON) values. Currently, CRDB only supports JSONB values, which are stored
	// in a decomposed binary format.
	//
	//   Canonical: types.Jsonb
	//   Oid      : T_jsonb
	//
	// Examples:
	//   JSON
	//   JSONB
	//
	JsonFamily Family = 18
	// TimeTZFamily is the family of date types that store only hour/minute/second
	// and timestamp components, with no date component. Seconds can have
	// varying precision (defaults to microsecond precision). Currently, only
	// microsecond precision is supported.
	//
	//   Canonical: types.TimeTZ
	//   Oid      : T_timetz
	//   Precision: fractional seconds (3 = ms, 0,6 = us, 9 = ns, etc.)
	//
	// Examples:
	//   TIMETZ
	//
	TimeTZFamily Family = 19
	// TupleFamily is a family of non-scalar structural types that describes the
	// fields of a row or record. The fields can be of any type, including nested
	// tuple and array types. Fields can also have optional labels. Currently,
	// CRDB does not support tuple types as column types, but it is possible to
	// construct tuples using the ROW function or tuple construction syntax.
	//
	//   Oid          : T_record
	//   TupleContents: []*types.T of each tuple field
	//   TupleLabels  : []string of each tuple label
	//
	// Examples:
	//   (1, 'foo')
	//   ((1, 'foo') AS num, str)
	//   ROW(1, 'foo')
	//   (ROW(1, 'foo') AS num, str)
	//
	TupleFamily Family = 20
	// BitFamily is the family of types containing ordered lists of bit values
	// (0 or 1). Note that while VARBIT has no default width limit, BIT has a
	// default width limit of 1.
	//
	//   Canonical: types.VarBit
	//   Oid      : T_varbit, T_bit
	//   Width    : max # of bits (0 = no specified limit)
	//
	// Examples:
	//   VARBIT
	//   VARBIT(10)
	//   BIT
	//   BIT(10)
	//
	BitFamily Family = 21
	// GeometryFamily is a family that supports the Geometry geospatial type,
	// which is compatible with PostGIS's Geometry implementation.
	//
	//   Canonical: types.Geometry
	//   Oid      : oidext.T_geometry
	//
	// Examples:
	//   GEOMETRY
	//   GEOMETRY(LINESTRING)
	//   GEOMETRY(LINESTRING, SRID)
	GeometryFamily Family = 22
	// GeographyFamily is a family that supports the Geography geospatial type,
	// which is compatible with PostGIS's Geography implementation.
	//
	//   Canonical: types.Geography
	//   Oid      : oidext.T_geography
	//
	// Examples:
	//   GEOGRAPHY
	//   GEOGRAPHY(LINESTRING)
	//   GEOGRAPHY(LINESTRING, SRID)
	GeographyFamily Family = 23
	// EnumFamily is a family that represents all ENUM types. ENUM types
	// have data about the ENUM defined in a TypeDescriptor. The ID of
	// the TypeDescriptor that backs this ENUM is stored in the StableTypeID
	// field. It does not have a canonical form.
	EnumFamily Family = 24
	// AnyFamily is a special type family used during static analysis as a
	// wildcard type that matches any other type, including scalar, array, and
	// tuple types. Execution-time values should never have this type. As an
	// example of its use, many SQL builtin functions allow an input value to be
	// of any type, and so use this type in their static definitions.
	//
	//   Canonical: types.Any
	//   Oid      : T_anyelement
	//
	AnyFamily Family = 100
)

var Family_name = map[int32]string{
	0:   "BoolFamily",
	1:   "IntFamily",
	2:   "FloatFamily",
	3:   "DecimalFamily",
	4:   "DateFamily",
	5:   "TimestampFamily",
	6:   "IntervalFamily",
	7:   "StringFamily",
	8:   "BytesFamily",
	9:   "TimestampTZFamily",
	10:  "CollatedStringFamily",
	12:  "OidFamily",
	13:  "UnknownFamily",
	14:  "UuidFamily",
	15:  "ArrayFamily",
	16:  "INetFamily",
	17:  "TimeFamily",
	18:  "JsonFamily",
	19:  "TimeTZFamily",
	20:  "TupleFamily",
	21:  "BitFamily",
	22:  "GeometryFamily",
	23:  "GeographyFamily",
	24:  "EnumFamily",
	100: "AnyFamily",
}
var Family_value = map[string]int32{
	"BoolFamily":           0,
	"IntFamily":            1,
	"FloatFamily":          2,
	"DecimalFamily":        3,
	"DateFamily":           4,
	"TimestampFamily":      5,
	"IntervalFamily":       6,
	"StringFamily":         7,
	"BytesFamily":          8,
	"TimestampTZFamily":    9,
	"CollatedStringFamily": 10,
	"OidFamily":            12,
	"UnknownFamily":        13,
	"UuidFamily":           14,
	"ArrayFamily":          15,
	"INetFamily":           16,
	"TimeFamily":           17,
	"JsonFamily":           18,
	"TimeTZFamily":         19,
	"TupleFamily":          20,
	"BitFamily":            21,
	"GeometryFamily":       22,
	"GeographyFamily":      23,
	"EnumFamily":           24,
	"AnyFamily":            100,
}

func (x Family) Enum() *Family {
	p := new(Family)
	*p = x
	return p
}
func (x Family) String() string {
	return proto.EnumName(Family_name, int32(x))
}
func (x *Family) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Family_value, data, "Family")
	if err != nil {
		return err
	}
	*x = Family(value)
	return nil
}
func (Family) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_dabb43d64e136a7a, []int{0}
}

// IntervalDurationType represents a duration that can be used
// when defining an Interval Duration Field.
// See https://www.postgresql.org/docs/current/datatype-datetime.html.
type IntervalDurationType int32

const (
	// UNSET defaults to SECOND during evaluation.
	// This indicates no typmod.
	IntervalDurationType_UNSET  IntervalDurationType = 0
	IntervalDurationType_YEAR   IntervalDurationType = 1
	IntervalDurationType_MONTH  IntervalDurationType = 2
	IntervalDurationType_DAY    IntervalDurationType = 3
	IntervalDurationType_HOUR   IntervalDurationType = 4
	IntervalDurationType_MINUTE IntervalDurationType = 5
	// SECOND is the only unit where precision can be added.
	IntervalDurationType_SECOND IntervalDurationType = 6
	// MILLISECOND is not technically part of the SQL standard for intervals, but we
	// provide it as a field to allow code to parse intervals with a default unit
	// of milliseconds, which is useful for some internal use cases like
	// statement_timeout.
	IntervalDurationType_MILLISECOND IntervalDurationType = 7
)

var IntervalDurationType_name = map[int32]string{
	0: "UNSET",
	1: "YEAR",
	2: "MONTH",
	3: "DAY",
	4: "HOUR",
	5: "MINUTE",
	6: "SECOND",
	7: "MILLISECOND",
}
var IntervalDurationType_value = map[string]int32{
	"UNSET":       0,
	"YEAR":        1,
	"MONTH":       2,
	"DAY":         3,
	"HOUR":        4,
	"MINUTE":      5,
	"SECOND":      6,
	"MILLISECOND": 7,
}

func (x IntervalDurationType) Enum() *IntervalDurationType {
	p := new(IntervalDurationType)
	*p = x
	return p
}
func (x IntervalDurationType) String() string {
	return proto.EnumName(IntervalDurationType_name, int32(x))
}
func (x *IntervalDurationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IntervalDurationType_value, data, "IntervalDurationType")
	if err != nil {
		return err
	}
	*x = IntervalDurationType(value)
	return nil
}
func (IntervalDurationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_dabb43d64e136a7a, []int{1}
}

// IntervalDurationField represents precisions in intervals which are
// outside of the regular time precision syntax.
// i.e. instead of INTERVAL(6), we can have INTERVAL SECOND(6), INTERVAL MONTH, etc.
// This is represented as a bitmask on the first 4 bits of precision in postgres.
type IntervalDurationField struct {
	// DurationType is the unit of measurement in which durations
	// should truncate themselves to.
	// This (unlike precision) gets truncated downward.
	DurationType IntervalDurationType `protobuf:"varint,1,opt,name=duration_type,json=durationType,enum=cockroach.sql.sem.types.IntervalDurationType" json:"duration_type"`
	// FromDurationType is the left side of the "duration field".
	// i.e. in the `DurationType_1 TO DurationType_2` syntax, this represents `DurationType_1`.
	// Note this is ignored, see https://www.postgresql.org/message-id/20110510040219.GD5617%40tornado.gateway.2wire.net.
	FromDurationType IntervalDurationType `protobuf:"varint,2,opt,name=from_duration_type,json=fromDurationType,enum=cockroach.sql.sem.types.IntervalDurationType" json:"from_duration_type"`
}

func (m *IntervalDurationField) Reset()         { *m = IntervalDurationField{} }
func (m *IntervalDurationField) String() string { return proto.CompactTextString(m) }
func (*IntervalDurationField) ProtoMessage()    {}
func (*IntervalDurationField) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_dabb43d64e136a7a, []int{0}
}
func (m *IntervalDurationField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntervalDurationField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *IntervalDurationField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntervalDurationField.Merge(dst, src)
}
func (m *IntervalDurationField) XXX_Size() int {
	return m.Size()
}
func (m *IntervalDurationField) XXX_DiscardUnknown() {
	xxx_messageInfo_IntervalDurationField.DiscardUnknown(m)
}

var xxx_messageInfo_IntervalDurationField proto.InternalMessageInfo

// GeoMetadata contains metadata associated with Geospatial data types.
type GeoMetadata struct {
	SRID  github_com_cockroachdb_cockroach_pkg_geo_geopb.SRID `protobuf:"varint,1,opt,name=srid,casttype=github.com/cockroachdb/cockroach/pkg/geo/geopb.SRID" json:"srid"`
	Shape geopb.Shape                                         `protobuf:"varint,2,opt,name=shape,enum=cockroach.geopb.Shape" json:"shape"`
}

func (m *GeoMetadata) Reset()         { *m = GeoMetadata{} }
func (m *GeoMetadata) String() string { return proto.CompactTextString(m) }
func (*GeoMetadata) ProtoMessage()    {}
func (*GeoMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_dabb43d64e136a7a, []int{1}
}
func (m *GeoMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *GeoMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoMetadata.Merge(dst, src)
}
func (m *GeoMetadata) XXX_Size() int {
	return m.Size()
}
func (m *GeoMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GeoMetadata proto.InternalMessageInfo

func (m *T) Reset()      { *m = T{} }
func (*T) ProtoMessage() {}
func (*T) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_dabb43d64e136a7a, []int{2}
}
func (m *T) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_T.Unmarshal(m, b)
}
func (m *T) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_T.Marshal(b, m, deterministic)
}
func (dst *T) XXX_Merge(src proto.Message) {
	xxx_messageInfo_T.Merge(dst, src)
}
func (m *T) XXX_Size() int {
	return xxx_messageInfo_T.Size(m)
}
func (m *T) XXX_DiscardUnknown() {
	xxx_messageInfo_T.DiscardUnknown(m)
}

var xxx_messageInfo_T proto.InternalMessageInfo

// InternalType is the protobuf encoding for SQL types. It is always wrapped by
// a T struct, and should never be used directly by outside packages. See the
// comment header for the T struct for more details.
type InternalType struct {
	// Family specifies a group of types that are compatible with one another.
	// See the header for the T.Family method for more details.
	Family Family `protobuf:"varint,1,opt,name=family,enum=cockroach.sql.sem.types.Family" json:"family"`
	// Width is the size or scale of the type, such as number of bits or
	// characters. See the T.Width method for more details.
	Width int32 `protobuf:"varint,2,opt,name=width" json:"width"`
	// Precision is the accuracy of the data type. See the T.Precision method for
	// more details. This field was also by FLOAT pre-2.1 (this was incorrect.)
	Precision int32 `protobuf:"varint,3,opt,name=precision" json:"precision"`
	// ArrayDimensions is deprecated in 19.2, since it was never used. It
	// previously contained the length of each dimension in the array. A
	// dimension of -1 meant that no bound was specified for that dimension. If
	// arrayDimensions was nil, then the array had one unbounded dimension.
	ArrayDimensions []int32 `protobuf:"varint,4,rep,name=array_dimensions,json=arrayDimensions" json:"array_dimensions,omitempty"`
	// Locale identifies a specific geographical, political, or cultural region that
	// impacts various character-based operations such as sorting, pattern matching,
	// and builtin functions like lower and upper. See the T.Locale method for
	// more details.
	Locale *string `protobuf:"bytes,5,opt,name=locale" json:"locale,omitempty"`
	// VisibleType is deprecated in 19.2, since it is now superseded by the Oid
	// field. It previously contained an alias for any types where our internal
	// representation is different than the user specification. Examples are INT4,
	// FLOAT4, etc. Mostly for Postgres compatibility.
	VisibleType int32 `protobuf:"varint,6,opt,name=visible_type,json=visibleType" json:"visible_type"`
	// ArrayElemType is deprecated in 19.2, since it is now superseded by the
	// ArrayContents field. It previously contained the type family of array
	// elements. The other array fields (width/precision/locale/etc) were used
	// to store the other attributes of the array's element type.
	ArrayElemType *Family `protobuf:"varint,7,opt,name=array_elem_type,json=arrayElemType,enum=cockroach.sql.sem.types.Family" json:"array_elem_type,omitempty"`
	// TupleContents returns a slice containing the type of each tuple field. This
	// is nil for non-TUPLE types.
	TupleContents []*T `protobuf:"bytes,8,rep,name=tuple_contents,json=tupleContents" json:"tuple_contents,omitempty"`
	// TupleLabels returns a slice containing the labels of each tuple field. This
	// is nil for non-TUPLE types, or if the TUPLE type does not specify labels.
	TupleLabels []string `protobuf:"bytes,9,rep,name=tuple_labels,json=tupleLabels" json:"tuple_labels,omitempty"`
	// Oid returns the type's Postgres Object ID. See the header for the T.Oid
	// method for more details. For user-defined types, the OID value is an
	// offset (oidext.CockroachPredefinedOIDMax) away from the stable_type_id
	// field. This makes it easy to retrieve a type descriptor by OID.
	Oid github_com_lib_pq_oid.Oid `protobuf:"varint,10,opt,name=oid,customtype=github.com/lib/pq/oid.Oid" json:"oid"`
	// ArrayContents returns the type of array elements. This is nil for non-ARRAY
	// types.
	ArrayContents *T `protobuf:"bytes,11,opt,name=array_contents,json=arrayContents" json:"array_contents,omitempty"`
	// TimePrecisionIsSet indicates whether the precision was explicitly set.
	// It is currently in use for the TIME-related families and INTERVALs
	// where a Precision of 0 indicated the default precision of 6
	// in versions pre-20.1.
	// The rules for Precision to use are as follows:
	//   * If Precision is > 0, then that is the precision.
	//   * If Precision is 0, it will default to 6 if TimePrecisionIsSet is false
	//    (for compatibility reasons).
	//   * Otherwise, Precision = 0 and TimePrecisionIsSet = true, so it is
	//     actually 0.
	TimePrecisionIsSet bool `protobuf:"varint,12,opt,name=time_precision_is_set,json=timePrecisionIsSet" json:"time_precision_is_set"`
	// IntervalDurationField is populated for intervals, representing extra
	// typmod or precision data that may be required.
	IntervalDurationField *IntervalDurationField `protobuf:"bytes,13,opt,name=interval_duration_field,json=intervalDurationField" json:"interval_duration_field,omitempty"`
	// GeoMetadata is populated for geospatial types.
	GeoMetadata *GeoMetadata `protobuf:"bytes,14,opt,name=geo_metadata,json=geoMetadata" json:"geo_metadata,omitempty"`
	// StableTypeID is the ID of the backing TypeDescriptor for this type.
	// StableTypeID is set only for User Defined Types.
	StableTypeID uint32 `protobuf:"varint,15,opt,name=stable_type_id,json=stableTypeId" json:"stable_type_id"`
	// StableArrayTypeID is the ID of the TypeDescriptor that defines the backs
	// the automatically generated array type for this type. StableArrayTypeID
	// is only set for user defined types that aren't arrays.
	StableArrayTypeID uint32 `protobuf:"varint,16,opt,name=stable_array_type_id,json=stableArrayTypeId" json:"stable_array_type_id"`
}

func (m *InternalType) Reset()         { *m = InternalType{} }
func (m *InternalType) String() string { return proto.CompactTextString(m) }
func (*InternalType) ProtoMessage()    {}
func (*InternalType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_dabb43d64e136a7a, []int{3}
}
func (m *InternalType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InternalType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalType.Merge(dst, src)
}
func (m *InternalType) XXX_Size() int {
	return m.Size()
}
func (m *InternalType) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalType.DiscardUnknown(m)
}

var xxx_messageInfo_InternalType proto.InternalMessageInfo

func init() {
	proto.RegisterType((*IntervalDurationField)(nil), "cockroach.sql.sem.types.IntervalDurationField")
	proto.RegisterType((*GeoMetadata)(nil), "cockroach.sql.sem.types.GeoMetadata")
	proto.RegisterType((*T)(nil), "cockroach.sql.sem.types.T")
	proto.RegisterType((*InternalType)(nil), "cockroach.sql.sem.types.InternalType")
	proto.RegisterEnum("cockroach.sql.sem.types.Family", Family_name, Family_value)
	proto.RegisterEnum("cockroach.sql.sem.types.IntervalDurationType", IntervalDurationType_name, IntervalDurationType_value)
}
func (m *IntervalDurationField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalDurationField) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.DurationType))
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.FromDurationType))
	return i, nil
}

func (m *GeoMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.SRID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Shape))
	return i, nil
}

func (m *InternalType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Family))
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Width))
	dAtA[i] = 0x18
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Precision))
	if len(m.ArrayDimensions) > 0 {
		for _, num := range m.ArrayDimensions {
			dAtA[i] = 0x20
			i++
			i = encodeVarintTypes(dAtA, i, uint64(num))
		}
	}
	if m.Locale != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.Locale)))
		i += copy(dAtA[i:], *m.Locale)
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.VisibleType))
	if m.ArrayElemType != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.ArrayElemType))
	}
	if len(m.TupleContents) > 0 {
		for _, msg := range m.TupleContents {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TupleLabels) > 0 {
		for _, s := range m.TupleLabels {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x50
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Oid))
	if m.ArrayContents != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ArrayContents.Size()))
		n1, err := m.ArrayContents.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	dAtA[i] = 0x60
	i++
	if m.TimePrecisionIsSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.IntervalDurationField != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IntervalDurationField.Size()))
		n2, err := m.IntervalDurationField.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.GeoMetadata != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.GeoMetadata.Size()))
		n3, err := m.GeoMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	dAtA[i] = 0x78
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.StableTypeID))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.StableArrayTypeID))
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IntervalDurationField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.DurationType))
	n += 1 + sovTypes(uint64(m.FromDurationType))
	return n
}

func (m *GeoMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.SRID))
	n += 1 + sovTypes(uint64(m.Shape))
	return n
}

func (m *InternalType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Family))
	n += 1 + sovTypes(uint64(m.Width))
	n += 1 + sovTypes(uint64(m.Precision))
	if len(m.ArrayDimensions) > 0 {
		for _, e := range m.ArrayDimensions {
			n += 1 + sovTypes(uint64(e))
		}
	}
	if m.Locale != nil {
		l = len(*m.Locale)
		n += 1 + l + sovTypes(uint64(l))
	}
	n += 1 + sovTypes(uint64(m.VisibleType))
	if m.ArrayElemType != nil {
		n += 1 + sovTypes(uint64(*m.ArrayElemType))
	}
	if len(m.TupleContents) > 0 {
		for _, e := range m.TupleContents {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TupleLabels) > 0 {
		for _, s := range m.TupleLabels {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	n += 1 + sovTypes(uint64(m.Oid))
	if m.ArrayContents != nil {
		l = m.ArrayContents.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	n += 2
	if m.IntervalDurationField != nil {
		l = m.IntervalDurationField.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GeoMetadata != nil {
		l = m.GeoMetadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	n += 1 + sovTypes(uint64(m.StableTypeID))
	n += 2 + sovTypes(uint64(m.StableArrayTypeID))
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IntervalDurationField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntervalDurationField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntervalDurationField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationType", wireType)
			}
			m.DurationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationType |= (IntervalDurationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromDurationType", wireType)
			}
			m.FromDurationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromDurationType |= (IntervalDurationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SRID", wireType)
			}
			m.SRID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SRID |= (github_com_cockroachdb_cockroach_pkg_geo_geopb.SRID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			m.Shape = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shape |= (geopb.Shape(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (Family(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArrayDimensions = append(m.ArrayDimensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArrayDimensions) == 0 {
					m.ArrayDimensions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArrayDimensions = append(m.ArrayDimensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayDimensions", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Locale = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleType", wireType)
			}
			m.VisibleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VisibleType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayElemType", wireType)
			}
			var v Family
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Family(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArrayElemType = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TupleContents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TupleContents = append(m.TupleContents, &T{})
			if err := m.TupleContents[len(m.TupleContents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TupleLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TupleLabels = append(m.TupleLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (github_com_lib_pq_oid.Oid(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayContents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArrayContents == nil {
				m.ArrayContents = &T{}
			}
			if err := m.ArrayContents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimePrecisionIsSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimePrecisionIsSet = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalDurationField", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntervalDurationField == nil {
				m.IntervalDurationField = &IntervalDurationField{}
			}
			if err := m.IntervalDurationField.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoMetadata == nil {
				m.GeoMetadata = &GeoMetadata{}
			}
			if err := m.GeoMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableTypeID", wireType)
			}
			m.StableTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StableTypeID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableArrayTypeID", wireType)
			}
			m.StableArrayTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StableArrayTypeID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sql/types/types.proto", fileDescriptor_types_dabb43d64e136a7a) }

var fileDescriptor_types_dabb43d64e136a7a = []byte{
	// 1077 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x26, 0xa3, 0x0f, 0x4b, 0xa3, 0x0f, 0xd3, 0x1b, 0xc9, 0x66, 0x7c, 0x10, 0xf5, 0x0a, 0x6f,
	0x11, 0x35, 0x40, 0x25, 0xc0, 0x3d, 0x14, 0x30, 0xd0, 0x83, 0x65, 0xc9, 0x8e, 0x02, 0xdb, 0x0a,
	0x28, 0x19, 0x6d, 0x72, 0x11, 0x56, 0xe2, 0x5a, 0x5e, 0x98, 0xe4, 0xca, 0xe4, 0x3a, 0x81, 0xff,
	0x81, 0x8f, 0x39, 0xb6, 0x3d, 0xd9, 0xe8, 0x9f, 0x71, 0x6e, 0x39, 0xf4, 0x10, 0xf4, 0x60, 0x34,
	0xf2, 0x1f, 0xe8, 0xb9, 0xa7, 0x62, 0x97, 0x4b, 0x59, 0x09, 0xe2, 0x20, 0xe8, 0x45, 0xe0, 0x3c,
	0x33, 0xf3, 0xcc, 0x33, 0xb3, 0xbb, 0x23, 0x28, 0x87, 0xa7, 0x6e, 0x93, 0x9f, 0x4f, 0x49, 0x18,
	0xfd, 0x36, 0xa6, 0x01, 0xe3, 0x0c, 0xad, 0x8d, 0xd9, 0xf8, 0x24, 0x60, 0x78, 0x7c, 0xdc, 0x08,
	0x4f, 0xdd, 0x46, 0x48, 0xbc, 0x86, 0x74, 0xaf, 0x97, 0x26, 0x6c, 0xc2, 0x64, 0x4c, 0x53, 0x7c,
	0x45, 0xe1, 0xeb, 0xe5, 0x09, 0x61, 0xcd, 0x09, 0x61, 0xd3, 0x51, 0xf4, 0x1b, 0xc1, 0xb5, 0x3f,
	0x74, 0x28, 0x77, 0x7d, 0x4e, 0x82, 0x57, 0xd8, 0x6d, 0x9f, 0x05, 0x98, 0x53, 0xe6, 0xef, 0x50,
	0xe2, 0x3a, 0xe8, 0x67, 0x28, 0x38, 0x0a, 0x18, 0x0a, 0x62, 0x53, 0xaf, 0xea, 0xf5, 0xe2, 0xc6,
	0x77, 0x8d, 0x7b, 0xea, 0x36, 0x3e, 0xa5, 0x19, 0x9c, 0x4f, 0x49, 0x2b, 0x79, 0x7d, 0x63, 0x69,
	0x76, 0xde, 0x59, 0xc0, 0x10, 0x06, 0x74, 0x14, 0x30, 0x6f, 0xf8, 0x31, 0xfd, 0x83, 0xff, 0x4e,
	0x6f, 0x08, 0xba, 0x45, 0xbc, 0xf6, 0x9b, 0x0e, 0xb9, 0x5d, 0xc2, 0xf6, 0x09, 0xc7, 0x0e, 0xe6,
	0x18, 0xfd, 0x04, 0xc9, 0x30, 0xa0, 0x8e, 0xec, 0x21, 0xd5, 0xda, 0x16, 0x59, 0xb3, 0x1b, 0x2b,
	0xd9, 0xb7, 0xbb, 0xed, 0x7f, 0x6e, 0xac, 0xef, 0x27, 0x94, 0x1f, 0x9f, 0x8d, 0x1a, 0x63, 0xe6,
	0x35, 0xe7, 0xe5, 0x9d, 0xd1, 0xdd, 0x77, 0x73, 0x7a, 0x32, 0x69, 0xce, 0x07, 0xd8, 0x10, 0x69,
	0xb6, 0x24, 0x44, 0x1b, 0x90, 0x0a, 0x8f, 0xf1, 0x5c, 0xfe, 0xea, 0x82, 0x7c, 0x15, 0x2b, 0xbc,
	0x4a, 0x67, 0x14, 0x5a, 0x63, 0xa0, 0x0f, 0xd0, 0x73, 0x28, 0x50, 0xd1, 0x91, 0x8f, 0xdd, 0xbb,
	0xf1, 0xe6, 0x36, 0xbe, 0xf9, 0x72, 0xff, 0x3e, 0x76, 0x17, 0xc7, 0x4a, 0x17, 0xb0, 0x4d, 0xf3,
	0xe2, 0xd2, 0xd2, 0x7e, 0xb9, 0xb4, 0xb4, 0x8b, 0x2b, 0x4b, 0x7b, 0x73, 0x65, 0x69, 0x97, 0x57,
	0x96, 0xf6, 0xf7, 0x95, 0xa5, 0xd5, 0x7e, 0x5d, 0x82, 0xfc, 0x62, 0x3a, 0xfa, 0x11, 0xd2, 0x47,
	0xd8, 0xa3, 0xee, 0xb9, 0x3a, 0x54, 0xeb, 0xde, 0xaa, 0x3b, 0x32, 0x4c, 0xd5, 0x53, 0x49, 0x68,
	0x1d, 0x52, 0xaf, 0xa9, 0xc3, 0x8f, 0x65, 0xd3, 0xa9, 0xb8, 0x39, 0x09, 0xa1, 0x1a, 0x64, 0xa7,
	0x01, 0x19, 0xd3, 0x90, 0x32, 0xdf, 0x4c, 0x2c, 0xf8, 0xef, 0x60, 0xf4, 0x2d, 0x18, 0x38, 0x08,
	0xf0, 0xf9, 0xd0, 0xa1, 0x1e, 0xf1, 0x05, 0x14, 0x9a, 0xc9, 0x6a, 0xa2, 0x9e, 0xb2, 0x97, 0x25,
	0xde, 0x9e, 0xc3, 0x68, 0x15, 0xd2, 0x2e, 0x1b, 0x63, 0x97, 0x98, 0xa9, 0xaa, 0x5e, 0xcf, 0xda,
	0xca, 0x42, 0x8f, 0x21, 0xff, 0x8a, 0x86, 0x74, 0xe4, 0x92, 0x68, 0x7a, 0xe9, 0x85, 0x4a, 0x39,
	0xe5, 0x91, 0xad, 0xee, 0x42, 0xc4, 0x39, 0x24, 0x2e, 0xf1, 0xa2, 0xd8, 0xa5, 0xaf, 0xea, 0xd9,
	0x2e, 0xc8, 0xbc, 0x8e, 0x4b, 0x3c, 0x49, 0xb4, 0x05, 0x45, 0x7e, 0x36, 0x75, 0xc9, 0x70, 0xcc,
	0x7c, 0x4e, 0x7c, 0x1e, 0x9a, 0x99, 0x6a, 0xa2, 0x9e, 0xdb, 0x58, 0xbf, 0x97, 0x67, 0x60, 0x17,
	0x64, 0xc6, 0xb6, 0x4a, 0x40, 0xff, 0x83, 0x7c, 0x44, 0xe1, 0xe2, 0x11, 0x71, 0x43, 0x33, 0x5b,
	0x4d, 0xd4, 0xb3, 0x76, 0x4e, 0x62, 0x7b, 0x12, 0x42, 0x9b, 0x90, 0x60, 0xd4, 0x31, 0xa1, 0xaa,
	0xd7, 0x0b, 0xad, 0xba, 0x68, 0xe7, 0xcf, 0x1b, 0xeb, 0xd1, 0xc2, 0xfd, 0x74, 0xe9, 0xa8, 0x39,
	0x3d, 0x6d, 0x32, 0xea, 0x34, 0x7a, 0xd4, 0x99, 0xdd, 0x58, 0x89, 0x1e, 0x75, 0x6c, 0x91, 0x24,
	0x14, 0x46, 0xad, 0xce, 0x15, 0xe6, 0xe4, 0x9d, 0xfa, 0xa2, 0x42, 0x99, 0x31, 0x57, 0xf8, 0x03,
	0x94, 0x39, 0xf5, 0xc8, 0x70, 0x7e, 0x56, 0x43, 0x1a, 0x0e, 0x43, 0xc2, 0xcd, 0x7c, 0x55, 0xaf,
	0x67, 0xd4, 0x7c, 0x91, 0x08, 0x79, 0x1e, 0x47, 0x74, 0xc3, 0x3e, 0xe1, 0xe8, 0x08, 0xd6, 0xa8,
	0x7a, 0xa0, 0x77, 0xef, 0xfa, 0x48, 0x2c, 0x12, 0xb3, 0x20, 0x45, 0x34, 0xbe, 0xfa, 0x61, 0xcb,
	0xf5, 0x63, 0x97, 0xe9, 0x67, 0xb7, 0xd2, 0x2e, 0xe4, 0x27, 0x84, 0x0d, 0x3d, 0xf5, 0xb0, 0xcd,
	0xa2, 0x24, 0xff, 0xff, 0xbd, 0xe4, 0x0b, 0x4b, 0xc0, 0xce, 0x4d, 0x16, 0x36, 0xc2, 0x26, 0x14,
	0x43, 0x8e, 0xe3, 0xfb, 0x33, 0xa4, 0x8e, 0xb9, 0x2c, 0x67, 0x5e, 0x52, 0xbb, 0x21, 0xdf, 0x97,
	0x5e, 0x71, 0xf4, 0xdd, 0xb6, 0x9d, 0x0f, 0xef, 0x2c, 0x07, 0x3d, 0x83, 0x92, 0xca, 0x8d, 0xe6,
	0x1d, 0x33, 0x18, 0x92, 0xe1, 0x91, 0x62, 0x58, 0x89, 0x18, 0xb6, 0x44, 0x88, 0xa2, 0x59, 0x09,
	0x3f, 0x81, 0x9c, 0x27, 0x1f, 0x12, 0x90, 0x8e, 0x2e, 0x1c, 0x2a, 0x02, 0xb4, 0x18, 0x73, 0x23,
	0xcb, 0xd0, 0x50, 0x01, 0xb2, 0x5d, 0x9f, 0x2b, 0x53, 0x47, 0xcb, 0x90, 0xdb, 0x71, 0x19, 0x8e,
	0x81, 0x07, 0x68, 0x05, 0x0a, 0x6d, 0x32, 0xa6, 0x1e, 0x8e, 0x53, 0x12, 0x82, 0xa2, 0x8d, 0x39,
	0x51, 0x76, 0x12, 0x3d, 0x84, 0xe5, 0x01, 0xf5, 0x48, 0xc8, 0xb1, 0x37, 0x55, 0x60, 0x0a, 0x21,
	0x28, 0xc6, 0x33, 0x57, 0x58, 0x1a, 0x19, 0x90, 0xef, 0xf3, 0x80, 0xfa, 0x13, 0x85, 0x2c, 0x89,
	0x72, 0xad, 0x73, 0x4e, 0x42, 0x05, 0x64, 0x50, 0x19, 0x56, 0xe6, 0x5c, 0x83, 0x97, 0x0a, 0xce,
	0x22, 0x13, 0x4a, 0xdb, 0xcc, 0x75, 0x31, 0x27, 0xce, 0x47, 0x0c, 0x20, 0xf4, 0xf7, 0xa8, 0xa3,
	0xcc, 0xbc, 0x90, 0x7b, 0xe8, 0x9f, 0xf8, 0xec, 0xb5, 0xaf, 0xa0, 0x82, 0x90, 0x7b, 0x78, 0x36,
	0x0f, 0x29, 0x8a, 0x9a, 0x72, 0x36, 0x0a, 0x58, 0x16, 0x01, 0xdd, 0x03, 0x12, 0xb7, 0x6c, 0x08,
	0x5b, 0x68, 0x50, 0xf6, 0x8a, 0xb0, 0x9f, 0x85, 0x2c, 0x26, 0x44, 0xa2, 0x0d, 0xe1, 0x9f, 0xcb,
	0x7b, 0x28, 0x28, 0x07, 0xe2, 0x7d, 0x29, 0xa0, 0x24, 0x54, 0xb5, 0x68, 0xcc, 0x58, 0x16, 0xc3,
	0xd8, 0x25, 0xcc, 0x23, 0x3c, 0x88, 0xab, 0xae, 0x8a, 0xa9, 0xed, 0x12, 0x36, 0x09, 0xf0, 0xf4,
	0x38, 0x06, 0xd7, 0x44, 0xa9, 0x8e, 0x7f, 0xe6, 0x29, 0xdb, 0x14, 0x3c, 0x5b, 0x7e, 0xec, 0x76,
	0xd6, 0x93, 0x17, 0xbf, 0x57, 0xb4, 0x5a, 0x32, 0x93, 0x33, 0x72, 0xb5, 0x74, 0xe6, 0x5a, 0x37,
	0xae, 0xf5, 0x5a, 0x3a, 0xf3, 0x56, 0x37, 0xde, 0xea, 0x4f, 0x02, 0x28, 0x7d, 0xee, 0xdf, 0x0b,
	0x65, 0x21, 0x75, 0x78, 0xd0, 0xef, 0x0c, 0x0c, 0x0d, 0x65, 0x20, 0xf9, 0xa2, 0xb3, 0x65, 0x1b,
	0xba, 0x00, 0xf7, 0x7b, 0x07, 0x83, 0xa7, 0xc6, 0x03, 0xb4, 0x04, 0x89, 0xf6, 0xd6, 0x0b, 0x23,
	0x21, 0xbc, 0x4f, 0x7b, 0x87, 0xb6, 0x91, 0x44, 0x00, 0xe9, 0xfd, 0xee, 0xc1, 0xe1, 0xa0, 0x63,
	0xa4, 0xc4, 0x77, 0xbf, 0xb3, 0xdd, 0x3b, 0x68, 0x1b, 0x69, 0xd1, 0xe6, 0x7e, 0x77, 0x6f, 0xaf,
	0xab, 0x80, 0xa5, 0xd6, 0xe3, 0xeb, 0x0f, 0x15, 0xed, 0x7a, 0x56, 0xd1, 0xdf, 0xcd, 0x2a, 0xfa,
	0xfb, 0x59, 0x45, 0xff, 0x6b, 0x56, 0xd1, 0xdf, 0xdc, 0x56, 0xb4, 0x77, 0xb7, 0x15, 0xed, 0xfd,
	0x6d, 0x45, 0x7b, 0x99, 0x92, 0x2f, 0xe4, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd4, 0xfe, 0x06,
	0x53, 0x5f, 0x08, 0x00, 0x00,
}
