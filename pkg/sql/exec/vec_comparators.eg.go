// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package exec

import (
	"bytes"
	"fmt"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

type BoolVecComparator struct {
	vecs  [][]bool
	nulls []*coldata.Nulls
}

func (c *BoolVecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	cmp = tree.CompareBools(left, right)
	return cmp
}

func (c *BoolVecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Bool()
	c.nulls[idx] = vec.Nulls()
}

func (c *BoolVecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

type BytesVecComparator struct {
	vecs  [][][]byte
	nulls []*coldata.Nulls
}

func (c *BytesVecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	cmp = bytes.Compare(left, right)
	return cmp
}

func (c *BytesVecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Bytes()
	c.nulls[idx] = vec.Nulls()
}

func (c *BytesVecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

type DecimalVecComparator struct {
	vecs  [][]apd.Decimal
	nulls []*coldata.Nulls
}

func (c *DecimalVecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	cmp = tree.CompareDecimals(&left, &right)
	return cmp
}

func (c *DecimalVecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Decimal()
	c.nulls[idx] = vec.Nulls()
}

func (c *DecimalVecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

type Int8VecComparator struct {
	vecs  [][]int8
	nulls []*coldata.Nulls
}

func (c *Int8VecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	if left < right {
		cmp = -1
	} else if left > right {
		cmp = 1
	} else {
		cmp = 0
	}
	return cmp
}

func (c *Int8VecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Int8()
	c.nulls[idx] = vec.Nulls()
}

func (c *Int8VecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

type Int16VecComparator struct {
	vecs  [][]int16
	nulls []*coldata.Nulls
}

func (c *Int16VecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	if left < right {
		cmp = -1
	} else if left > right {
		cmp = 1
	} else {
		cmp = 0
	}
	return cmp
}

func (c *Int16VecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Int16()
	c.nulls[idx] = vec.Nulls()
}

func (c *Int16VecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

type Int32VecComparator struct {
	vecs  [][]int32
	nulls []*coldata.Nulls
}

func (c *Int32VecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	if left < right {
		cmp = -1
	} else if left > right {
		cmp = 1
	} else {
		cmp = 0
	}
	return cmp
}

func (c *Int32VecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Int32()
	c.nulls[idx] = vec.Nulls()
}

func (c *Int32VecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

type Int64VecComparator struct {
	vecs  [][]int64
	nulls []*coldata.Nulls
}

func (c *Int64VecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	if left < right {
		cmp = -1
	} else if left > right {
		cmp = 1
	} else {
		cmp = 0
	}
	return cmp
}

func (c *Int64VecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Int64()
	c.nulls[idx] = vec.Nulls()
}

func (c *Int64VecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

type Float32VecComparator struct {
	vecs  [][]float32
	nulls []*coldata.Nulls
}

func (c *Float32VecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	cmp = compareFloats(float64(left), float64(right))
	return cmp
}

func (c *Float32VecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Float32()
	c.nulls[idx] = vec.Nulls()
}

func (c *Float32VecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

type Float64VecComparator struct {
	vecs  [][]float64
	nulls []*coldata.Nulls
}

func (c *Float64VecComparator) compare(vecIdx1, vecIdx2 int, valIdx1, valIdx2 uint16) int {
	n1 := c.nulls[vecIdx1].MaybeHasNulls() && c.nulls[vecIdx1].NullAt(valIdx1)
	n2 := c.nulls[vecIdx2].MaybeHasNulls() && c.nulls[vecIdx2].NullAt(valIdx2)
	if n1 && n2 {
		return 0
	} else if n1 {
		return -1
	} else if n2 {
		return 1
	}
	left := c.vecs[vecIdx1][valIdx1]
	right := c.vecs[vecIdx2][valIdx2]
	var cmp int
	cmp = compareFloats(float64(left), float64(right))
	return cmp
}

func (c *Float64VecComparator) setVec(idx int, vec coldata.Vec) {
	c.vecs[idx] = vec.Float64()
	c.nulls[idx] = vec.Nulls()
}

func (c *Float64VecComparator) set(srcVecIdx, dstVecIdx int, srcIdx, dstIdx uint16) {
	if c.nulls[srcVecIdx].MaybeHasNulls() && c.nulls[srcVecIdx].NullAt(srcIdx) {
		c.nulls[dstVecIdx].SetNull(dstIdx)
	} else {
		c.nulls[dstVecIdx].UnsetNull(dstIdx)
		c.vecs[dstVecIdx][dstIdx] = c.vecs[srcVecIdx][srcIdx]
	}
}

func GetVecComparator(t types.T, numVecs int) vecComparator {
	switch t {
	case types.Bool:
		return &BoolVecComparator{
			vecs:  make([][]bool, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	case types.Bytes:
		return &BytesVecComparator{
			vecs:  make([][][]byte, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	case types.Decimal:
		return &DecimalVecComparator{
			vecs:  make([][]apd.Decimal, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	case types.Int8:
		return &Int8VecComparator{
			vecs:  make([][]int8, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	case types.Int16:
		return &Int16VecComparator{
			vecs:  make([][]int16, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	case types.Int32:
		return &Int32VecComparator{
			vecs:  make([][]int32, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	case types.Int64:
		return &Int64VecComparator{
			vecs:  make([][]int64, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	case types.Float32:
		return &Float32VecComparator{
			vecs:  make([][]float32, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	case types.Float64:
		return &Float64VecComparator{
			vecs:  make([][]float64, numVecs),
			nulls: make([]*coldata.Nulls, numVecs),
		}
	}
	panic(fmt.Sprintf("unhandled type %v", t))
}
