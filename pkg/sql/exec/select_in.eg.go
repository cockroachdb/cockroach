// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package exec

import (
	"bytes"
	"context"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types/conv"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	semtypes "github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/pkg/errors"
)

// Enum used to represent comparison results
type comparisonResult int

const (
	siTrue comparisonResult = iota
	siFalse
	siNull
)

func GetInProjectionOperator(
	ct *semtypes.T, input Operator, colIdx int, resultIdx int, datumTuple *tree.DTuple, negate bool,
) (Operator, error) {
	var err error
	switch t := conv.FromColumnType(ct); t {
	case types.Bool:
		obj := &projectInOpBool{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBool(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Bytes:
		obj := &projectInOpBytes{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBytes(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Decimal:
		obj := &projectInOpDecimal{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowDecimal(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int8:
		obj := &projectInOpInt8{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt8(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int16:
		obj := &projectInOpInt16{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt16(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int32:
		obj := &projectInOpInt32{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt32(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int64:
		obj := &projectInOpInt64{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Float32:
		obj := &projectInOpFloat32{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowFloat32(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Float64:
		obj := &projectInOpFloat64{
			input:     input,
			colIdx:    colIdx,
			outputIdx: resultIdx,
			negate:    negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowFloat64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	default:
		return nil, errors.Errorf("unhandled type: %s", t)
	}
}

func GetInOperator(
	ct *semtypes.T, input Operator, colIdx int, datumTuple *tree.DTuple, negate bool,
) (Operator, error) {
	var err error
	switch t := conv.FromColumnType(ct); t {
	case types.Bool:
		obj := &selectInOpBool{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBool(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Bytes:
		obj := &selectInOpBytes{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBytes(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Decimal:
		obj := &selectInOpDecimal{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowDecimal(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int8:
		obj := &selectInOpInt8{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt8(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int16:
		obj := &selectInOpInt16{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt16(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int32:
		obj := &selectInOpInt32{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt32(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int64:
		obj := &selectInOpInt64{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Float32:
		obj := &selectInOpFloat32{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowFloat32(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Float64:
		obj := &selectInOpFloat64{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowFloat64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	default:
		return nil, errors.Errorf("unhandled type: %s", t)
	}
}

type selectInOpBool struct {
	input     Operator
	colIdx    int
	filterRow []bool
	hasNulls  bool
	negate    bool
}

type projectInOpBool struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow []bool
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpBool{}

func (p *projectInOpBool) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowBool(ct *semtypes.T, datumTuple *tree.DTuple) ([]bool, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []bool
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(bool)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInBool(target bool, filterRow []bool, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = tree.CompareBools(target, filterRow[i]) == 0
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBool) Init() {
	si.input.Init()
}

func (pi *projectInOpBool) Init() {
	pi.input.Init()
}

func (si *selectInOpBool) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bool()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInBool(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInBool(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInBool(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInBool(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpBool) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Bool()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInBool(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInBool(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInBool(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInBool(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpBytes struct {
	input     Operator
	colIdx    int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
}

type projectInOpBytes struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpBytes{}

func (p *projectInOpBytes) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowBytes(ct *semtypes.T, datumTuple *tree.DTuple) ([][]byte, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result [][]byte
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.([]byte)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInBytes(target []byte, filterRow [][]byte, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = bytes.Compare(target, filterRow[i]) == 0
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBytes) Init() {
	si.input.Init()
}

func (pi *projectInOpBytes) Init() {
	pi.input.Init()
}

func (si *selectInOpBytes) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bytes()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInBytes(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInBytes(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInBytes(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInBytes(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpBytes) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Bytes()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInBytes(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInBytes(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInBytes(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInBytes(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpDecimal struct {
	input     Operator
	colIdx    int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
}

type projectInOpDecimal struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpDecimal{}

func (p *projectInOpDecimal) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowDecimal(ct *semtypes.T, datumTuple *tree.DTuple) ([]apd.Decimal, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []apd.Decimal
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(apd.Decimal)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInDecimal(target apd.Decimal, filterRow []apd.Decimal, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = tree.CompareDecimals(&target, &filterRow[i]) == 0
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpDecimal) Init() {
	si.input.Init()
}

func (pi *projectInOpDecimal) Init() {
	pi.input.Init()
}

func (si *selectInOpDecimal) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInDecimal(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInDecimal(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInDecimal(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInDecimal(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpDecimal) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Decimal()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInDecimal(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInDecimal(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInDecimal(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInDecimal(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt8 struct {
	input     Operator
	colIdx    int
	filterRow []int8
	hasNulls  bool
	negate    bool
}

type projectInOpInt8 struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow []int8
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpInt8{}

func (p *projectInOpInt8) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowInt8(ct *semtypes.T, datumTuple *tree.DTuple) ([]int8, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []int8
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int8)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt8(target int8, filterRow []int8, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = target == filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt8) Init() {
	si.input.Init()
}

func (pi *projectInOpInt8) Init() {
	pi.input.Init()
}

func (si *selectInOpInt8) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInInt8(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInInt8(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInInt8(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInInt8(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt8) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int8()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInInt8(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInInt8(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInInt8(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInInt8(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt16 struct {
	input     Operator
	colIdx    int
	filterRow []int16
	hasNulls  bool
	negate    bool
}

type projectInOpInt16 struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow []int16
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpInt16{}

func (p *projectInOpInt16) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowInt16(ct *semtypes.T, datumTuple *tree.DTuple) ([]int16, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []int16
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int16)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt16(target int16, filterRow []int16, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = target == filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt16) Init() {
	si.input.Init()
}

func (pi *projectInOpInt16) Init() {
	pi.input.Init()
}

func (si *selectInOpInt16) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInInt16(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInInt16(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInInt16(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInInt16(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt16) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int16()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInInt16(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInInt16(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInInt16(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInInt16(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt32 struct {
	input     Operator
	colIdx    int
	filterRow []int32
	hasNulls  bool
	negate    bool
}

type projectInOpInt32 struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow []int32
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpInt32{}

func (p *projectInOpInt32) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowInt32(ct *semtypes.T, datumTuple *tree.DTuple) ([]int32, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []int32
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int32)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt32(target int32, filterRow []int32, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = target == filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt32) Init() {
	si.input.Init()
}

func (pi *projectInOpInt32) Init() {
	pi.input.Init()
}

func (si *selectInOpInt32) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInInt32(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInInt32(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInInt32(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInInt32(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt32) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int32()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInInt32(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInInt32(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInInt32(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInInt32(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt64 struct {
	input     Operator
	colIdx    int
	filterRow []int64
	hasNulls  bool
	negate    bool
}

type projectInOpInt64 struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow []int64
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpInt64{}

func (p *projectInOpInt64) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowInt64(ct *semtypes.T, datumTuple *tree.DTuple) ([]int64, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []int64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int64)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt64(target int64, filterRow []int64, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = target == filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt64) Init() {
	si.input.Init()
}

func (pi *projectInOpInt64) Init() {
	pi.input.Init()
}

func (si *selectInOpInt64) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInInt64(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInInt64(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInInt64(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInInt64(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt64) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int64()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInInt64(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInInt64(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInInt64(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInInt64(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpFloat32 struct {
	input     Operator
	colIdx    int
	filterRow []float32
	hasNulls  bool
	negate    bool
}

type projectInOpFloat32 struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow []float32
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpFloat32{}

func (p *projectInOpFloat32) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowFloat32(ct *semtypes.T, datumTuple *tree.DTuple) ([]float32, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []float32
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(float32)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInFloat32(target float32, filterRow []float32, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = compareFloats(float64(target), float64(filterRow[i])) == 0
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpFloat32) Init() {
	si.input.Init()
}

func (pi *projectInOpFloat32) Init() {
	pi.input.Init()
}

func (si *selectInOpFloat32) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInFloat32(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInFloat32(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInFloat32(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInFloat32(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpFloat32) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Float32()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInFloat32(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInFloat32(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInFloat32(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInFloat32(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpFloat64 struct {
	input     Operator
	colIdx    int
	filterRow []float64
	hasNulls  bool
	negate    bool
}

type projectInOpFloat64 struct {
	input     Operator
	colIdx    int
	outputIdx int
	filterRow []float64
	hasNulls  bool
	negate    bool
}

var _ StaticMemoryOperator = &projectInOpFloat64{}

func (p *projectInOpFloat64) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]types.T{types.Bool}, coldata.BatchSize)
}

func fillDatumRowFloat64(ct *semtypes.T, datumTuple *tree.DTuple) ([]float64, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []float64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(float64)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInFloat64(target float64, filterRow []float64, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool
		cmp = compareFloats(float64(target), float64(filterRow[i])) == 0
		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpFloat64) Init() {
	si.input.Init()
}

func (pi *projectInOpFloat64) Init() {
	pi.input.Init()
}

func (si *selectInOpFloat64) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && cmpInFloat64(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && cmpInFloat64(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if cmpInFloat64(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if cmpInFloat64(col[i], si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpFloat64) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}

	if pi.outputIdx == batch.Width() {
		batch.AppendCol(types.Bool)
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Float64()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInFloat64(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					cmpRes := cmpInFloat64(col[i], pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				cmpRes := cmpInFloat64(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[:n]
			for i := range col {
				cmpRes := cmpInFloat64(col[i], pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}
