// Copyright 2018 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"

	"github.com/pkg/errors"
)

var (
	errInvalidArgCount     = errors.New("invalid number of arguments")
	errUnrecognizedCommand = errors.New("unrecognized command")
)

func main() {
	gen := execgen{useGoFmt: true, stdErr: os.Stderr}
	if !gen.run(os.Args[1:]...) {
		os.Exit(2)
	}
}

type execgen struct {
	// useGoFmt runs the go fmt tool on code generated by execgen, if this setting
	// is true.
	useGoFmt bool

	// stdErr is the writer to which all standard error output will be redirected.
	stdErr io.Writer

	// cmdLine stores the set of flags used to invoke the Execgen tool.
	cmdLine *flag.FlagSet
}

type generator func(io.Writer) error

var generators = map[string]generator{
	"rowstovec": genRowsToVec,
}

func (g *execgen) run(args ...string) bool {
	// Parse command line.
	g.cmdLine = flag.NewFlagSet("execgen", flag.ContinueOnError)
	g.cmdLine.SetOutput(g.stdErr)
	g.cmdLine.Usage = g.usage
	g.cmdLine.String("out", "", "output file name of generated code")
	err := g.cmdLine.Parse(args)
	if err != nil {
		return false
	}

	// Get remaining args after any flags have been parsed.
	args = g.cmdLine.Args()
	if len(args) < 1 {
		g.cmdLine.Usage()
		g.reportError(errInvalidArgCount)
		return false
	}

	cmd := args[0]
	gen := generators[cmd]
	if gen == nil {
		g.reportError(errUnrecognizedCommand)
		return false
	}

	if err := g.generate(gen); err != nil {
		g.reportError(err)
		return false
	}
	return true
}

func (g *execgen) generate(genFunc generator) error {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by execgen; DO NOT EDIT.\n")

	err := genFunc(&buf)
	if err != nil {
		return err
	}

	var b []byte
	if g.useGoFmt {
		b, err = format.Source(buf.Bytes())
		if err != nil {
			// Write out incorrect source for easier debugging.
			b = buf.Bytes()
			out := g.cmdLine.Lookup("out").Value.String()
			err = fmt.Errorf("Code formatting failed with Go parse error\n%s:%s", out, err)
		}
	} else {
		b = buf.Bytes()
	}

	if err != nil {
		// Ignore any write error if another error already occurred.
		_ = g.writeOutputFile(b)
		return err
	}
	return g.writeOutputFile(b)
}

func (g *execgen) writeOutputFile(b []byte) error {
	out := g.cmdLine.Lookup("out").Value.String()
	if out != "" {
		file, err := os.Create(out)
		if err != nil {
			return err
		}
		defer file.Close()

		_, err = file.Write(b)
		return err
	}

	// Send output to stderr.
	_, err := g.stdErr.Write(b)
	return err
}

// usage is a replacement usage function for the flags package.
func (g *execgen) usage() {
	fmt.Fprintf(g.stdErr, "Execgen is a tool for generating templated code related to ")
	fmt.Fprintf(g.stdErr, "columnarized execution.\n\n")

	fmt.Fprintf(g.stdErr, "Usage:\n")
	fmt.Fprintf(g.stdErr, "\texecgen [flags] command...\n\n")

	fmt.Fprintf(g.stdErr, "The commands are:\n")
	fmt.Fprintf(g.stdErr, "\trowstovec  generate the EncDatumRowsToColVec function\n\n")

	fmt.Fprintf(g.stdErr, "Flags:\n")
	g.cmdLine.PrintDefaults()
	fmt.Fprintf(g.stdErr, "\n")
}

func (g *execgen) reportError(err error) {
	fmt.Fprintf(g.stdErr, "ERROR: %v\n", err)
}
