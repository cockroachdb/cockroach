// Code generated by execgen; DO NOT EDIT.

package exec

import (
	"bytes"
	"fmt"
	"math"

	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
)

// rehash takes a element of a key (tuple representing a row of equality
// column values) at a given column and computes a new hash by applying a
// transformation to the existing hash.
func (ht *hashTable) rehash(
	buckets []uint64, keyIdx int, t types.T, col ColVec, nKeys uint64, sel []uint16,
) {
	switch t {

	case types.Bool:
		keys := col.Bool()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				if keys[sel[i]] {
					buckets[i] = buckets[i]*31 + 1
				}

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				if keys[i] {
					buckets[i] = buckets[i]*31 + 1
				}

			}
		}

	case types.Bytes:
		keys := col.Bytes()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				hash := 1
				for b := range keys[sel[i]] {
					hash = hash*31 + b
				}
				buckets[i] = buckets[i]*31 + uint64(hash)

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				hash := 1
				for b := range keys[i] {
					hash = hash*31 + b
				}
				buckets[i] = buckets[i]*31 + uint64(hash)

			}
		}

	case types.Decimal:
		keys := col.Decimal()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				d, err := keys[sel[i]].Float64()
				if err != nil {
					panic(fmt.Sprintf("%v", err))
				}
				buckets[i] = buckets[i]*31 + math.Float64bits(d)

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				d, err := keys[i].Float64()
				if err != nil {
					panic(fmt.Sprintf("%v", err))
				}
				buckets[i] = buckets[i]*31 + math.Float64bits(d)

			}
		}

	case types.Int8:
		keys := col.Int8()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[i])

			}
		}

	case types.Int16:
		keys := col.Int16()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[i])

			}
		}

	case types.Int32:
		keys := col.Int32()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[i])

			}
		}

	case types.Int64:
		keys := col.Int64()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[i])

			}
		}

	case types.Float32:
		keys := col.Float32()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(math.Float32bits(keys[sel[i]]))

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(math.Float32bits(keys[i]))

			}
		}

	case types.Float64:
		keys := col.Float64()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + math.Float64bits(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + math.Float64bits(keys[i])

			}
		}

	default:
		panic(fmt.Sprintf("unhandled type %d", t))
	}
}

// checkCol determines if the current key column in the groupID buckets
// matches the specified equality column key. If there is a match, then the key
// is added to differs. If the bucket has reached the end, the key is rejected.
func (prober *hashJoinProber) checkCol(t types.T, keyColIdx int, nToCheck uint16, sel []uint16) {
	switch t {

	case types.Bool:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Bool()
		probeKeys := prober.keys[keyColIdx].Bool()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	case types.Bytes:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Bytes()
		probeKeys := prober.keys[keyColIdx].Bytes()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if !bytes.Equal(buildKeys[keyID-1], probeKeys[sel[prober.toCheck[i]]]) {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if !bytes.Equal(buildKeys[keyID-1], probeKeys[prober.toCheck[i]]) {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	case types.Decimal:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Decimal()
		probeKeys := prober.keys[keyColIdx].Decimal()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1].Cmp(&probeKeys[sel[prober.toCheck[i]]]) != 0 {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1].Cmp(&probeKeys[prober.toCheck[i]]) != 0 {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	case types.Int8:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Int8()
		probeKeys := prober.keys[keyColIdx].Int8()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	case types.Int16:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Int16()
		probeKeys := prober.keys[keyColIdx].Int16()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	case types.Int32:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Int32()
		probeKeys := prober.keys[keyColIdx].Int32()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	case types.Int64:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Int64()
		probeKeys := prober.keys[keyColIdx].Int64()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	case types.Float32:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Float32()
		probeKeys := prober.keys[keyColIdx].Float32()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	case types.Float64:
		buildKeys := prober.ht.vals[prober.ht.keyCols[keyColIdx]].Float64()
		probeKeys := prober.keys[keyColIdx].Float64()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
						prober.differs[prober.toCheck[i]] = true
					}

				}
			}
		}

	default:
		panic(fmt.Sprintf("unhandled type %d", t))
	}
}
