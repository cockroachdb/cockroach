// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package exec

import (
	"bytes"
	"context"
	"fmt"
	"math"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/distsqlpb"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.UNSAFEGET

type mergeJoinLeftOuterOp struct {
	mergeJoinBase
}

var _ StaticMemoryOperator = &mergeJoinLeftOuterOp{}

func (o *mergeJoinLeftOuterOp) probeBodyLSeltrueRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftOuterOp) probeBodyLSeltrueRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := lSel[curLIdx]
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftOuterOp) probeBodyLSelfalseRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := rSel[curRIdx]
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := rSel[curRIdx]
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := rSel[curRIdx]
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftOuterOp) probeBodyLSelfalseRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult < 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case coltypes.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										if !lVal && rVal {
											cmpResult = -1
										} else if lVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys.Get(int(lSelIdx))
								rSelIdx := curRIdx
								rVal := rKeys.Get(int(rSelIdx))

								var match bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys.Get(int(rSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(lVal, rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys.Get(int(lSelIdx))

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&lVal, &rVal)
										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := int64(lVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case coltypes.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lSelIdx := curLIdx
								lVal := lKeys[int(lSelIdx)]
								rSelIdx := curRIdx
								rVal := rKeys[int(rSelIdx)]

								var match bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									match = cmpResult == 0
								}

								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											lSelIdx := curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											rSelIdx := curRIdx
											newRVal := rKeys[int(rSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool

									{
										var cmpResult int

										{
											a, b := float64(lVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										incrementLeft = cmpResult > 0
									}

									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											lSelIdx = curLIdx
											newLVal := lKeys[int(lSelIdx)]

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												break
											}
											o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

// buildLeftGroups takes a []group and expands each group into the output by
// repeating each row in the group numRepeats times. For example, given an
// input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroups expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroups in that each row of group is
// repeated numRepeats times, instead of a simple copy of the group as a whole.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinLeftOuterOp) buildLeftGroups(
	leftGroups []group,
	colOffset int,
	input *mergeJoinInput,
	batch coldata.Batch,
	destStartIdx uint16,
) {
	sel := batch.Selection()
	initialBuilderState := o.builderState.left
	outputBatchSize := int(o.outputBatchSize)
	// Loop over every column.
LeftColLoop:
	for ; o.builderState.left.colIdx < len(input.outCols); o.builderState.left.colIdx++ {
		colIdx := input.outCols[o.builderState.left.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx))
		src := batch.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		if sel != nil {
			if src.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol.Get(srcStartIdx)
									for i := 0; i < toAppend; i++ {
										outCol.Set(outStartIdx, val)
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol.Get(srcStartIdx)
									for i := 0; i < toAppend; i++ {
										outCol.Set(outStartIdx, val)
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol.Get(srcStartIdx)
									for i := 0; i < toAppend; i++ {
										outCol.Set(outStartIdx, val)
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol.Get(srcStartIdx)
									for i := 0; i < toAppend; i++ {
										outCol.Set(outStartIdx, val)
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}
		o.builderState.left.setBuilderColumnState(initialBuilderState)
	}
	o.builderState.left.reset()
}

// buildRightGroups takes a []group and repeats each group numRepeats times.
// For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroups in that each group is not
// expanded but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinLeftOuterOp) buildRightGroups(
	rightGroups []group,
	colOffset int,
	input *mergeJoinInput,
	batch coldata.Batch,
	destStartIdx uint16,
) {
	initialBuilderState := o.builderState.right
	sel := batch.Selection()
	outputBatchSize := int(o.outputBatchSize)

	// Loop over every column.
RightColLoop:
	for ; o.builderState.right.colIdx < len(input.outCols); o.builderState.right.colIdx++ {
		colIdx := input.outCols[o.builderState.right.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx) + colOffset)
		src := batch.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		if sel != nil {
			if src.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol.Get(int(sel[o.builderState.right.curSrcStartIdx]))
									outCol.Set(outStartIdx, v)
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol.Get(int(sel[i+o.builderState.right.curSrcStartIdx]))
										outCol.Set(i+outStartIdx, v)
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol.Get(int(sel[o.builderState.right.curSrcStartIdx]))
									outCol.Set(outStartIdx, v)
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol.Get(int(sel[i+o.builderState.right.curSrcStartIdx]))
										outCol.Set(i+outStartIdx, v)
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
									outCol[outStartIdx] = v
								} else {
									for i := 0; i < toAppend; i++ {
										v := srcCol[int(sel[i+o.builderState.right.curSrcStartIdx])]
										outCol[i+outStartIdx] = v
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol.Get(o.builderState.right.curSrcStartIdx)
									outCol.Set(outStartIdx, v)
								} else {
									outCol.CopySlice(srcCol, outStartIdx, o.builderState.right.curSrcStartIdx, o.builderState.right.curSrcStartIdx+toAppend)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol.Get(o.builderState.right.curSrcStartIdx)
									outCol.Set(outStartIdx, v)
								} else {
									outCol.CopySlice(srcCol, outStartIdx, o.builderState.right.curSrcStartIdx, o.builderState.right.curSrcStartIdx+toAppend)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									v := srcCol[o.builderState.right.curSrcStartIdx]
									outCol[outStartIdx] = v
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}

		o.builderState.right.setBuilderColumnState(initialBuilderState)
	}
	o.builderState.right.reset()
}

// probe is where we generate the groups slices that are used in the build
// phase. We do this by first assuming that every row in both batches
// contributes to the cross product. Then, with every equality column, we
// filter out the rows that don't contribute to the cross product (i.e. they
// don't have a matching row on the other side in the case of an inner join),
// and set the correct cardinality.
// Note that in this phase, we do this for every group, except the last group
// in the batch.
func (o *mergeJoinLeftOuterOp) probe() {
	o.groups.reset(o.proberState.lIdx, o.proberState.lLength, o.proberState.rIdx, o.proberState.rLength)
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
	if lSel != nil {
		if rSel != nil {
			o.probeBodyLSeltrueRSeltrue()
		} else {
			o.probeBodyLSeltrueRSelfalse()
		}
	} else {
		if rSel != nil {
			o.probeBodyLSelfalseRSeltrue()
		} else {
			o.probeBodyLSelfalseRSelfalse()
		}
	}
}

// setBuilderSourceToBufferedGroup sets up the builder state to use the
// buffered group.
func (o *mergeJoinLeftOuterOp) setBuilderSourceToBufferedGroup() {
	lGroupEndIdx := int(o.proberState.lBufferedGroup.length)
	// The capacity of builder state lGroups and rGroups is always at least 1
	// given the init.
	o.builderState.lGroups = o.builderState.lGroups[:1]
	o.builderState.rGroups = o.builderState.rGroups[:1]
	rGroupEndIdx := int(o.proberState.rBufferedGroup.length)
	o.builderState.lGroups[0] = group{
		rowStartIdx: 0,
		rowEndIdx:   lGroupEndIdx,
		numRepeats:  rGroupEndIdx,
		toBuild:     lGroupEndIdx * rGroupEndIdx,
	}
	o.builderState.rGroups[0] = group{
		rowStartIdx: 0,
		rowEndIdx:   rGroupEndIdx,
		numRepeats:  lGroupEndIdx,
		toBuild:     rGroupEndIdx * lGroupEndIdx,
	}

	o.builderState.lBatch = o.proberState.lBufferedGroup
	o.builderState.rBatch = o.proberState.rBufferedGroup

	// We cannot yet reset the buffered groups because the builder will be taking
	// input from them. The actual reset will take place on the next call to
	// initProberState().
	o.proberState.lBufferedGroup.needToReset = true
	o.proberState.rBufferedGroup.needToReset = true
}

// exhaustLeftSource sets up the builder to process any remaining tuples from
// the left source. It should only be called when the right source has been
// exhausted.
func (o *mergeJoinLeftOuterOp) exhaustLeftSource() {
	// The capacity of builder state lGroups and rGroups is always at least 1
	// given the init.
	o.builderState.lGroups = o.builderState.lGroups[:1]
	o.builderState.lGroups[0] = group{
		rowStartIdx: o.proberState.lIdx,
		rowEndIdx:   o.proberState.lLength,
		numRepeats:  1,
		toBuild:     o.proberState.lLength - o.proberState.lIdx,
		unmatched:   true,
	}
	o.builderState.rGroups = o.builderState.rGroups[:1]
	o.builderState.rGroups[0] = group{
		rowStartIdx: o.proberState.lIdx,
		rowEndIdx:   o.proberState.lLength,
		numRepeats:  1,
		toBuild:     o.proberState.lLength - o.proberState.lIdx,
		nullGroup:   true,
	}

	o.proberState.lIdx = o.proberState.lLength
}

// exhaustRightSource sets up the builder to process any remaining tuples from
// the right source. It should only be called when the left source has been
// exhausted.
func (o *mergeJoinLeftOuterOp) exhaustRightSource() {
}

// build creates the cross product, and writes it to the output member.
func (o *mergeJoinLeftOuterOp) build() {
	if o.output.Width() != 0 {
		outStartIdx := o.builderState.outCount
		o.buildLeftGroups(o.builderState.lGroups, 0 /* colOffset */, &o.left, o.builderState.lBatch, outStartIdx)
		o.buildRightGroups(o.builderState.rGroups, len(o.left.sourceTypes), &o.right, o.builderState.rBatch, outStartIdx)
	}
	o.builderState.outCount = o.calculateOutputCount(o.builderState.lGroups)
}

// calculateOutputCount uses the toBuild field of each group and the output
// batch size to determine the output count. Note that as soon as a group is
// materialized partially or fully to output, its toBuild field is updated
// accordingly.
func (o *mergeJoinLeftOuterOp) calculateOutputCount(groups []group) uint16 {
	count := int(o.builderState.outCount)

	for i := 0; i < len(groups); i++ {
		count += groups[i].toBuild
		groups[i].toBuild = 0
		if count > int(o.outputBatchSize) {
			groups[i].toBuild = count - int(o.outputBatchSize)
			count = int(o.outputBatchSize)
			return uint16(count)
		}
	}
	o.builderState.outFinished = true
	return uint16(count)
}

func (o *mergeJoinLeftOuterOp) Next(ctx context.Context) coldata.Batch {
	for {
		switch o.state {
		case mjEntry:
			if o.needToResetOutput {
				o.needToResetOutput = false
				o.output.ResetInternalBatch()
				for _, vec := range o.output.ColVecs() {
					// We only need to explicitly reset nulls since the values will be
					// copied over and the correct length will be set.
					vec.Nulls().UnsetNulls()
				}
			}
			o.initProberState(ctx)

			if o.nonEmptyBufferedGroup() {
				o.state = mjFinishBufferedGroup
				break
			}

			if o.sourceFinished() {
				o.state = mjSourceFinished
				break
			}

			o.state = mjProbe
		case mjSourceFinished:

			o.outputReady = true
			// First we make sure that batches of the builder state are always set. This
			// is needed because the batches are accessed outside of _LEFT_SWITCH and
			// _RIGHT_SWITCH (before the merge joiner figures out whether there are any
			// groups to be built).
			o.builderState.lBatch = o.proberState.lBatch
			o.builderState.rBatch = o.proberState.rBatch
			// Next, we need to make sure that builder state is set up for a case when
			// neither exhaustLeftSource nor exhaustRightSource is called below. In such
			// scenario the merge joiner is done, so it'll be outputting zero-length
			// batches from now on.
			o.builderState.lGroups = o.builderState.lGroups[:0]
			o.builderState.rGroups = o.builderState.rGroups[:0]
			// At least one of the sources is finished. If it was the right one,
			// then we need to emit remaining tuples from the left source with
			// nulls corresponding to the right one. But if the left source is
			// finished, then there is nothing left to do.
			if o.proberState.lIdx < o.proberState.lLength {
				o.exhaustLeftSource()
				// We unset o.outputReady here because we want to put as many unmatched
				// tuples from the left into the output batch. Once outCount reaches the
				// desired output batch size, the output will be returned.
				o.outputReady = false
			}
			o.state = mjBuild
		case mjFinishBufferedGroup:
			o.finishProbe(ctx)
			o.setBuilderSourceToBufferedGroup()
			o.state = mjBuild
		case mjProbe:
			o.probe()
			o.setBuilderSourceToBatch()
			o.state = mjBuild
		case mjBuild:
			o.build()

			if o.builderState.outFinished {
				o.state = mjEntry
				o.builderState.outFinished = false
			}

			if o.outputReady || o.builderState.outCount == o.outputBatchSize {
				o.output.SetLength(o.builderState.outCount)
				// Reset builder out count.
				o.builderState.outCount = uint16(0)
				o.needToResetOutput = true
				o.outputReady = false
				return o.output
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unexpected merge joiner state in Next: %v", o.state))
		}
	}
}
