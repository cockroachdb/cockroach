// Code generated by execgen; DO NOT EDIT.

package colexec

import (
	"bytes"
	"math"
	"time"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

func performPlusDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Add(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMinusDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Sub(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMultDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Mul(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performDivDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal

	{

		if b == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.DecimalCtx.Quo(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Add(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMinusDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Sub(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMultDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Mul(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performDivDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal

	{

		if b == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.DecimalCtx.Quo(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Add(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMinusDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Sub(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMultDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal

	{

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.ExactCtx.Mul(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performDivDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal

	{

		if b == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}

		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(b), 0)
		if _, err := tree.DecimalCtx.Quo(&r, &a, tmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	if _, err := tree.ExactCtx.Add(&r, &a, &b); err != nil {
		execerror.NonVectorizedPanic(err)
	}
	return r
}

func performMinusDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	if _, err := tree.ExactCtx.Sub(&r, &a, &b); err != nil {
		execerror.NonVectorizedPanic(err)
	}
	return r
}

func performMultDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	if _, err := tree.ExactCtx.Mul(&r, &a, &b); err != nil {
		execerror.NonVectorizedPanic(err)
	}
	return r
}

func performDivDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		cond, err := tree.DecimalCtx.Quo(&r, &a, &b)
		if cond.DivisionByZero() {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt16Int16(a int16, b int16) int16 {
	var r int16

	{
		result := a + b
		if (result < a) != (b < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt16Int16(a int16, b int16) int16 {
	var r int16

	{
		result := a - b
		if (result < a) != (b > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt16Int16(a int16, b int16) int16 {
	var r int16

	{
		result := a * b
		if a > math.MaxInt8 || a < math.MinInt8 || b > math.MaxInt8 || b < math.MinInt8 {
			if a != 0 && b != 0 {
				sameSign := (a < 0) == (b < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/b != a {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt16Int16(a int16, b int16) apd.Decimal {
	var r apd.Decimal

	{
		if b == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(a), 0)
		rightTmpDec.SetFinite(int64(b), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt16Int32(a int16, b int32) int64 {
	var r int64

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt16Int32(a int16, b int32) int64 {
	var r int64

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt16Int32(a int16, b int32) int64 {
	var r int64

	{
		result := int64(a) * int64(b)
		if int64(a) > math.MaxInt32 || int64(a) < math.MinInt32 || int64(b) > math.MaxInt32 || int64(b) < math.MinInt32 {
			if int64(a) != 0 && int64(b) != 0 {
				sameSign := (int64(a) < 0) == (int64(b) < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/int64(b) != int64(a) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt16Int32(a int16, b int32) apd.Decimal {
	var r apd.Decimal

	{
		if int64(b) == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(int64(a)), 0)
		rightTmpDec.SetFinite(int64(int64(b)), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt16Int64(a int16, b int64) int64 {
	var r int64

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt16Int64(a int16, b int64) int64 {
	var r int64

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt16Int64(a int16, b int64) int64 {
	var r int64

	{
		result := int64(a) * int64(b)
		if int64(a) > math.MaxInt32 || int64(a) < math.MinInt32 || int64(b) > math.MaxInt32 || int64(b) < math.MinInt32 {
			if int64(a) != 0 && int64(b) != 0 {
				sameSign := (int64(a) < 0) == (int64(b) < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/int64(b) != int64(a) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt16Int64(a int16, b int64) apd.Decimal {
	var r apd.Decimal

	{
		if int64(b) == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(int64(a)), 0)
		rightTmpDec.SetFinite(int64(int64(b)), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Add(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMinusInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Sub(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMultInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Mul(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performDivInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		cond, err := tree.DecimalCtx.Quo(&r, tmpDec, &b)
		if cond.DivisionByZero() {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt32Int16(a int32, b int16) int64 {
	var r int64

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt32Int16(a int32, b int16) int64 {
	var r int64

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt32Int16(a int32, b int16) int64 {
	var r int64

	{
		result := int64(a) * int64(b)
		if int64(a) > math.MaxInt32 || int64(a) < math.MinInt32 || int64(b) > math.MaxInt32 || int64(b) < math.MinInt32 {
			if int64(a) != 0 && int64(b) != 0 {
				sameSign := (int64(a) < 0) == (int64(b) < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/int64(b) != int64(a) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt32Int16(a int32, b int16) apd.Decimal {
	var r apd.Decimal

	{
		if int64(b) == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(int64(a)), 0)
		rightTmpDec.SetFinite(int64(int64(b)), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt32Int32(a int32, b int32) int32 {
	var r int32

	{
		result := a + b
		if (result < a) != (b < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt32Int32(a int32, b int32) int32 {
	var r int32

	{
		result := a - b
		if (result < a) != (b > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt32Int32(a int32, b int32) int32 {
	var r int32

	{
		result := a * b
		if a > math.MaxInt16 || a < math.MinInt16 || b > math.MaxInt16 || b < math.MinInt16 {
			if a != 0 && b != 0 {
				sameSign := (a < 0) == (b < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/b != a {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt32Int32(a int32, b int32) apd.Decimal {
	var r apd.Decimal

	{
		if b == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(a), 0)
		rightTmpDec.SetFinite(int64(b), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt32Int64(a int32, b int64) int64 {
	var r int64

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt32Int64(a int32, b int64) int64 {
	var r int64

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt32Int64(a int32, b int64) int64 {
	var r int64

	{
		result := int64(a) * int64(b)
		if int64(a) > math.MaxInt32 || int64(a) < math.MinInt32 || int64(b) > math.MaxInt32 || int64(b) < math.MinInt32 {
			if int64(a) != 0 && int64(b) != 0 {
				sameSign := (int64(a) < 0) == (int64(b) < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/int64(b) != int64(a) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt32Int64(a int32, b int64) apd.Decimal {
	var r apd.Decimal

	{
		if int64(b) == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(int64(a)), 0)
		rightTmpDec.SetFinite(int64(int64(b)), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Add(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMinusInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Sub(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMultInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Mul(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performDivInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		cond, err := tree.DecimalCtx.Quo(&r, tmpDec, &b)
		if cond.DivisionByZero() {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt64Int16(a int64, b int16) int64 {
	var r int64

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt64Int16(a int64, b int16) int64 {
	var r int64

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt64Int16(a int64, b int16) int64 {
	var r int64

	{
		result := int64(a) * int64(b)
		if int64(a) > math.MaxInt32 || int64(a) < math.MinInt32 || int64(b) > math.MaxInt32 || int64(b) < math.MinInt32 {
			if int64(a) != 0 && int64(b) != 0 {
				sameSign := (int64(a) < 0) == (int64(b) < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/int64(b) != int64(a) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt64Int16(a int64, b int16) apd.Decimal {
	var r apd.Decimal

	{
		if int64(b) == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(int64(a)), 0)
		rightTmpDec.SetFinite(int64(int64(b)), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt64Int32(a int64, b int32) int64 {
	var r int64

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt64Int32(a int64, b int32) int64 {
	var r int64

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt64Int32(a int64, b int32) int64 {
	var r int64

	{
		result := int64(a) * int64(b)
		if int64(a) > math.MaxInt32 || int64(a) < math.MinInt32 || int64(b) > math.MaxInt32 || int64(b) < math.MinInt32 {
			if int64(a) != 0 && int64(b) != 0 {
				sameSign := (int64(a) < 0) == (int64(b) < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/int64(b) != int64(a) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt64Int32(a int64, b int32) apd.Decimal {
	var r apd.Decimal

	{
		if int64(b) == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(int64(a)), 0)
		rightTmpDec.SetFinite(int64(int64(b)), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt64Int64(a int64, b int64) int64 {
	var r int64

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt64Int64(a int64, b int64) int64 {
	var r int64

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMultInt64Int64(a int64, b int64) int64 {
	var r int64

	{
		result := int64(a) * int64(b)
		if int64(a) > math.MaxInt32 || int64(a) < math.MinInt32 || int64(b) > math.MaxInt32 || int64(b) < math.MinInt32 {
			if int64(a) != 0 && int64(b) != 0 {
				sameSign := (int64(a) < 0) == (int64(b) < 0)
				if (result < 0) == sameSign {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				} else if result/int64(b) != int64(a) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performDivInt64Int64(a int64, b int64) apd.Decimal {
	var r apd.Decimal

	{
		if int64(b) == 0 {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
		leftTmpDec.SetFinite(int64(int64(a)), 0)
		rightTmpDec.SetFinite(int64(int64(b)), 0)
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Add(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMinusInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Sub(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performMultInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		_, err := tree.ExactCtx.Mul(&r, tmpDec, &b)

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performDivInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal

	{
		tmpDec := &apd.Decimal{}
		tmpDec.SetFinite(int64(a), 0)

		cond, err := tree.DecimalCtx.Quo(&r, tmpDec, &b)
		if cond.DivisionByZero() {
			execerror.NonVectorizedPanic(tree.ErrDivByZero)
		}

		if err != nil {
			execerror.NonVectorizedPanic(err)
		}
	}

	return r
}

func performPlusFloat64Float64(a float64, b float64) float64 {
	var r float64
	r = float64(a) + float64(b)
	return r
}

func performMinusFloat64Float64(a float64, b float64) float64 {
	var r float64
	r = float64(a) - float64(b)
	return r
}

func performMultFloat64Float64(a float64, b float64) float64 {
	var r float64
	r = float64(a) * float64(b)
	return r
}

func performDivFloat64Float64(a float64, b float64) float64 {
	var r float64
	r = float64(a) / float64(b)
	return r
}

func performEQBoolBool(a bool, b bool) bool {
	var r bool

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult == 0
	}

	return r
}

func performNEBoolBool(a bool, b bool) bool {
	var r bool

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult != 0
	}

	return r
}

func performLTBoolBool(a bool, b bool) bool {
	var r bool

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult < 0
	}

	return r
}

func performLEBoolBool(a bool, b bool) bool {
	var r bool

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTBoolBool(a bool, b bool) bool {
	var r bool

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult > 0
	}

	return r
}

func performGEBoolBool(a bool, b bool) bool {
	var r bool

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQBytesBytes(a []byte, b []byte) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult == 0
	}

	return r
}

func performNEBytesBytes(a []byte, b []byte) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult != 0
	}

	return r
}

func performLTBytesBytes(a []byte, b []byte) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult < 0
	}

	return r
}

func performLEBytesBytes(a []byte, b []byte) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult <= 0
	}

	return r
}

func performGTBytesBytes(a []byte, b []byte) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult > 0
	}

	return r
}

func performGEBytesBytes(a []byte, b []byte) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult >= 0
	}

	return r
}

func performEQDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult == 0
	}

	return r
}

func performNEDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult != 0
	}

	return r
}

func performLTDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult < 0
	}

	return r
}

func performLEDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult > 0
	}

	return r
}

func performGEDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult == 0
	}

	return r
}

func performNEDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult != 0
	}

	return r
}

func performLTDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult < 0
	}

	return r
}

func performLEDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult > 0
	}

	return r
}

func performGEDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult == 0
	}

	return r
}

func performNEDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult != 0
	}

	return r
}

func performLTDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult < 0
	}

	return r
}

func performLEDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult > 0
	}

	return r
}

func performGEDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(b), 0)
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult == 0
	}

	return r
}

func performNEDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult != 0
	}

	return r
}

func performLTDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult < 0
	}

	return r
}

func performLEDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult > 0
	}

	return r
}

func performGEDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult == 0
	}

	return r
}

func performNEDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult != 0
	}

	return r
}

func performLTDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult < 0
	}

	return r
}

func performLEDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult <= 0
	}

	return r
}

func performGTDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult > 0
	}

	return r
}

func performGEDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult >= 0
	}

	return r
}

func performEQInt16Int16(a int16, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt16Int16(a int16, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt16Int16(a int16, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt16Int16(a int16, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt16Int16(a int16, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt16Int16(a int16, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt16Int32(a int16, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt16Int32(a int16, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt16Int32(a int16, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt16Int32(a int16, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt16Int32(a int16, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt16Int32(a int16, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt16Int64(a int16, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt16Int64(a int16, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt16Int64(a int16, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt16Int64(a int16, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt16Int64(a int16, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt16Int64(a int16, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt16Float64(a int16, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt16Float64(a int16, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt16Float64(a int16, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt16Float64(a int16, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt16Float64(a int16, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt16Float64(a int16, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt32Int16(a int32, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt32Int16(a int32, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt32Int16(a int32, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt32Int16(a int32, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt32Int16(a int32, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt32Int16(a int32, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt32Int32(a int32, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt32Int32(a int32, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt32Int32(a int32, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt32Int32(a int32, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt32Int32(a int32, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt32Int32(a int32, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt32Int64(a int32, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt32Int64(a int32, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt32Int64(a int32, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt32Int64(a int32, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt32Int64(a int32, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt32Int64(a int32, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt32Float64(a int32, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt32Float64(a int32, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt32Float64(a int32, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt32Float64(a int32, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt32Float64(a int32, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt32Float64(a int32, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt64Int16(a int64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt64Int16(a int64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt64Int16(a int64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt64Int16(a int64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt64Int16(a int64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt64Int16(a int64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt64Int32(a int64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt64Int32(a int64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt64Int32(a int64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt64Int32(a int64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt64Int32(a int64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt64Int32(a int64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt64Int64(a int64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt64Int64(a int64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt64Int64(a int64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt64Int64(a int64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt64Int64(a int64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt64Int64(a int64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt64Float64(a int64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt64Float64(a int64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt64Float64(a int64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt64Float64(a int64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt64Float64(a int64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt64Float64(a int64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult == 0
	}

	return r
}

func performNEInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult != 0
	}

	return r
}

func performLTInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult < 0
	}

	return r
}

func performLEInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult > 0
	}

	return r
}

func performGEInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			tmpDec.SetFinite(int64(a), 0)
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQFloat64Int16(a float64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEFloat64Int16(a float64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTFloat64Int16(a float64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEFloat64Int16(a float64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTFloat64Int16(a float64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEFloat64Int16(a float64, b int16) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQFloat64Int32(a float64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEFloat64Int32(a float64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTFloat64Int32(a float64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEFloat64Int32(a float64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTFloat64Int32(a float64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEFloat64Int32(a float64, b int32) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQFloat64Int64(a float64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEFloat64Int64(a float64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTFloat64Int64(a float64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEFloat64Int64(a float64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTFloat64Int64(a float64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEFloat64Int64(a float64, b int64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQFloat64Float64(a float64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performNEFloat64Float64(a float64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performLTFloat64Float64(a float64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLEFloat64Float64(a float64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTFloat64Float64(a float64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGEFloat64Float64(a float64, b float64) bool {
	var r bool

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult == 0
	}

	return r
}

func performNEFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult != 0
	}

	return r
}

func performLTFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult < 0
	}

	return r
}

func performLEFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult <= 0
	}

	return r
}

func performGTFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult > 0
	}

	return r
}

func performGEFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool

	{
		var cmpResult int

		{
			tmpDec := &apd.Decimal{}
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				execerror.NonVectorizedPanic(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult >= 0
	}

	return r
}

func performEQTimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult == 0
	}

	return r
}

func performNETimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult != 0
	}

	return r
}

func performLTTimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult < 0
	}

	return r
}

func performLETimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult <= 0
	}

	return r
}

func performGTTimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult > 0
	}

	return r
}

func performGETimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult >= 0
	}

	return r
}
