// Code generated by execgen; DO NOT EDIT.

package colexec

import (
	"bytes"
	"math"
	"time"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/server/telemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sqltelemetry"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
)

func performBitandInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitandInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitandInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitandInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitandInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitandInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitandInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitandInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitandInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) & int64(b)

	return r
}

func performBitorInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitorInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitorInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitorInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitorInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitorInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitorInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitorInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitorInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) | int64(b)

	return r
}

func performBitxorInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performBitxorInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performBitxorInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performBitxorInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performBitxorInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performBitxorInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performBitxorInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performBitxorInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performBitxorInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	r = int64(a) ^ int64(b)

	return r
}

func performPlusDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Add(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPlusDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Add(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPlusDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Add(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPlusDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		_, err := tree.ExactCtx.Add(&r, &a, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPlusInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) + int64(b)
		if (result < int64(a)) != (int64(b) < 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performPlusInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Add(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPlusInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Add(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPlusInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Add(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPlusFloat64Float64(a float64, b float64) float64 {
	var r float64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		r = float64(a) + float64(b)
	}

	return r
}

func performPlusTimestampInterval(a time.Time, b duration.Duration) time.Time {
	var r time.Time
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = duration.Add(a, b)
	return r
}

func performPlusIntervalTimestamp(a duration.Duration, b time.Time) time.Time {
	var r time.Time
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = duration.Add(b, a)
	return r
}

func performPlusIntervalInterval(a duration.Duration, b duration.Duration) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = a.Add(b)
	return r
}

func performMinusDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Sub(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMinusDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Sub(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMinusDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Sub(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMinusDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		_, err := tree.ExactCtx.Sub(&r, &a, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMinusInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		result := int64(a) - int64(b)
		if (result < int64(a)) != (int64(b) > 0) {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = result
	}

	return r
}

func performMinusInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Sub(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMinusInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Sub(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMinusInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Sub(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMinusFloat64Float64(a float64, b float64) float64 {
	var r float64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		r = float64(a) - float64(b)
	}

	return r
}

func performMinusTimestampTimestamp(a time.Time, b time.Time) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	nanos := a.Sub(b).Nanoseconds()
	r = duration.MakeDuration(nanos, 0, 0)

	return r
}

func performMinusTimestampInterval(a time.Time, b duration.Duration) time.Time {
	var r time.Time
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = duration.Add(a, b.Mul(-1))
	return r
}

func performMinusIntervalInterval(a duration.Duration, b duration.Duration) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = a.Sub(b)
	return r
}

func performMultDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Mul(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMultDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Mul(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMultDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.ExactCtx.Mul(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMultDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		_, err := tree.ExactCtx.Mul(&r, &a, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMultDecimalInterval(a apd.Decimal, b duration.Duration) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	f, err := a.Float64()
	if err != nil {
		colexecerror.InternalError(err)
	}
	r = b.MulFloat(f)
	return r
}

func performMultInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		_left, _right := int64(a), int64(b)
		result := _left * _right
		if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
			if _left != 0 && _right != 0 {
				sameSign := (_left < 0) == (_right < 0)
				if (result < 0) == sameSign {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				} else if result/_right != _left {
					colexecerror.ExpectedError(tree.ErrIntOutOfRange)
				}
			}
		}
		r = result
	}

	return r
}

func performMultInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Mul(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMultInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Mul(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMultInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.ExactCtx.Mul(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performMultInt16Interval(a int16, b duration.Duration) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = b.Mul(int64(a))
	return r
}

func performMultInt32Interval(a int32, b duration.Duration) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = b.Mul(int64(a))
	return r
}

func performMultInt64Interval(a int64, b duration.Duration) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = b.Mul(int64(a))
	return r
}

func performMultFloat64Float64(a float64, b float64) float64 {
	var r float64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		r = float64(a) * float64(b)
	}

	return r
}

func performMultFloat64Interval(a float64, b duration.Duration) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = b.MulFloat(float64(a))
	return r
}

func performMultIntervalInt16(a duration.Duration, b int16) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = a.Mul(int64(b))
	return r
}

func performMultIntervalInt32(a duration.Duration, b int32) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = a.Mul(int64(b))
	return r
}

func performMultIntervalInt64(a duration.Duration, b int64) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = a.Mul(int64(b))
	return r
}

func performMultIntervalFloat64(a duration.Duration, b float64) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	r = a.MulFloat(float64(b))
	return r
}

func performMultIntervalDecimal(a duration.Duration, b apd.Decimal) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	f, err := b.Float64()
	if err != nil {
		colexecerror.InternalError(err)
	}
	r = a.MulFloat(f)
	return r
}

func performDivDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.DecimalCtx.Quo(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.DecimalCtx.Quo(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.DecimalCtx.Quo(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		_, err := tree.DecimalCtx.Quo(&r, &a, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt16Int16(a int16, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt16Int32(a int16, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt16Int64(a int16, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt32Int16(a int32, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt32Int32(a int32, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt32Int64(a int32, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt64Int16(a int64, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt64Int32(a int64, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt64Int64(a int64, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Quo(&r, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.DecimalCtx.Quo(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.DecimalCtx.Quo(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.DecimalCtx.Quo(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performDivFloat64Float64(a float64, b float64) float64 {
	var r float64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0.0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		r = float64(a) / float64(b)
	}

	return r
}

func performDivIntervalInt64(a duration.Duration, b int64) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	if b == 0 {
		colexecerror.ExpectedError(tree.ErrDivByZero)
	}
	r = a.Div(int64(b))
	return r
}

func performDivIntervalFloat64(a duration.Duration, b float64) duration.Duration {
	var r duration.Duration
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	if b == 0.0 {
		colexecerror.ExpectedError(tree.ErrDivByZero)
	}
	r = a.DivFloat(float64(b))
	return r
}

func performFloorDivDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.HighPrecisionCtx.QuoInteger(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performFloorDivDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.HighPrecisionCtx.QuoInteger(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performFloorDivDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.HighPrecisionCtx.QuoInteger(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performFloorDivDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		_, err := tree.HighPrecisionCtx.QuoInteger(&r, &a, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performFloorDivInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) // int64(b)
	}

	return r
}

func performFloorDivInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.HighPrecisionCtx.QuoInteger(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performFloorDivInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.HighPrecisionCtx.QuoInteger(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performFloorDivInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.HighPrecisionCtx.QuoInteger(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performFloorDivFloat64Float64(a float64, b float64) float64 {
	var r float64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0.0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		r = math.Trunc(float64(a) / float64(b))
	}

	return r
}

func performModDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.HighPrecisionCtx.Rem(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performModDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.HighPrecisionCtx.Rem(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performModDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.HighPrecisionCtx.Rem(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performModDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		_, err := tree.HighPrecisionCtx.Rem(&r, &a, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performModInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) == 0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}
		r = int64(a) % int64(b)
	}

	return r
}

func performModInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.HighPrecisionCtx.Rem(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performModInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.HighPrecisionCtx.Rem(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performModInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b.IsZero() {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.HighPrecisionCtx.Rem(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performModFloat64Float64(a float64, b float64) float64 {
	var r float64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		if b == 0.0 {
			colexecerror.ExpectedError(tree.ErrDivByZero)
		}

		r = math.Mod(float64(a), float64(b))
	}

	return r
}

func performPowDecimalInt16(a apd.Decimal, b int16) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.DecimalCtx.Pow(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPowDecimalInt32(a apd.Decimal, b int32) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.DecimalCtx.Pow(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPowDecimalInt64(a apd.Decimal, b int64) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(b))
		if _, err := tree.DecimalCtx.Pow(&r, &a, tmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPowDecimalDecimal(a apd.Decimal, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		_, err := tree.DecimalCtx.Pow(&r, &a, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPowInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
		leftTmpDec.SetInt64(int64(int64(a)))
		rightTmpDec.SetInt64(int64(int64(b)))
		if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
			colexecerror.ExpectedError(err)
		}
		resultInt, err := leftTmpDec.Int64()
		if err != nil {
			colexecerror.ExpectedError(tree.ErrIntOutOfRange)
		}
		r = resultInt
	}

	return r
}

func performPowInt16Decimal(a int16, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.DecimalCtx.Pow(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPowInt32Decimal(a int32, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.DecimalCtx.Pow(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPowInt64Decimal(a int64, b apd.Decimal) apd.Decimal {
	var r apd.Decimal
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		tmpDec := &_overloadHelper.tmpDec1
		tmpDec.SetInt64(int64(a))
		_, err := tree.DecimalCtx.Pow(&r, tmpDec, &b)
		if err != nil {
			colexecerror.ExpectedError(err)
		}
	}

	return r
}

func performPowFloat64Float64(a float64, b float64) float64 {
	var r float64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{

		r = math.Pow(float64(a), float64(b))
	}

	return r
}

func performConcatBytesBytes(a []byte, b []byte) []byte {
	var r []byte
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper
	colexecerror.InternalError("couldn't translate indexing on target element: r")
	return r
}

func performLShiftInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performLShiftInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performLShiftInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performLShiftInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performLShiftInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performLShiftInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performLShiftInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performLShiftInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performLShiftInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) << int64(b)
	}

	return r
}

func performRShiftInt16Int16(a int16, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performRShiftInt16Int32(a int16, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performRShiftInt16Int64(a int16, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performRShiftInt32Int16(a int32, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performRShiftInt32Int32(a int32, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performRShiftInt32Int64(a int32, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performRShiftInt64Int16(a int64, b int16) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performRShiftInt64Int32(a int64, b int32) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performRShiftInt64Int64(a int64, b int64) int64 {
	var r int64
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		if int64(b) < 0 || int64(b) >= 64 {
			telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
			colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
		}
		r = int64(a) >> int64(b)
	}

	return r
}

func performEQBoolBool(a bool, b bool) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult == 0
	}

	return r
}

func performEQBytesBytes(a []byte, b []byte) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult == 0
	}

	return r
}

func performEQDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult == 0
	}

	return r
}

func performEQDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult == 0
	}

	return r
}

func performEQDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult == 0
	}

	return r
}

func performEQDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult == 0
	}

	return r
}

func performEQDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult == 0
	}

	return r
}

func performEQInt16Int16(a int16, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt16Int32(a int16, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt16Int64(a int16, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt32Int16(a int32, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt32Int32(a int32, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt32Int64(a int32, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt64Int16(a int64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt64Int32(a int64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt64Int64(a int64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt16Float64(a int16, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt32Float64(a int32, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt64Float64(a int64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult == 0
	}

	return r
}

func performEQInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult == 0
	}

	return r
}

func performEQFloat64Int16(a float64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQFloat64Int32(a float64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQFloat64Int64(a float64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQFloat64Float64(a float64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult == 0
	}

	return r
}

func performEQFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult == 0
	}

	return r
}

func performEQTimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult == 0
	}

	return r
}

func performEQIntervalInterval(a duration.Duration, b duration.Duration) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = a.Compare(b)
		r = cmpResult == 0
	}

	return r
}

func performNEBoolBool(a bool, b bool) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult != 0
	}

	return r
}

func performNEBytesBytes(a []byte, b []byte) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult != 0
	}

	return r
}

func performNEDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult != 0
	}

	return r
}

func performNEDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult != 0
	}

	return r
}

func performNEDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult != 0
	}

	return r
}

func performNEDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult != 0
	}

	return r
}

func performNEDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult != 0
	}

	return r
}

func performNEInt16Int16(a int16, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt16Int32(a int16, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt16Int64(a int16, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt32Int16(a int32, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt32Int32(a int32, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt32Int64(a int32, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt64Int16(a int64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt64Int32(a int64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt64Int64(a int64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt16Float64(a int16, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt32Float64(a int32, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt64Float64(a int64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult != 0
	}

	return r
}

func performNEInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult != 0
	}

	return r
}

func performNEFloat64Int16(a float64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEFloat64Int32(a float64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEFloat64Int64(a float64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEFloat64Float64(a float64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult != 0
	}

	return r
}

func performNEFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult != 0
	}

	return r
}

func performNETimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult != 0
	}

	return r
}

func performNEIntervalInterval(a duration.Duration, b duration.Duration) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = a.Compare(b)
		r = cmpResult != 0
	}

	return r
}

func performLTBoolBool(a bool, b bool) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult < 0
	}

	return r
}

func performLTBytesBytes(a []byte, b []byte) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult < 0
	}

	return r
}

func performLTDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult < 0
	}

	return r
}

func performLTDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult < 0
	}

	return r
}

func performLTDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult < 0
	}

	return r
}

func performLTDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult < 0
	}

	return r
}

func performLTDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult < 0
	}

	return r
}

func performLTInt16Int16(a int16, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt16Int32(a int16, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt16Int64(a int16, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt32Int16(a int32, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt32Int32(a int32, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt32Int64(a int32, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt64Int16(a int64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt64Int32(a int64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt64Int64(a int64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt16Float64(a int16, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt32Float64(a int32, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt64Float64(a int64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult < 0
	}

	return r
}

func performLTInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult < 0
	}

	return r
}

func performLTFloat64Int16(a float64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTFloat64Int32(a float64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTFloat64Int64(a float64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTFloat64Float64(a float64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult < 0
	}

	return r
}

func performLTFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult < 0
	}

	return r
}

func performLTTimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult < 0
	}

	return r
}

func performLTIntervalInterval(a duration.Duration, b duration.Duration) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = a.Compare(b)
		r = cmpResult < 0
	}

	return r
}

func performLEBoolBool(a bool, b bool) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEBytesBytes(a []byte, b []byte) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult <= 0
	}

	return r
}

func performLEDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult <= 0
	}

	return r
}

func performLEInt16Int16(a int16, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt16Int32(a int16, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt16Int64(a int16, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt32Int16(a int32, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt32Int32(a int32, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt32Int64(a int32, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt64Int16(a int64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt64Int32(a int64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt64Int64(a int64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt16Float64(a int16, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt32Float64(a int32, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt64Float64(a int64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEFloat64Int16(a float64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEFloat64Int32(a float64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEFloat64Int64(a float64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEFloat64Float64(a float64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult <= 0
	}

	return r
}

func performLEFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult <= 0
	}

	return r
}

func performLETimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult <= 0
	}

	return r
}

func performLEIntervalInterval(a duration.Duration, b duration.Duration) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = a.Compare(b)
		r = cmpResult <= 0
	}

	return r
}

func performGTBoolBool(a bool, b bool) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult > 0
	}

	return r
}

func performGTBytesBytes(a []byte, b []byte) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult > 0
	}

	return r
}

func performGTDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult > 0
	}

	return r
}

func performGTDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult > 0
	}

	return r
}

func performGTDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult > 0
	}

	return r
}

func performGTDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult > 0
	}

	return r
}

func performGTDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult > 0
	}

	return r
}

func performGTInt16Int16(a int16, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt16Int32(a int16, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt16Int64(a int16, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt32Int16(a int32, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt32Int32(a int32, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt32Int64(a int32, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt64Int16(a int64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt64Int32(a int64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt64Int64(a int64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt16Float64(a int16, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt32Float64(a int32, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt64Float64(a int64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult > 0
	}

	return r
}

func performGTInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult > 0
	}

	return r
}

func performGTFloat64Int16(a float64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTFloat64Int32(a float64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTFloat64Int64(a float64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTFloat64Float64(a float64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult > 0
	}

	return r
}

func performGTFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult > 0
	}

	return r
}

func performGTTimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult > 0
	}

	return r
}

func performGTIntervalInterval(a duration.Duration, b duration.Duration) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = a.Compare(b)
		r = cmpResult > 0
	}

	return r
}

func performGEBoolBool(a bool, b bool) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if !a && b {
			cmpResult = -1
		} else if a && !b {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEBytesBytes(a []byte, b []byte) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = bytes.Compare(a, b)
		r = cmpResult >= 0
	}

	return r
}

func performGEDecimalInt16(a apd.Decimal, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEDecimalInt32(a apd.Decimal, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEDecimalInt64(a apd.Decimal, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(b))
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEDecimalFloat64(a apd.Decimal, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(b)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(&a, tmpDec)
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEDecimalDecimal(a apd.Decimal, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&a, &b)
		r = cmpResult >= 0
	}

	return r
}

func performGEInt16Int16(a int16, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt16Int32(a int16, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt16Int64(a int16, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt32Int16(a int32, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt32Int32(a int32, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt32Int64(a int32, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt64Int16(a int64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt64Int32(a int64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt64Int64(a int64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := int64(a), int64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt16Float64(a int16, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt32Float64(a int32, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt64Float64(a int64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if false {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt16Decimal(a int16, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt32Decimal(a int32, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEInt64Decimal(a int64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			tmpDec.SetInt64(int64(a))
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEFloat64Int16(a float64, b int16) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEFloat64Int32(a float64, b int32) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEFloat64Int64(a float64, b int64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if false {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEFloat64Float64(a float64, b float64) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			a, b := float64(a), float64(b)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		r = cmpResult >= 0
	}

	return r
}

func performGEFloat64Decimal(a float64, b apd.Decimal) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		{
			tmpDec := &_overloadHelper.tmpDec1
			if _, err := tmpDec.SetFloat64(float64(a)); err != nil {
				colexecerror.ExpectedError(err)
			}
			cmpResult = tree.CompareDecimals(tmpDec, &b)
		}

		r = cmpResult >= 0
	}

	return r
}

func performGETimestampTimestamp(a time.Time, b time.Time) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int

		if a.Before(b) {
			cmpResult = -1
		} else if b.Before(a) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		r = cmpResult >= 0
	}

	return r
}

func performGEIntervalInterval(a duration.Duration, b duration.Duration) bool {
	var r bool
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "overloadHelper".
	var _overloadHelper overloadHelper
	// However, the scratch is not used in all of the functions, so we add this
	// to go around "unused" error.
	_ = _overloadHelper

	{
		var cmpResult int
		cmpResult = a.Compare(b)
		r = cmpResult >= 0
	}

	return r
}
