// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexecjoin

import (
	"bytes"
	"context"
	"math"
	"time"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecop"
	"github.com/cockroachdb/cockroach/pkg/sql/execinfrapb"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

// Workaround for bazel auto-generated code. goimports does not automatically
// pick up the right packages when run within the bazel sandbox.
var (
	_ = typeconv.DatumVecCanonicalTypeFamily
	_ apd.Context
	_ coldataext.Datum
	_ duration.Duration
	_ tree.AggType
)

type mergeJoinLeftAntiOp struct {
	*mergeJoinBase
}

var _ colexecop.Operator = &mergeJoinLeftAntiOp{}

func (o *mergeJoinLeftAntiOp) probeBodyLSeltrueRSeltrue(ctx context.Context) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		leftColIdx := o.left.eqCols[eqColIdx]
		rightColIdx := o.right.eqCols[eqColIdx]
		lVec := o.proberState.lBatch.ColVec(int(leftColIdx))
		rVec := o.proberState.rBatch.ColVec(int(rightColIdx))
		colType := o.left.sourceTypes[leftColIdx]
		lNulls := lVec.Nulls()
		rNulls := rVec.Nulls()
		switch lVec.CanonicalTypeFamily() {
		case types.BoolFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Bool()
				rKeys := rVec.Bool()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       bool
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							if !lVal && rVal {
								cmp = -1
							} else if lVal && !rVal {
								cmp = 1
							} else {
								cmp = 0
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if !newLVal && lVal {
											cmpResult = -1
										} else if newLVal && !lVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										if !newRVal && rVal {
											cmpResult = -1
										} else if newRVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if !newLVal && lVal {
											cmpResult = -1
										} else if newLVal && !lVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.BytesFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Bytes()
				rKeys := rVec.Bytes()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       []byte
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)
							cmp = bytes.Compare(lVal, rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newLVal, lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newRVal, rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newLVal, lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.DecimalFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Decimal()
				rKeys := rVec.Decimal()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       apd.Decimal
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)
							cmp = tree.CompareDecimals(&lVal, &rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newLVal, &lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newRVal, &rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newLVal, &lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.IntFamily:
			switch colType.Width() {
			case 16:
				lKeys := lVec.Int16()
				rKeys := rVec.Int16()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int16
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			case 32:
				lKeys := lVec.Int32()
				rKeys := rVec.Int32()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int32
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			case -1:
			default:
				lKeys := lVec.Int64()
				rKeys := rVec.Int64()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int64
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.FloatFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Float64()
				rKeys := rVec.Float64()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       float64
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := float64(lVal), float64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else if a == b {
									cmp = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmp = 0
									} else {
										cmp = -1
									}
								} else {
									cmp = 1
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newLVal), float64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newRVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newLVal), float64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.TimestampTZFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Timestamp()
				rKeys := rVec.Timestamp()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       time.Time
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							if lVal.Before(rVal) {
								cmp = -1
							} else if rVal.Before(lVal) {
								cmp = 1
							} else {
								cmp = 0
							}
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if newLVal.Before(lVal) {
											cmpResult = -1
										} else if lVal.Before(newLVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										if newRVal.Before(rVal) {
											cmpResult = -1
										} else if rVal.Before(newRVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if newLVal.Before(lVal) {
											cmpResult = -1
										} else if lVal.Before(newLVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.IntervalFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Interval()
				rKeys := rVec.Interval()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       duration.Duration
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)
							cmp = lVal.Compare(rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = newLVal.Compare(lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = newRVal.Compare(rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = newLVal.Compare(lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Datum()
				rKeys := rVec.Datum()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       interface{}
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		default:
			colexecerror.InternalError(errors.AssertionFailedf("unhandled type %s", colType))
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftAntiOp) probeBodyLSeltrueRSelfalse(ctx context.Context) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		leftColIdx := o.left.eqCols[eqColIdx]
		rightColIdx := o.right.eqCols[eqColIdx]
		lVec := o.proberState.lBatch.ColVec(int(leftColIdx))
		rVec := o.proberState.rBatch.ColVec(int(rightColIdx))
		colType := o.left.sourceTypes[leftColIdx]
		lNulls := lVec.Nulls()
		rNulls := rVec.Nulls()
		switch lVec.CanonicalTypeFamily() {
		case types.BoolFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Bool()
				rKeys := rVec.Bool()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       bool
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							if !lVal && rVal {
								cmp = -1
							} else if lVal && !rVal {
								cmp = 1
							} else {
								cmp = 0
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if !newLVal && lVal {
											cmpResult = -1
										} else if newLVal && !lVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										if !newRVal && rVal {
											cmpResult = -1
										} else if newRVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if !newLVal && lVal {
											cmpResult = -1
										} else if newLVal && !lVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.BytesFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Bytes()
				rKeys := rVec.Bytes()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       []byte
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)
							cmp = bytes.Compare(lVal, rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newLVal, lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newRVal, rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newLVal, lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.DecimalFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Decimal()
				rKeys := rVec.Decimal()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       apd.Decimal
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)
							cmp = tree.CompareDecimals(&lVal, &rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newLVal, &lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newRVal, &rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newLVal, &lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.IntFamily:
			switch colType.Width() {
			case 16:
				lKeys := lVec.Int16()
				rKeys := rVec.Int16()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int16
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			case 32:
				lKeys := lVec.Int32()
				rKeys := rVec.Int32()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int32
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			case -1:
			default:
				lKeys := lVec.Int64()
				rKeys := rVec.Int64()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int64
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.FloatFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Float64()
				rKeys := rVec.Float64()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       float64
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := float64(lVal), float64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else if a == b {
									cmp = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmp = 0
									} else {
										cmp = -1
									}
								} else {
									cmp = 1
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newLVal), float64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newRVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newLVal), float64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.TimestampTZFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Timestamp()
				rKeys := rVec.Timestamp()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       time.Time
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							if lVal.Before(rVal) {
								cmp = -1
							} else if rVal.Before(lVal) {
								cmp = 1
							} else {
								cmp = 0
							}
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if newLVal.Before(lVal) {
											cmpResult = -1
										} else if lVal.Before(newLVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										if newRVal.Before(rVal) {
											cmpResult = -1
										} else if rVal.Before(newRVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if newLVal.Before(lVal) {
											cmpResult = -1
										} else if lVal.Before(newLVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.IntervalFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Interval()
				rKeys := rVec.Interval()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       duration.Duration
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)
							cmp = lVal.Compare(rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = newLVal.Compare(lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = newRVal.Compare(rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = newLVal.Compare(lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Datum()
				rKeys := rVec.Datum()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       interface{}
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(lSel[curLIdx])
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = lSel[curLIdx]
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(lSel[curLIdx]) {
										lComplete = true
										break
									}
									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(lSel[curLIdx]) {
										break
									}

									lSelIdx = lSel[curLIdx]
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		default:
			colexecerror.InternalError(errors.AssertionFailedf("unhandled type %s", colType))
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftAntiOp) probeBodyLSelfalseRSeltrue(ctx context.Context) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		leftColIdx := o.left.eqCols[eqColIdx]
		rightColIdx := o.right.eqCols[eqColIdx]
		lVec := o.proberState.lBatch.ColVec(int(leftColIdx))
		rVec := o.proberState.rBatch.ColVec(int(rightColIdx))
		colType := o.left.sourceTypes[leftColIdx]
		lNulls := lVec.Nulls()
		rNulls := rVec.Nulls()
		switch lVec.CanonicalTypeFamily() {
		case types.BoolFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Bool()
				rKeys := rVec.Bool()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       bool
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							if !lVal && rVal {
								cmp = -1
							} else if lVal && !rVal {
								cmp = 1
							} else {
								cmp = 0
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if !newLVal && lVal {
											cmpResult = -1
										} else if newLVal && !lVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										if !newRVal && rVal {
											cmpResult = -1
										} else if newRVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if !newLVal && lVal {
											cmpResult = -1
										} else if newLVal && !lVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.BytesFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Bytes()
				rKeys := rVec.Bytes()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       []byte
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)
							cmp = bytes.Compare(lVal, rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newLVal, lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newRVal, rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newLVal, lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.DecimalFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Decimal()
				rKeys := rVec.Decimal()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       apd.Decimal
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)
							cmp = tree.CompareDecimals(&lVal, &rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newLVal, &lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newRVal, &rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newLVal, &lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.IntFamily:
			switch colType.Width() {
			case 16:
				lKeys := lVec.Int16()
				rKeys := rVec.Int16()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int16
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			case 32:
				lKeys := lVec.Int32()
				rKeys := rVec.Int32()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int32
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			case -1:
			default:
				lKeys := lVec.Int64()
				rKeys := rVec.Int64()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int64
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.FloatFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Float64()
				rKeys := rVec.Float64()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       float64
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := float64(lVal), float64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else if a == b {
									cmp = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmp = 0
									} else {
										cmp = -1
									}
								} else {
									cmp = 1
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newLVal), float64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newRVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newLVal), float64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.TimestampTZFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Timestamp()
				rKeys := rVec.Timestamp()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       time.Time
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							if lVal.Before(rVal) {
								cmp = -1
							} else if rVal.Before(lVal) {
								cmp = 1
							} else {
								cmp = 0
							}
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if newLVal.Before(lVal) {
											cmpResult = -1
										} else if lVal.Before(newLVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										if newRVal.Before(rVal) {
											cmpResult = -1
										} else if rVal.Before(newRVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if newLVal.Before(lVal) {
											cmpResult = -1
										} else if lVal.Before(newLVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.IntervalFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Interval()
				rKeys := rVec.Interval()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       duration.Duration
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)
							cmp = lVal.Compare(rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = newLVal.Compare(lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = newRVal.Compare(rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = newLVal.Compare(lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Datum()
				rKeys := rVec.Datum()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       interface{}
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(rSel[curRIdx])

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = rSel[curRIdx]
							rVal = rKeys.Get(rSelIdx)

							cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(rSel[curRIdx]) {
										rComplete = true
										break
									}
									rSelIdx = rSel[curRIdx]
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		default:
			colexecerror.InternalError(errors.AssertionFailedf("unhandled type %s", colType))
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftAntiOp) probeBodyLSelfalseRSelfalse(ctx context.Context) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		leftColIdx := o.left.eqCols[eqColIdx]
		rightColIdx := o.right.eqCols[eqColIdx]
		lVec := o.proberState.lBatch.ColVec(int(leftColIdx))
		rVec := o.proberState.rBatch.ColVec(int(rightColIdx))
		colType := o.left.sourceTypes[leftColIdx]
		lNulls := lVec.Nulls()
		rNulls := rVec.Nulls()
		switch lVec.CanonicalTypeFamily() {
		case types.BoolFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Bool()
				rKeys := rVec.Bool()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       bool
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							if !lVal && rVal {
								cmp = -1
							} else if lVal && !rVal {
								cmp = 1
							} else {
								cmp = 0
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if !newLVal && lVal {
											cmpResult = -1
										} else if newLVal && !lVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										if !newRVal && rVal {
											cmpResult = -1
										} else if newRVal && !rVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if !newLVal && lVal {
											cmpResult = -1
										} else if newLVal && !lVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.BytesFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Bytes()
				rKeys := rVec.Bytes()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       []byte
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)
							cmp = bytes.Compare(lVal, rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newLVal, lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newRVal, rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = bytes.Compare(newLVal, lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.DecimalFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Decimal()
				rKeys := rVec.Decimal()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       apd.Decimal
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)
							cmp = tree.CompareDecimals(&lVal, &rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newLVal, &lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newRVal, &rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&newLVal, &lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.IntFamily:
			switch colType.Width() {
			case 16:
				lKeys := lVec.Int16()
				rKeys := rVec.Int16()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int16
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			case 32:
				lKeys := lVec.Int32()
				rKeys := rVec.Int32()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int32
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			case -1:
			default:
				lKeys := lVec.Int64()
				rKeys := rVec.Int64()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       int64
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := int64(lVal), int64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else {
									cmp = 0
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newRVal), int64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := int64(newLVal), int64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.FloatFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Float64()
				rKeys := rVec.Float64()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       float64
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							{
								a, b := float64(lVal), float64(rVal)
								if a < b {
									cmp = -1
								} else if a > b {
									cmp = 1
								} else if a == b {
									cmp = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmp = 0
									} else {
										cmp = -1
									}
								} else {
									cmp = 1
								}
							}

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newLVal), float64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newRVal), float64(rVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										{
											a, b := float64(newLVal), float64(lVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.TimestampTZFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Timestamp()
				rKeys := rVec.Timestamp()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       time.Time
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							if lVal.Before(rVal) {
								cmp = -1
							} else if rVal.Before(lVal) {
								cmp = 1
							} else {
								cmp = 0
							}
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if newLVal.Before(lVal) {
											cmpResult = -1
										} else if lVal.Before(newLVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										if newRVal.Before(rVal) {
											cmpResult = -1
										} else if rVal.Before(newRVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										if newLVal.Before(lVal) {
											cmpResult = -1
										} else if lVal.Before(newLVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case types.IntervalFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Interval()
				rKeys := rVec.Interval()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       duration.Duration
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)
							cmp = lVal.Compare(rVal)
						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = newLVal.Compare(lVal)
										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int
										cmpResult = newRVal.Compare(rVal)
										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int
										cmpResult = newLVal.Compare(lVal)
										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch colType.Width() {
			case -1:
			default:
				lKeys := lVec.Datum()
				rKeys := rVec.Datum()
				var (
					lGroup, rGroup   group
					cmp              int
					match            bool
					lVal, rVal       interface{}
					lSelIdx, rSelIdx int
				)

				for o.groups.nextGroupInCol(&lGroup, &rGroup) {
					curLIdx := lGroup.rowStartIdx
					curRIdx := rGroup.rowStartIdx
					curLEndIdx := lGroup.rowEndIdx
					curREndIdx := rGroup.rowEndIdx
					areGroupsProcessed := false
					if lGroup.unmatched {
						if curLIdx+1 != curLEndIdx {
							colexecerror.InternalError(errors.AssertionFailedf("unexpectedly length %d of the left unmatched group is not 1", curLEndIdx-curLIdx))
						}
						// The row already does not have a match, so we don't need to do any
						// additional processing.
						o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
						curLIdx++
						areGroupsProcessed = true
					}
					// Expand or filter each group based on the current equality column.
					for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
						cmp = 0
						lNull := lNulls.NullAt(curLIdx)
						rNull := rNulls.NullAt(curRIdx)

						// TODO(yuzefovich): we can advance both sides if both are
						// NULL.
						if lNull {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
							continue
						}
						if rNull {
							curRIdx++
							continue
						}

						needToCompare := true
						if needToCompare {
							lSelIdx = curLIdx
							lVal = lKeys.Get(lSelIdx)
							rSelIdx = curRIdx
							rVal = rKeys.Get(rSelIdx)

							cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

						}

						if cmp == 0 {
							// Find the length of the groups on each side.
							lGroupLength, rGroupLength := 1, 1
							// If a group ends before the end of the probing batch,
							// then we know it is complete.
							lComplete := curLEndIdx < o.proberState.lLength
							rComplete := curREndIdx < o.proberState.rLength
							beginLIdx, beginRIdx := curLIdx, curRIdx
							curLIdx++
							curRIdx++

							// Find the length of the group on the left.
							for curLIdx < curLEndIdx {
								{
									if lNulls.NullAt(curLIdx) {
										lComplete = true
										break
									}
									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

										match = cmpResult == 0
									}

									if !match {
										lComplete = true
										break
									}
								}
								lGroupLength++
								curLIdx++
							}

							// Find the length of the group on the right.
							for curRIdx < curREndIdx {
								{
									if rNulls.NullAt(curRIdx) {
										rComplete = true
										break
									}
									rSelIdx = curRIdx
									newRVal := rKeys.Get(rSelIdx)

									{
										var cmpResult int

										cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

										match = cmpResult == 0
									}

									if !match {
										rComplete = true
										break
									}
								}
								rGroupLength++
								curRIdx++
							}

							// Last equality column and either group is incomplete. Save state
							// and have it handled in the next iteration.
							if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
								o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
								o.proberState.lIdx = lGroupLength + beginLIdx
								o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
								o.proberState.rIdx = rGroupLength + beginRIdx

								o.groups.finishedCol()
								break EqLoop
							}

							if eqColIdx < len(o.left.eqCols)-1 {
								o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
							} else {
								// With LEFT ANTI join, we are only interested in unmatched tuples
								// from the left, and all tuples in the current group have a match.
							}
						} else { // mismatch
							// The line below is a compact form of the following:
							//   incrementLeft :=
							//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
							//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
							incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
							if incrementLeft {
								curLIdx++
								// All the rows on the left within the current group will not get a match on
								// the right, so we're adding each of them as a left unmatched group.
								o.groups.addLeftUnmatchedGroup(curLIdx-1, curRIdx)
								for curLIdx < curLEndIdx {
									if lNulls.NullAt(curLIdx) {
										break
									}

									lSelIdx = curLIdx
									newLVal := lKeys.Get(lSelIdx)

									{
										var cmpResult int

										cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

										match = cmpResult == 0
									}

									if !match {
										break
									}
									o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
									curLIdx++
								}
							} else {
								curRIdx++
							}
						}
					}
					if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
						// The current group is not the last one within the column, so it cannot be
						// extended into the next batch, and we need to process it right now. Any
						// unprocessed row in the left group will not get a match, so each one of
						// them becomes a new unmatched group with a corresponding null group.
						for curLIdx < curLEndIdx {
							o.groups.addLeftUnmatchedGroup(curLIdx, curRIdx)
							curLIdx++
						}
					}
					// Both o.proberState.lIdx and o.proberState.rIdx should point to the
					// last elements processed in their respective batches.
					o.proberState.lIdx = curLIdx
					o.proberState.rIdx = curRIdx
				}
			}
		default:
			colexecerror.InternalError(errors.AssertionFailedf("unhandled type %s", colType))
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

// buildLeftGroupsFromBatch takes a []group and expands each group into the
// output by repeating each row in the group numRepeats times. For example,
// given an input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroupsFromBatch expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroupsFromBatch in that each row of
// group is repeated numRepeats times, instead of a simple copy of the group as
// a whole.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinLeftAntiOp) buildLeftGroupsFromBatch(
	leftGroups []group, input *mergeJoinInput, batch coldata.Batch, destStartIdx int,
) {
	sel := batch.Selection()
	initialBuilderState := o.builderState.left
	o.unlimitedAllocator.PerformOperation(
		o.output.ColVecs()[:len(input.sourceTypes)],
		func() {
			// Loop over every column.
		LeftColLoop:
			for colIdx := range input.sourceTypes {
				outStartIdx := destStartIdx
				out := o.output.ColVec(colIdx)
				var src coldata.Vec
				if batch.Length() > 0 {
					src = batch.ColVec(colIdx)
				}
				if sel != nil {
					var srcNulls *coldata.Nulls
					if src != nil {
						srcNulls = src.Nulls()
					}
					outNulls := out.Nulls()
					switch input.canonicalTypeFamilies[colIdx] {
					case types.BoolFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Bools
							if src != nil {
								srcCol = src.Bool()
							}
							outCol := out.Bool()
							var val bool
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.BytesFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol *coldata.Bytes
							if src != nil {
								srcCol = src.Bytes()
							}
							outCol := out.Bytes()
							var val []byte
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol.Set(outStartIdx, val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.DecimalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Decimals
							if src != nil {
								srcCol = src.Decimal()
							}
							outCol := out.Decimal()
							var val apd.Decimal
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx].Set(&val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.IntFamily:
						switch input.sourceTypes[colIdx].Width() {
						case 16:
							var srcCol coldata.Int16s
							if src != nil {
								srcCol = src.Int16()
							}
							outCol := out.Int16()
							var val int16
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case 32:
							var srcCol coldata.Int32s
							if src != nil {
								srcCol = src.Int32()
							}
							outCol := out.Int32()
							var val int32
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case -1:
						default:
							var srcCol coldata.Int64s
							if src != nil {
								srcCol = src.Int64()
							}
							outCol := out.Int64()
							var val int64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.FloatFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Float64s
							if src != nil {
								srcCol = src.Float64()
							}
							outCol := out.Float64()
							var val float64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.TimestampTZFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Times
							if src != nil {
								srcCol = src.Timestamp()
							}
							outCol := out.Timestamp()
							var val time.Time
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.IntervalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Durations
							if src != nil {
								srcCol = src.Interval()
							}
							outCol := out.Interval()
							var val duration.Duration
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.DatumVec
							if src != nil {
								srcCol = src.Datum()
							}
							outCol := out.Datum()
							var val interface{}
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = sel[srcStartIdx]

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol.Set(outStartIdx, val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					default:
						colexecerror.InternalError(errors.AssertionFailedf("unhandled type %s", input.sourceTypes[colIdx].String()))
					}
				} else {
					var srcNulls *coldata.Nulls
					if src != nil {
						srcNulls = src.Nulls()
					}
					outNulls := out.Nulls()
					switch input.canonicalTypeFamilies[colIdx] {
					case types.BoolFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Bools
							if src != nil {
								srcCol = src.Bool()
							}
							outCol := out.Bool()
							var val bool
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.BytesFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol *coldata.Bytes
							if src != nil {
								srcCol = src.Bytes()
							}
							outCol := out.Bytes()
							var val []byte
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol.Set(outStartIdx, val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.DecimalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Decimals
							if src != nil {
								srcCol = src.Decimal()
							}
							outCol := out.Decimal()
							var val apd.Decimal
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx].Set(&val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.IntFamily:
						switch input.sourceTypes[colIdx].Width() {
						case 16:
							var srcCol coldata.Int16s
							if src != nil {
								srcCol = src.Int16()
							}
							outCol := out.Int16()
							var val int16
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case 32:
							var srcCol coldata.Int32s
							if src != nil {
								srcCol = src.Int32()
							}
							outCol := out.Int32()
							var val int32
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case -1:
						default:
							var srcCol coldata.Int64s
							if src != nil {
								srcCol = src.Int64()
							}
							outCol := out.Int64()
							var val int64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.FloatFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Float64s
							if src != nil {
								srcCol = src.Float64()
							}
							outCol := out.Float64()
							var val float64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.TimestampTZFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Times
							if src != nil {
								srcCol = src.Timestamp()
							}
							outCol := out.Timestamp()
							var val time.Time
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.IntervalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Durations
							if src != nil {
								srcCol = src.Interval()
							}
							outCol := out.Interval()
							var val duration.Duration
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.DatumVec
							if src != nil {
								srcCol = src.Datum()
							}
							outCol := out.Datum()
							var val interface{}
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								if !leftGroup.unmatched {
									continue
								}
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										if srcNulls.NullAt(srcStartIdx) {
											outNulls.SetNullRange(outStartIdx, outStartIdx+toAppend)
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol.Set(outStartIdx, val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if colIdx == len(input.sourceTypes)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						}
					default:
						colexecerror.InternalError(errors.AssertionFailedf("unhandled type %s", input.sourceTypes[colIdx].String()))
					}
				}
				o.builderState.left.setBuilderColumnState(initialBuilderState)
			}
			o.builderState.left.reset()
		},
	)
}

// buildRightGroupsFromBatch takes a []group and repeats each group numRepeats
// times. For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroupsFromBatch in that each group is
// not expanded but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinLeftAntiOp) buildRightGroupsFromBatch(
	rightGroups []group, colOffset int, input *mergeJoinInput, batch coldata.Batch, destStartIdx int,
) {
	initialBuilderState := o.builderState.right
	sel := batch.Selection()
	o.unlimitedAllocator.PerformOperation(
		o.output.ColVecs()[colOffset:colOffset+len(input.sourceTypes)],
		func() {
			// Loop over every column.
		RightColLoop:
			for colIdx := range input.sourceTypes {
				outStartIdx := destStartIdx
				out := o.output.ColVec(colIdx + colOffset)
				var src coldata.Vec
				if batch.Length() > 0 {
					src = batch.ColVec(colIdx)
				}
				if sel != nil {
					var srcNulls *coldata.Nulls
					if src != nil {
						srcNulls = src.Nulls()
					}
					outNulls := out.Nulls()
					switch input.canonicalTypeFamilies[colIdx] {
					case types.BoolFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Bools
							if src != nil {
								srcCol = src.Bool()
							}
							outCol := out.Bool()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.BytesFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol *coldata.Bytes
							if src != nil {
								srcCol = src.Bytes()
							}
							outCol := out.Bytes()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol.Set(outStartIdx, v)
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.DecimalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Decimals
							if src != nil {
								srcCol = src.Decimal()
							}
							outCol := out.Decimal()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx].Set(&v)
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.IntFamily:
						switch input.sourceTypes[colIdx].Width() {
						case 16:
							var srcCol coldata.Int16s
							if src != nil {
								srcCol = src.Int16()
							}
							outCol := out.Int16()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						case 32:
							var srcCol coldata.Int32s
							if src != nil {
								srcCol = src.Int32()
							}
							outCol := out.Int32()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						case -1:
						default:
							var srcCol coldata.Int64s
							if src != nil {
								srcCol = src.Int64()
							}
							outCol := out.Int64()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.FloatFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Float64s
							if src != nil {
								srcCol = src.Float64()
							}
							outCol := out.Float64()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.TimestampTZFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Times
							if src != nil {
								srcCol = src.Timestamp()
							}
							outCol := out.Timestamp()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.IntervalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Durations
							if src != nil {
								srcCol = src.Interval()
							}
							outCol := out.Interval()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.DatumVec
							if src != nil {
								srcCol = src.Datum()
							}
							outCol := out.Datum()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := sel[o.builderState.right.curSrcStartIdx]
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol.Set(outStartIdx, v)
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					default:
						colexecerror.InternalError(errors.AssertionFailedf("unhandled type %s", input.sourceTypes[colIdx].String()))
					}
				} else {
					var srcNulls *coldata.Nulls
					if src != nil {
						srcNulls = src.Nulls()
					}
					outNulls := out.Nulls()
					switch input.canonicalTypeFamilies[colIdx] {
					case types.BoolFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Bools
							if src != nil {
								srcCol = src.Bool()
							}
							outCol := out.Bool()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.BytesFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol *coldata.Bytes
							if src != nil {
								srcCol = src.Bytes()
							}
							outCol := out.Bytes()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol.Set(outStartIdx, v)
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.DecimalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Decimals
							if src != nil {
								srcCol = src.Decimal()
							}
							outCol := out.Decimal()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx].Set(&v)
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.IntFamily:
						switch input.sourceTypes[colIdx].Width() {
						case 16:
							var srcCol coldata.Int16s
							if src != nil {
								srcCol = src.Int16()
							}
							outCol := out.Int16()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						case 32:
							var srcCol coldata.Int32s
							if src != nil {
								srcCol = src.Int32()
							}
							outCol := out.Int32()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						case -1:
						default:
							var srcCol coldata.Int64s
							if src != nil {
								srcCol = src.Int64()
							}
							outCol := out.Int64()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.FloatFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Float64s
							if src != nil {
								srcCol = src.Float64()
							}
							outCol := out.Float64()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.TimestampTZFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Times
							if src != nil {
								srcCol = src.Timestamp()
							}
							outCol := out.Timestamp()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case types.IntervalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.Durations
							if src != nil {
								srcCol = src.Interval()
							}
							outCol := out.Interval()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol[outStartIdx] = v
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							var srcCol coldata.DatumVec
							if src != nil {
								srcCol = src.Datum()
							}
							outCol := out.Datum()

							// Loop over every group.
							for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
								rightGroup := &rightGroups[o.builderState.right.groupsIdx]
								// Repeat every group numRepeats times.
								for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
									if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
									}
									toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
									if outStartIdx+toAppend > o.output.Capacity() {
										toAppend = o.output.Capacity() - outStartIdx
									}

									{
										// Optimization in the case that group length is 1, use assign
										// instead of copy.
										if toAppend == 1 {
											srcIdx := o.builderState.right.curSrcStartIdx
											if srcNulls.NullAt(srcIdx) {
												outNulls.SetNull(outStartIdx)
											} else {
												v := srcCol.Get(srcIdx)
												outCol.Set(outStartIdx, v)
											}
										} else {
											out.Copy(
												coldata.CopySliceArgs{
													SliceArgs: coldata.SliceArgs{
														Src:         src,
														Sel:         sel,
														DestIdx:     outStartIdx,
														SrcStartIdx: o.builderState.right.curSrcStartIdx,
														SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
													},
												},
											)
										}
									}

									outStartIdx += toAppend

									// If we haven't materialized all the rows from the group, then we are
									// done with the current column.
									if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
										// If it's the last column, save state and return.
										if colIdx == len(input.sourceTypes)-1 {
											o.builderState.right.curSrcStartIdx += toAppend
											return
										}
										// Otherwise, reset to the initial state and begin the next column.
										o.builderState.right.setBuilderColumnState(initialBuilderState)
										continue RightColLoop
									}
									o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
							}
							o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
						}
					default:
						colexecerror.InternalError(errors.AssertionFailedf("unhandled type %s", input.sourceTypes[colIdx].String()))
					}
				}
				o.builderState.right.setBuilderColumnState(initialBuilderState)
			}
			o.builderState.right.reset()
		})
}

// probe is where we generate the groups slices that are used in the build
// phase. We do this by first assuming that every row in both batches
// contributes to the cross product. Then, with every equality column, we
// filter out the rows that don't contribute to the cross product (i.e. they
// don't have a matching row on the other side in the case of an inner join),
// and set the correct cardinality.
// Note that in this phase, we do this for every group, except the last group
// in the batch.
func (o *mergeJoinLeftAntiOp) probe(ctx context.Context) {
	o.groups.reset(o.proberState.lIdx, o.proberState.lLength, o.proberState.rIdx, o.proberState.rLength)
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
	if lSel != nil {
		if rSel != nil {
			o.probeBodyLSeltrueRSeltrue(ctx)
		} else {
			o.probeBodyLSeltrueRSelfalse(ctx)
		}
	} else {
		if rSel != nil {
			o.probeBodyLSelfalseRSeltrue(ctx)
		} else {
			o.probeBodyLSelfalseRSelfalse(ctx)
		}
	}
}

// setBuilderSourceToBufferedGroup sets up the builder state to use the
// buffered group.
func (o *mergeJoinLeftAntiOp) setBuilderSourceToBufferedGroup(ctx context.Context) {
	o.builderState.buildFrom = mjBuildFromBufferedGroup
	o.bufferedGroup.helper.setupBuilder()
	o.builderState.totalOutCountFromBufferedGroup = o.bufferedGroup.helper.calculateOutputCount()
	o.builderState.alreadyEmittedFromBufferedGroup = 0

	// We cannot yet reset the buffered groups because the builder will be taking
	// input from them. The actual reset will take place on the next call to
	// initProberState().
	o.bufferedGroup.needToReset = true
}

// exhaustLeftSource sets up the builder to process any remaining tuples from
// the left source. It should only be called when the right source has been
// exhausted.
func (o *mergeJoinLeftAntiOp) exhaustLeftSource(ctx context.Context) {
	// The capacity of builder state lGroups and rGroups is always at least 1
	// given the init.
	o.builderState.lGroups = o.builderState.lGroups[:1]
	o.builderState.lGroups[0] = group{
		rowStartIdx: o.proberState.lIdx,
		rowEndIdx:   o.proberState.lLength,
		numRepeats:  1,
		toBuild:     o.proberState.lLength - o.proberState.lIdx,
		unmatched:   true,
	}

	o.proberState.lIdx = o.proberState.lLength
}

// exhaustRightSource sets up the builder to process any remaining tuples from
// the right source. It should only be called when the left source has been
// exhausted.
func (o *mergeJoinLeftAntiOp) exhaustRightSource() {
	// Remaining tuples from the right source do not have a match, so they are
	// ignored in all joins except for RIGHT OUTER and FULL OUTER.
}

// calculateOutputCount uses the toBuild field of each group and the output
// batch size to determine the output count. Note that as soon as a group is
// materialized partially or fully to output, its toBuild field is updated
// accordingly.
func (o *mergeJoinLeftAntiOp) calculateOutputCount(groups []group) int {
	count := o.builderState.outCount

	for i := 0; i < len(groups); i++ {
		if !groups[i].unmatched {
			// "Matched" groups are not outputted in LEFT ANTI, RIGHT ANTI,
			// and EXCEPT ALL joins (for the latter IsLeftAnti == true), so
			// they do not contribute to the output count.
			continue
		}
		count += groups[i].toBuild
		groups[i].toBuild = 0
		if count > o.output.Capacity() {
			groups[i].toBuild = count - o.output.Capacity()
			count = o.output.Capacity()
			return count
		}
	}
	o.builderState.outFinished = true
	return count
}

// build creates the cross product, and writes it to the output member.
func (o *mergeJoinLeftAntiOp) build(ctx context.Context) {
	outStartIdx := o.builderState.outCount
	switch o.builderState.buildFrom {
	case mjBuildFromBatch:
		o.builderState.outCount = o.calculateOutputCount(o.builderState.lGroups)
		if o.output.Width() != 0 && o.builderState.outCount > outStartIdx {
			// We will be actually building the output if we have columns in the output
			// batch (meaning that we're not doing query like 'SELECT count(*) ...')
			// and when builderState.outCount has increased (meaning that we have
			// something to build).
			colOffsetForRightGroups := 0
			o.buildLeftGroupsFromBatch(o.builderState.lGroups, &o.left, o.proberState.lBatch, outStartIdx)
			colOffsetForRightGroups = len(o.left.sourceTypes)
			_ = colOffsetForRightGroups
		}

	case mjBuildFromBufferedGroup:
		willEmit := o.builderState.totalOutCountFromBufferedGroup - o.builderState.alreadyEmittedFromBufferedGroup
		if o.builderState.outCount+willEmit > o.output.Capacity() {
			willEmit = o.output.Capacity() - o.builderState.outCount
		} else {
			o.builderState.outFinished = true
		}
		o.builderState.outCount += willEmit
		o.builderState.alreadyEmittedFromBufferedGroup += willEmit
		if o.output.Width() != 0 && willEmit > 0 {
			o.bufferedGroup.helper.buildFromLeftInput(ctx, outStartIdx)
		}

	default:
		colexecerror.InternalError(errors.AssertionFailedf("unsupported mjBuildFrom %d", o.builderState.buildFrom))

	}
}

func (o *mergeJoinLeftAntiOp) Next(ctx context.Context) coldata.Batch {
	o.output, _ = o.unlimitedAllocator.ResetMaybeReallocate(
		o.outputTypes, o.output, 1 /* minCapacity */, o.memoryLimit,
	)
	o.bufferedGroup.helper.output = o.output
	for {
		switch o.state {
		case mjEntry:
			o.initProberState(ctx)

			if o.nonEmptyBufferedGroup() {
				o.state = mjFinishBufferedGroup
				break
			}

			if o.sourceFinished() {
				o.state = mjSourceFinished
				break
			}

			o.state = mjProbe
		case mjSourceFinished:
			o.outputReady = true
			o.builderState.buildFrom = mjBuildFromBatch
			// Next, we need to make sure that builder state is set up for a case when
			// neither exhaustLeftSource nor exhaustRightSource is called below. In such
			// scenario the merge joiner is done, so it'll be outputting zero-length
			// batches from now on.
			o.builderState.lGroups = o.builderState.lGroups[:0]
			o.builderState.rGroups = o.builderState.rGroups[:0]
			// At least one of the sources is finished. If it was the right one,
			// then we need to emit remaining tuples from the left source with
			// nulls corresponding to the right one. But if the left source is
			// finished, then there is nothing left to do.
			if o.proberState.lIdx < o.proberState.lLength {
				o.exhaustLeftSource(ctx)
				// We unset o.outputReady here because we want to put as many unmatched
				// tuples from the left into the output batch. Once outCount reaches the
				// desired output batch size, the output will be returned.
				o.outputReady = false
			}
			o.state = mjBuild
		case mjFinishBufferedGroup:
			o.finishProbe(ctx)
			o.setBuilderSourceToBufferedGroup(ctx)
			o.state = mjBuild
		case mjProbe:
			o.probe(ctx)
			o.setBuilderSourceToBatch()
			o.state = mjBuild
		case mjBuild:
			o.build(ctx)

			if o.builderState.outFinished {
				o.state = mjEntry
				o.builderState.outFinished = false
			}

			if o.outputReady || o.builderState.outCount == o.output.Capacity() {
				if o.builderState.outCount == 0 {
					// We have already fully emitted the result of the join, so we
					// transition to "finished" state.
					o.state = mjDone
					continue
				}
				o.output.SetLength(o.builderState.outCount)
				// Reset builder out count.
				o.builderState.outCount = 0
				o.outputReady = false
				return o.output
			}
		case mjDone:
			// Note that resetting of buffered group will close disk queues
			// (if there are any).
			if o.bufferedGroup.needToReset {
				o.bufferedGroup.helper.Reset(ctx)
				o.bufferedGroup.needToReset = false
			}
			return coldata.ZeroBatch
		default:
			colexecerror.InternalError(errors.AssertionFailedf("unexpected merge joiner state in Next: %v", o.state))
		}
	}
}
