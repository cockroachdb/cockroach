// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"fmt"
	"math"
	"time"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/execinfrapb"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
)

type mergeJoinLeftSemiOp struct {
	*mergeJoinBase
}

var _ InternalMemoryOperator = &mergeJoinLeftSemiOp{}

func (o *mergeJoinLeftSemiOp) probeBodyLSeltrueRSeltrue(ctx context.Context) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		leftColIdx := o.left.eqCols[eqColIdx]
		rightColIdx := o.right.eqCols[eqColIdx]
		lVec := o.proberState.lBatch.ColVec(int(leftColIdx))
		rVec := o.proberState.rBatch.ColVec(int(rightColIdx))
		leftType := o.left.sourceTypes[leftColIdx]
		rightType := o.right.sourceTypes[rightColIdx]
		colType := leftType
		// Merge joiner only supports the case when the physical types in the
		// equality columns in both inputs are the same. If that is not the case,
		// we need to cast one of the vectors to another's physical type putting
		// the result of the cast into a temporary vector that is used instead of
		// the original.
		leftCanonicalTypeFamily := o.left.canonicalTypeFamilies[leftColIdx]
		isNumeric := leftCanonicalTypeFamily == types.IntFamily ||
			leftCanonicalTypeFamily == types.FloatFamily ||
			leftCanonicalTypeFamily == types.DecimalFamily
		if isNumeric && !leftType.Identical(rightType) {
			castLeftToRight := false
			// There is a hierarchy of valid casts:
			//   Int16 -> Int32 -> Int64 -> Float64 -> Decimal
			// and the cast is valid if 'fromType' is mentioned before 'toType'
			// in this chain.
			switch leftCanonicalTypeFamily {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					castLeftToRight = true
				case 32:
					castLeftToRight = !rightType.Identical(types.Int2)
				case 64:
					castLeftToRight = !rightType.Identical(types.Int2) && !rightType.Identical(types.Int4)
				}
			case types.FloatFamily:
				castLeftToRight = o.right.canonicalTypeFamilies[rightColIdx] == types.DecimalFamily
			}

			toType := leftType
			if castLeftToRight {
				toType = rightType
			}
			var tempVec coldata.Vec
			for _, vec := range o.scratch.tempVecs {
				if vec.Type().Identical(toType) {
					tempVec = vec
					break
				}
			}
			if tempVec == nil {
				tempVec = o.unlimitedAllocator.NewMemColumn(toType, coldata.BatchSize())
				o.scratch.tempVecs = append(o.scratch.tempVecs, tempVec)
			} else {
				tempVec.Nulls().UnsetNulls()
				if tempVec.CanonicalTypeFamily() == types.BytesFamily {
					tempVec.Bytes().Reset()
				}
			}
			if castLeftToRight {
				cast(lVec, tempVec, o.proberState.lBatch.Length(), lSel)
				lVec = tempVec
				colType = rightType
			} else {
				cast(rVec, tempVec, o.proberState.rBatch.Length(), rSel)
				rVec = tempVec
			}
		}
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			} else {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			}
		} else {
			if rVec.MaybeHasNulls() {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			} else {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftSemiOp) probeBodyLSeltrueRSelfalse(ctx context.Context) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		leftColIdx := o.left.eqCols[eqColIdx]
		rightColIdx := o.right.eqCols[eqColIdx]
		lVec := o.proberState.lBatch.ColVec(int(leftColIdx))
		rVec := o.proberState.rBatch.ColVec(int(rightColIdx))
		leftType := o.left.sourceTypes[leftColIdx]
		rightType := o.right.sourceTypes[rightColIdx]
		colType := leftType
		// Merge joiner only supports the case when the physical types in the
		// equality columns in both inputs are the same. If that is not the case,
		// we need to cast one of the vectors to another's physical type putting
		// the result of the cast into a temporary vector that is used instead of
		// the original.
		leftCanonicalTypeFamily := o.left.canonicalTypeFamilies[leftColIdx]
		isNumeric := leftCanonicalTypeFamily == types.IntFamily ||
			leftCanonicalTypeFamily == types.FloatFamily ||
			leftCanonicalTypeFamily == types.DecimalFamily
		if isNumeric && !leftType.Identical(rightType) {
			castLeftToRight := false
			// There is a hierarchy of valid casts:
			//   Int16 -> Int32 -> Int64 -> Float64 -> Decimal
			// and the cast is valid if 'fromType' is mentioned before 'toType'
			// in this chain.
			switch leftCanonicalTypeFamily {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					castLeftToRight = true
				case 32:
					castLeftToRight = !rightType.Identical(types.Int2)
				case 64:
					castLeftToRight = !rightType.Identical(types.Int2) && !rightType.Identical(types.Int4)
				}
			case types.FloatFamily:
				castLeftToRight = o.right.canonicalTypeFamilies[rightColIdx] == types.DecimalFamily
			}

			toType := leftType
			if castLeftToRight {
				toType = rightType
			}
			var tempVec coldata.Vec
			for _, vec := range o.scratch.tempVecs {
				if vec.Type().Identical(toType) {
					tempVec = vec
					break
				}
			}
			if tempVec == nil {
				tempVec = o.unlimitedAllocator.NewMemColumn(toType, coldata.BatchSize())
				o.scratch.tempVecs = append(o.scratch.tempVecs, tempVec)
			} else {
				tempVec.Nulls().UnsetNulls()
				if tempVec.CanonicalTypeFamily() == types.BytesFamily {
					tempVec.Bytes().Reset()
				}
			}
			if castLeftToRight {
				cast(lVec, tempVec, o.proberState.lBatch.Length(), lSel)
				lVec = tempVec
				colType = rightType
			} else {
				cast(rVec, tempVec, o.proberState.rBatch.Length(), rSel)
				rVec = tempVec
			}
		}
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			} else {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(lSel[curLIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(lSel[curLIdx]) {
												lComplete = true
												break
											}
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			}
		} else {
			if rVec.MaybeHasNulls() {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			} else {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = lSel[curLIdx]
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = lSel[curLIdx]
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftSemiOp) probeBodyLSelfalseRSeltrue(ctx context.Context) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		leftColIdx := o.left.eqCols[eqColIdx]
		rightColIdx := o.right.eqCols[eqColIdx]
		lVec := o.proberState.lBatch.ColVec(int(leftColIdx))
		rVec := o.proberState.rBatch.ColVec(int(rightColIdx))
		leftType := o.left.sourceTypes[leftColIdx]
		rightType := o.right.sourceTypes[rightColIdx]
		colType := leftType
		// Merge joiner only supports the case when the physical types in the
		// equality columns in both inputs are the same. If that is not the case,
		// we need to cast one of the vectors to another's physical type putting
		// the result of the cast into a temporary vector that is used instead of
		// the original.
		leftCanonicalTypeFamily := o.left.canonicalTypeFamilies[leftColIdx]
		isNumeric := leftCanonicalTypeFamily == types.IntFamily ||
			leftCanonicalTypeFamily == types.FloatFamily ||
			leftCanonicalTypeFamily == types.DecimalFamily
		if isNumeric && !leftType.Identical(rightType) {
			castLeftToRight := false
			// There is a hierarchy of valid casts:
			//   Int16 -> Int32 -> Int64 -> Float64 -> Decimal
			// and the cast is valid if 'fromType' is mentioned before 'toType'
			// in this chain.
			switch leftCanonicalTypeFamily {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					castLeftToRight = true
				case 32:
					castLeftToRight = !rightType.Identical(types.Int2)
				case 64:
					castLeftToRight = !rightType.Identical(types.Int2) && !rightType.Identical(types.Int4)
				}
			case types.FloatFamily:
				castLeftToRight = o.right.canonicalTypeFamilies[rightColIdx] == types.DecimalFamily
			}

			toType := leftType
			if castLeftToRight {
				toType = rightType
			}
			var tempVec coldata.Vec
			for _, vec := range o.scratch.tempVecs {
				if vec.Type().Identical(toType) {
					tempVec = vec
					break
				}
			}
			if tempVec == nil {
				tempVec = o.unlimitedAllocator.NewMemColumn(toType, coldata.BatchSize())
				o.scratch.tempVecs = append(o.scratch.tempVecs, tempVec)
			} else {
				tempVec.Nulls().UnsetNulls()
				if tempVec.CanonicalTypeFamily() == types.BytesFamily {
					tempVec.Bytes().Reset()
				}
			}
			if castLeftToRight {
				cast(lVec, tempVec, o.proberState.lBatch.Length(), lSel)
				lVec = tempVec
				colType = rightType
			} else {
				cast(rVec, tempVec, o.proberState.rBatch.Length(), rSel)
				rVec = tempVec
			}
		}
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			} else {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			}
		} else {
			if rVec.MaybeHasNulls() {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(rSel[curRIdx])

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(rSel[curRIdx]) {
												rComplete = true
												break
											}
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			} else {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = rSel[curRIdx]
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = rSel[curRIdx]
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftSemiOp) probeBodyLSelfalseRSelfalse(ctx context.Context) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		leftColIdx := o.left.eqCols[eqColIdx]
		rightColIdx := o.right.eqCols[eqColIdx]
		lVec := o.proberState.lBatch.ColVec(int(leftColIdx))
		rVec := o.proberState.rBatch.ColVec(int(rightColIdx))
		leftType := o.left.sourceTypes[leftColIdx]
		rightType := o.right.sourceTypes[rightColIdx]
		colType := leftType
		// Merge joiner only supports the case when the physical types in the
		// equality columns in both inputs are the same. If that is not the case,
		// we need to cast one of the vectors to another's physical type putting
		// the result of the cast into a temporary vector that is used instead of
		// the original.
		leftCanonicalTypeFamily := o.left.canonicalTypeFamilies[leftColIdx]
		isNumeric := leftCanonicalTypeFamily == types.IntFamily ||
			leftCanonicalTypeFamily == types.FloatFamily ||
			leftCanonicalTypeFamily == types.DecimalFamily
		if isNumeric && !leftType.Identical(rightType) {
			castLeftToRight := false
			// There is a hierarchy of valid casts:
			//   Int16 -> Int32 -> Int64 -> Float64 -> Decimal
			// and the cast is valid if 'fromType' is mentioned before 'toType'
			// in this chain.
			switch leftCanonicalTypeFamily {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					castLeftToRight = true
				case 32:
					castLeftToRight = !rightType.Identical(types.Int2)
				case 64:
					castLeftToRight = !rightType.Identical(types.Int2) && !rightType.Identical(types.Int4)
				}
			case types.FloatFamily:
				castLeftToRight = o.right.canonicalTypeFamilies[rightColIdx] == types.DecimalFamily
			}

			toType := leftType
			if castLeftToRight {
				toType = rightType
			}
			var tempVec coldata.Vec
			for _, vec := range o.scratch.tempVecs {
				if vec.Type().Identical(toType) {
					tempVec = vec
					break
				}
			}
			if tempVec == nil {
				tempVec = o.unlimitedAllocator.NewMemColumn(toType, coldata.BatchSize())
				o.scratch.tempVecs = append(o.scratch.tempVecs, tempVec)
			} else {
				tempVec.Nulls().UnsetNulls()
				if tempVec.CanonicalTypeFamily() == types.BytesFamily {
					tempVec.Bytes().Reset()
				}
			}
			if castLeftToRight {
				cast(lVec, tempVec, o.proberState.lBatch.Length(), lSel)
				lVec = tempVec
				colType = rightType
			} else {
				cast(rVec, tempVec, o.proberState.rBatch.Length(), rSel)
				rVec = tempVec
			}
		}
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			} else {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								lNull := lVec.Nulls().NullAt(curLIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if lNull {

									curLIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											if lVec.Nulls().NullAt(curLIdx) {
												lComplete = true
												break
											}
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			}
		} else {
			if rVec.MaybeHasNulls() {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0
								rNull := rVec.Nulls().NullAt(curRIdx)

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.
								if rNull {

									curRIdx++
									continue
								}

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											if rVec.Nulls().NullAt(curRIdx) {
												rComplete = true
												break
											}
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			} else {

				switch lVec.CanonicalTypeFamily() {
				case types.BoolFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       bool
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if !lVal && rVal {
										cmp = -1
									} else if lVal && !rVal {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newLVal && lVal {
													cmpResult = -1
												} else if newLVal && !lVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if !newRVal && rVal {
													cmpResult = -1
												} else if newRVal && !rVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.BytesFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       []byte
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = bytes.Compare(lVal, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newLVal, lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = bytes.Compare(newRVal, rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.DecimalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       apd.Decimal
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = tree.CompareDecimals(&lVal, &rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newLVal, &lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&newRVal, &rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntFamily:
					switch colType.Width() {
					case 16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int16
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case 32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int32
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case -1:
					default:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       int64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else {
											cmp = 0
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newLVal), int64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := int64(newRVal), int64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.FloatFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       float64
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmp = -1
										} else if a > b {
											cmp = 1
										} else if a == b {
											cmp = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmp = 0
											} else {
												cmp = -1
											}
										} else {
											cmp = 1
										}
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newLVal), float64(lVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												{
													a, b := float64(newRVal), float64(rVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.TimestampTZFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Timestamp()
						rKeys := rVec.Timestamp()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       time.Time
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline

									if lVal.Before(rVal) {
										cmp = -1
									} else if rVal.Before(lVal) {
										cmp = 1
									} else {
										cmp = 0
									}

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newLVal.Before(lVal) {
													cmpResult = -1
												} else if lVal.Before(newLVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int

												if newRVal.Before(rVal) {
													cmpResult = -1
												} else if rVal.Before(newRVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case types.IntervalFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Interval()
						rKeys := rVec.Interval()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       duration.Duration
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx) //gcassert:inline
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx) //gcassert:inline
									cmp = lVal.Compare(rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newLVal.Compare(lVal)
												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx) //gcassert:inline

											{
												var cmpResult int
												cmpResult = newRVal.Compare(rVal)
												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch colType.Width() {
					case -1:
					default:
						lKeys := lVec.Datum()
						rKeys := rVec.Datum()
						var (
							lGroup, rGroup   group
							cmp              int
							match            bool
							lVal, rVal       interface{}
							lSelIdx, rSelIdx int
						)

						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLEndIdx := lGroup.rowEndIdx
							curREndIdx := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLEndIdx && curRIdx < curREndIdx && !areGroupsProcessed {
								cmp = 0

								// TODO(yuzefovich): we can advance both sides if both are
								// NULL.

								{

									lSelIdx = curLIdx
									lVal = lKeys.Get(lSelIdx)
									rSelIdx = curRIdx
									rVal = rKeys.Get(rSelIdx)

									cmp = lVal.(*coldataext.Datum).CompareDatum(lKeys, rVal)

								}

								if cmp == 0 {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									// If a group ends before the end of the probing batch,
									// then we know it is complete.
									lComplete := curLEndIdx < o.proberState.lLength
									rComplete := curREndIdx < o.proberState.rLength
									beginLIdx, beginRIdx := curLIdx, curRIdx
									curLIdx++
									curRIdx++

									// Find the length of the group on the left.
									for curLIdx < curLEndIdx {
										{
											lSelIdx = curLIdx
											newLVal := lKeys.Get(lSelIdx)

											{
												var cmpResult int

												cmpResult = newLVal.(*coldataext.Datum).CompareDatum(lKeys, lVal)

												match = cmpResult == 0
											}

											if !match {
												lComplete = true
												break
											}
										}
										lGroupLength++
										curLIdx++
									}

									// Find the length of the group on the right.
									for curRIdx < curREndIdx {
										{
											rSelIdx = curRIdx
											newRVal := rKeys.Get(rSelIdx)

											{
												var cmpResult int

												cmpResult = newRVal.(*coldataext.Datum).CompareDatum(rKeys, rVal)

												match = cmpResult == 0
											}

											if !match {
												rComplete = true
												break
											}
										}
										rGroupLength++
										curRIdx++
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(ctx, &o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(ctx, &o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									if eqColIdx < len(o.left.eqCols)-1 {
										o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
									} else {
										leftSemiGroupLength := lGroupLength
										o.groups.addLeftSemiGroup(beginLIdx, leftSemiGroupLength)
									}
								} else { // mismatch
									// The line below is a compact form of the following:
									//   incrementLeft :=
									//    (cmp < 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC) ||
									//	  (cmp > 0 && o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_DESC).
									incrementLeft := cmp < 0 == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}
								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unhandled type %s", colType))
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

// buildLeftGroupsFromBatch takes a []group and expands each group into the
// output by repeating each row in the group numRepeats times. For example,
// given an input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroupsFromBatch expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroupsFromBatch in that each row of
// group is repeated numRepeats times, instead of a simple copy of the group as
// a whole.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinLeftSemiOp) buildLeftGroupsFromBatch(
	leftGroups []group, input *mergeJoinInput, batch coldata.Batch, destStartIdx int,
) {
	sel := batch.Selection()
	initialBuilderState := o.builderState.left
	outputBatchSize := o.outputBatchSize
	o.unlimitedAllocator.PerformOperation(
		o.output.ColVecs()[:len(input.sourceTypes)],
		func() {
			// Loop over every column.
		LeftColLoop:
			for colIdx := range input.sourceTypes {
				outStartIdx := destStartIdx
				out := o.output.ColVec(colIdx)
				var src coldata.Vec
				if batch.Length() > 0 {
					src = batch.ColVec(colIdx)
				}

				if sel != nil {
					if src != nil && src.MaybeHasNulls() {

						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Bools
								if src != nil {
									srcCol = src.Bool()
								}
								outCol := out.Bool()
								var val bool
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol *coldata.Bytes
								if src != nil {
									srcCol = src.Bytes()
								}
								outCol := out.Bytes()
								var val []byte
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol.Set(outStartIdx, val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Decimals
								if src != nil {
									srcCol = src.Decimal()
								}
								outCol := out.Decimal()
								var val apd.Decimal
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx].Set(&val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								var srcCol coldata.Int16s
								if src != nil {
									srcCol = src.Int16()
								}
								outCol := out.Int16()
								var val int16
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							case 32:
								var srcCol coldata.Int32s
								if src != nil {
									srcCol = src.Int32()
								}
								outCol := out.Int32()
								var val int32
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							case -1:
							default:
								var srcCol coldata.Int64s
								if src != nil {
									srcCol = src.Int64()
								}
								outCol := out.Int64()
								var val int64
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Float64s
								if src != nil {
									srcCol = src.Float64()
								}
								outCol := out.Float64()
								var val float64
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Times
								if src != nil {
									srcCol = src.Timestamp()
								}
								outCol := out.Timestamp()
								var val time.Time
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Durations
								if src != nil {
									srcCol = src.Interval()
								}
								outCol := out.Interval()
								var val duration.Duration
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.DatumVec
								if src != nil {
									srcCol = src.Datum()
								}
								outCol := out.Datum()
								var val interface{}
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx)
												for i := 0; i < toAppend; i++ {
													outCol.Set(outStartIdx, val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					} else {

						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Bools
								if src != nil {
									srcCol = src.Bool()
								}
								outCol := out.Bool()
								var val bool
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol *coldata.Bytes
								if src != nil {
									srcCol = src.Bytes()
								}
								outCol := out.Bytes()
								var val []byte
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol.Set(outStartIdx, val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Decimals
								if src != nil {
									srcCol = src.Decimal()
								}
								outCol := out.Decimal()
								var val apd.Decimal
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx].Set(&val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								var srcCol coldata.Int16s
								if src != nil {
									srcCol = src.Int16()
								}
								outCol := out.Int16()
								var val int16
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							case 32:
								var srcCol coldata.Int32s
								if src != nil {
									srcCol = src.Int32()
								}
								outCol := out.Int32()
								var val int32
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							case -1:
							default:
								var srcCol coldata.Int64s
								if src != nil {
									srcCol = src.Int64()
								}
								outCol := out.Int64()
								var val int64
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Float64s
								if src != nil {
									srcCol = src.Float64()
								}
								outCol := out.Float64()
								var val float64
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Times
								if src != nil {
									srcCol = src.Timestamp()
								}
								outCol := out.Timestamp()
								var val time.Time
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Durations
								if src != nil {
									srcCol = src.Interval()
								}
								outCol := out.Interval()
								var val duration.Duration
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.DatumVec
								if src != nil {
									srcCol = src.Datum()
								}
								outCol := out.Datum()
								var val interface{}
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx
										srcStartIdx = sel[srcStartIdx]

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx)
												for i := 0; i < toAppend; i++ {
													outCol.Set(outStartIdx, val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					}
				} else {
					if src != nil && src.MaybeHasNulls() {

						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Bools
								if src != nil {
									srcCol = src.Bool()
								}
								outCol := out.Bool()
								var val bool
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol *coldata.Bytes
								if src != nil {
									srcCol = src.Bytes()
								}
								outCol := out.Bytes()
								var val []byte
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol.Set(outStartIdx, val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Decimals
								if src != nil {
									srcCol = src.Decimal()
								}
								outCol := out.Decimal()
								var val apd.Decimal
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx].Set(&val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								var srcCol coldata.Int16s
								if src != nil {
									srcCol = src.Int16()
								}
								outCol := out.Int16()
								var val int16
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							case 32:
								var srcCol coldata.Int32s
								if src != nil {
									srcCol = src.Int32()
								}
								outCol := out.Int32()
								var val int32
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							case -1:
							default:
								var srcCol coldata.Int64s
								if src != nil {
									srcCol = src.Int64()
								}
								outCol := out.Int64()
								var val int64
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Float64s
								if src != nil {
									srcCol = src.Float64()
								}
								outCol := out.Float64()
								var val float64
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Times
								if src != nil {
									srcCol = src.Timestamp()
								}
								outCol := out.Timestamp()
								var val time.Time
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Durations
								if src != nil {
									srcCol = src.Interval()
								}
								outCol := out.Interval()
								var val duration.Duration
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.DatumVec
								if src != nil {
									srcCol = src.Datum()
								}
								outCol := out.Datum()
								var val interface{}
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											if src.Nulls().NullAt(srcStartIdx) {
												out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
												outStartIdx += toAppend
											} else {
												val = srcCol.Get(srcStartIdx)
												for i := 0; i < toAppend; i++ {
													outCol.Set(outStartIdx, val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					} else {

						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Bools
								if src != nil {
									srcCol = src.Bool()
								}
								outCol := out.Bool()
								var val bool
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol *coldata.Bytes
								if src != nil {
									srcCol = src.Bytes()
								}
								outCol := out.Bytes()
								var val []byte
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol.Set(outStartIdx, val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Decimals
								if src != nil {
									srcCol = src.Decimal()
								}
								outCol := out.Decimal()
								var val apd.Decimal
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx].Set(&val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								var srcCol coldata.Int16s
								if src != nil {
									srcCol = src.Int16()
								}
								outCol := out.Int16()
								var val int16
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							case 32:
								var srcCol coldata.Int32s
								if src != nil {
									srcCol = src.Int32()
								}
								outCol := out.Int32()
								var val int32
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							case -1:
							default:
								var srcCol coldata.Int64s
								if src != nil {
									srcCol = src.Int64()
								}
								outCol := out.Int64()
								var val int64
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Float64s
								if src != nil {
									srcCol = src.Float64()
								}
								outCol := out.Float64()
								var val float64
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Times
								if src != nil {
									srcCol = src.Timestamp()
								}
								outCol := out.Timestamp()
								var val time.Time
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Durations
								if src != nil {
									srcCol = src.Interval()
								}
								outCol := out.Interval()
								var val duration.Duration
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx) //gcassert:inline
												for i := 0; i < toAppend; i++ {
													outCol[outStartIdx] = val
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.DatumVec
								if src != nil {
									srcCol = src.Datum()
								}
								outCol := out.Datum()
								var val interface{}
								var srcStartIdx int

								// Loop over every group.
								for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
									leftGroup := &leftGroups[o.builderState.left.groupsIdx]
									// If curSrcStartIdx is uninitialized, start it at the group's start idx.
									// Otherwise continue where we left off.
									if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
										o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
									}
									// Loop over every row in the group.
									for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
										// Repeat each row numRepeats times.
										srcStartIdx = o.builderState.left.curSrcStartIdx

										repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
										toAppend := repeatsLeft
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											{
												val = srcCol.Get(srcStartIdx)
												for i := 0; i < toAppend; i++ {
													outCol.Set(outStartIdx, val)
													outStartIdx++
												}
											}
										}

										if toAppend < repeatsLeft {
											// We didn't materialize all the rows in the group so save state and
											// move to the next column.
											o.builderState.left.numRepeatsIdx += toAppend
											if colIdx == len(input.sourceTypes)-1 {
												return
											}
											o.builderState.left.setBuilderColumnState(initialBuilderState)
											continue LeftColLoop
										}

										o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
									}
									o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
								}
								o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					}
				}
				o.builderState.left.setBuilderColumnState(initialBuilderState)
			}
			o.builderState.left.reset()
		},
	)
}

// buildLeftBufferedGroup is similar to buildLeftGroupsFromBatch, but it
// builds the output columns corresponding to the left input based on the
// buffered group. The goal is to repeat each row from the left buffered group
// leftGroup.numRepeats times.
// Note that for non-set operation joins all other fields of leftGroup are
// ignored because, by definition, all rows in the buffered group are part of
// leftGroup (i.e. we don't need to look at rowStartIdx and rowEndIdx). Also,
// all rows in the buffered group do have a match, so the group can neither be
// "nullGroup" nor "unmatched".
// This function does pay attention to rowEndIdx field for set operation joins:
// only the first rowEndIdx will be output. For performance reasons we choose
// to output the first rows (for both INTERSECT ALL and EXCEPT ALL joins we
// need to output exactly rowEndIdx different rows from the left, but the
// choice of rows can be arbitrary).
func (o *mergeJoinLeftSemiOp) buildLeftBufferedGroup(
	ctx context.Context,
	leftGroup group,
	input *mergeJoinInput,
	bufferedGroup mjBufferedGroup,
	destStartIdx int,
) {
	var err error
	currentBatch := o.builderState.lBufferedGroupBatch
	if currentBatch == nil {
		currentBatch, err = bufferedGroup.dequeue(ctx)
		if err != nil {
			colexecerror.InternalError(err)
		}
		o.builderState.lBufferedGroupBatch = currentBatch
		o.builderState.left.curSrcStartIdx = 0
		o.builderState.left.numRepeatsIdx = 0
	}
	initialBuilderState := o.builderState.left
	o.unlimitedAllocator.PerformOperation(
		o.output.ColVecs()[:len(input.sourceTypes)],
		func() {
			batchLength := currentBatch.Length()
			for batchLength > 0 {
				// Loop over every column.
			LeftColLoop:
				for colIdx := range input.sourceTypes {
					outStartIdx := destStartIdx
					src := currentBatch.ColVec(colIdx)
					out := o.output.ColVec(colIdx)
					switch input.canonicalTypeFamilies[colIdx] {
					case types.BoolFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							srcCol := src.Bool()
							outCol := out.Bool()
							var val bool
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						}
					case types.BytesFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							srcCol := src.Bytes()
							outCol := out.Bytes()
							var val []byte
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol.Set(outStartIdx, val)
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						}
					case types.DecimalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							srcCol := src.Decimal()
							outCol := out.Decimal()
							var val apd.Decimal
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx].Set(&val)
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						}
					case types.IntFamily:
						switch input.sourceTypes[colIdx].Width() {
						case 16:
							srcCol := src.Int16()
							outCol := out.Int16()
							var val int16
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						case 32:
							srcCol := src.Int32()
							outCol := out.Int32()
							var val int32
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						case -1:
						default:
							srcCol := src.Int64()
							outCol := out.Int64()
							var val int64
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						}
					case types.FloatFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							srcCol := src.Float64()
							outCol := out.Float64()
							var val float64
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						}
					case types.TimestampTZFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							srcCol := src.Timestamp()
							outCol := out.Timestamp()
							var val time.Time
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						}
					case types.IntervalFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							srcCol := src.Interval()
							outCol := out.Interval()
							var val duration.Duration
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx) //gcassert:inline
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch input.sourceTypes[colIdx].Width() {
						case -1:
						default:
							srcCol := src.Datum()
							outCol := out.Datum()
							var val interface{}
							// Loop over every row in the group.
							for ; o.builderState.left.curSrcStartIdx < batchLength; o.builderState.left.curSrcStartIdx++ {
								// Repeat each row numRepeats times.
								srcStartIdx := o.builderState.left.curSrcStartIdx
								repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
								toAppend := repeatsLeft
								if outStartIdx+toAppend > o.outputBatchSize {
									toAppend = o.outputBatchSize - outStartIdx
								}

								if src.Nulls().NullAt(srcStartIdx) {
									out.Nulls().SetNullRange(outStartIdx, outStartIdx+toAppend)
									outStartIdx += toAppend
								} else {
									val = srcCol.Get(srcStartIdx)
									for i := 0; i < toAppend; i++ {
										outCol.Set(outStartIdx, val)
										outStartIdx++
									}
								}

								if toAppend < repeatsLeft {
									// We didn't materialize all the rows in the current batch, so
									// we move to the next column.
									if colIdx == len(input.sourceTypes)-1 {
										// This is the last column, so we update the builder state
										// and exit.
										o.builderState.left.numRepeatsIdx += toAppend
										return
									}
									// We need to start building the next column
									// with the same initial builder state as the
									// current column.
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop
								}
								// We fully processed the current row, and before moving on to the
								// next one, we need to reset numRepeatsIdx (so that the next row
								// would be repeated leftGroup.numRepeats times).
								o.builderState.left.numRepeatsIdx = 0
							}
						}
					default:
						colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
					}
					if colIdx == len(input.sourceTypes)-1 {
						// We have appended some tuples into the output batch from the current
						// batch (the latter is now fully processed), so we need to adjust
						// destStartIdx accordingly for the next batch.
						destStartIdx = outStartIdx
					} else {
						o.builderState.left.setBuilderColumnState(initialBuilderState)
					}
				}
				// We have processed all tuples in the current batch from the
				// buffered group, so we need to dequeue the next one.
				o.unlimitedAllocator.ReleaseBatch(currentBatch)
				currentBatch, err = bufferedGroup.dequeue(ctx)
				if err != nil {
					colexecerror.InternalError(err)
				}
				o.builderState.lBufferedGroupBatch = currentBatch
				batchLength = currentBatch.Length()
				// We have transitioned to building from a new batch, so we
				// need to update the builder state to build from the beginning
				// of the new batch.
				o.builderState.left.curSrcStartIdx = 0
				o.builderState.left.numRepeatsIdx = 0
				// We also need to update 'initialBuilderState' so that the
				// builder state gets reset correctly in-between different
				// columns in the loop above.
				initialBuilderState = o.builderState.left
			}
			o.builderState.lBufferedGroupBatch = nil
			o.builderState.left.reset()
		},
	)
}

// buildRightGroupsFromBatch takes a []group and repeats each group numRepeats
// times. For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroupsFromBatch in that each group is
// not expanded but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinLeftSemiOp) buildRightGroupsFromBatch(
	rightGroups []group, colOffset int, input *mergeJoinInput, batch coldata.Batch, destStartIdx int,
) {
	initialBuilderState := o.builderState.right
	sel := batch.Selection()
	outputBatchSize := o.outputBatchSize

	o.unlimitedAllocator.PerformOperation(
		o.output.ColVecs()[colOffset:colOffset+len(input.sourceTypes)],
		func() {
			// Loop over every column.
		RightColLoop:
			for colIdx := range input.sourceTypes {
				outStartIdx := destStartIdx
				out := o.output.ColVec(colIdx + colOffset)
				var src coldata.Vec
				if batch.Length() > 0 {
					src = batch.ColVec(colIdx)
				}

				if sel != nil {
					if src != nil && src.MaybeHasNulls() {

						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Bools
								if src != nil {
									srcCol = src.Bool()
								}
								outCol := out.Bool()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol *coldata.Bytes
								if src != nil {
									srcCol = src.Bytes()
								}
								outCol := out.Bytes()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol.Set(outStartIdx, v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Decimals
								if src != nil {
									srcCol = src.Decimal()
								}
								outCol := out.Decimal()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx].Set(&v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								var srcCol coldata.Int16s
								if src != nil {
									srcCol = src.Int16()
								}
								outCol := out.Int16()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							case 32:
								var srcCol coldata.Int32s
								if src != nil {
									srcCol = src.Int32()
								}
								outCol := out.Int32()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							case -1:
							default:
								var srcCol coldata.Int64s
								if src != nil {
									srcCol = src.Int64()
								}
								outCol := out.Int64()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Float64s
								if src != nil {
									srcCol = src.Float64()
								}
								outCol := out.Float64()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Times
								if src != nil {
									srcCol = src.Timestamp()
								}
								outCol := out.Timestamp()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Durations
								if src != nil {
									srcCol = src.Interval()
								}
								outCol := out.Interval()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.DatumVec
								if src != nil {
									srcCol = src.Datum()
								}
								outCol := out.Datum()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx])
													outCol.Set(outStartIdx, v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					} else {

						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Bools
								if src != nil {
									srcCol = src.Bool()
								}
								outCol := out.Bool()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol *coldata.Bytes
								if src != nil {
									srcCol = src.Bytes()
								}
								outCol := out.Bytes()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol.Set(outStartIdx, v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Decimals
								if src != nil {
									srcCol = src.Decimal()
								}
								outCol := out.Decimal()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx].Set(&v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								var srcCol coldata.Int16s
								if src != nil {
									srcCol = src.Int16()
								}
								outCol := out.Int16()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							case 32:
								var srcCol coldata.Int32s
								if src != nil {
									srcCol = src.Int32()
								}
								outCol := out.Int32()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							case -1:
							default:
								var srcCol coldata.Int64s
								if src != nil {
									srcCol = src.Int64()
								}
								outCol := out.Int64()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Float64s
								if src != nil {
									srcCol = src.Float64()
								}
								outCol := out.Float64()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Times
								if src != nil {
									srcCol = src.Timestamp()
								}
								outCol := out.Timestamp()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Durations
								if src != nil {
									srcCol = src.Interval()
								}
								outCol := out.Interval()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx]) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.DatumVec
								if src != nil {
									srcCol = src.Datum()
								}
								outCol := out.Datum()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(sel[o.builderState.right.curSrcStartIdx])
													outCol.Set(outStartIdx, v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					}
				} else {
					if src != nil && src.MaybeHasNulls() {

						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Bools
								if src != nil {
									srcCol = src.Bool()
								}
								outCol := out.Bool()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol *coldata.Bytes
								if src != nil {
									srcCol = src.Bytes()
								}
								outCol := out.Bytes()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol.Set(outStartIdx, v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Decimals
								if src != nil {
									srcCol = src.Decimal()
								}
								outCol := out.Decimal()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx].Set(&v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								var srcCol coldata.Int16s
								if src != nil {
									srcCol = src.Int16()
								}
								outCol := out.Int16()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							case 32:
								var srcCol coldata.Int32s
								if src != nil {
									srcCol = src.Int32()
								}
								outCol := out.Int32()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							case -1:
							default:
								var srcCol coldata.Int64s
								if src != nil {
									srcCol = src.Int64()
								}
								outCol := out.Int64()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Float64s
								if src != nil {
									srcCol = src.Float64()
								}
								outCol := out.Float64()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Times
								if src != nil {
									srcCol = src.Timestamp()
								}
								outCol := out.Timestamp()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Durations
								if src != nil {
									srcCol = src.Interval()
								}
								outCol := out.Interval()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.DatumVec
								if src != nil {
									srcCol = src.Datum()
								}
								outCol := out.Datum()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
													out.Nulls().SetNull(outStartIdx)
												} else {
													v := srcCol.Get(o.builderState.right.curSrcStartIdx)
													outCol.Set(outStartIdx, v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					} else {

						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Bools
								if src != nil {
									srcCol = src.Bool()
								}
								outCol := out.Bool()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol *coldata.Bytes
								if src != nil {
									srcCol = src.Bytes()
								}
								outCol := out.Bytes()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol.Set(outStartIdx, v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Decimals
								if src != nil {
									srcCol = src.Decimal()
								}
								outCol := out.Decimal()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx].Set(&v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								var srcCol coldata.Int16s
								if src != nil {
									srcCol = src.Int16()
								}
								outCol := out.Int16()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							case 32:
								var srcCol coldata.Int32s
								if src != nil {
									srcCol = src.Int32()
								}
								outCol := out.Int32()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							case -1:
							default:
								var srcCol coldata.Int64s
								if src != nil {
									srcCol = src.Int64()
								}
								outCol := out.Int64()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Float64s
								if src != nil {
									srcCol = src.Float64()
								}
								outCol := out.Float64()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Times
								if src != nil {
									srcCol = src.Timestamp()
								}
								outCol := out.Timestamp()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.Durations
								if src != nil {
									srcCol = src.Interval()
								}
								outCol := out.Interval()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
													outCol[outStartIdx] = v
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								var srcCol coldata.DatumVec
								if src != nil {
									srcCol = src.Datum()
								}
								outCol := out.Datum()

								// Loop over every group.
								for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
									rightGroup := &rightGroups[o.builderState.right.groupsIdx]
									// Repeat every group numRepeats times.
									for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
										if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
											o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
										}
										toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
										if outStartIdx+toAppend > outputBatchSize {
											toAppend = outputBatchSize - outStartIdx
										}

										{
											// Optimization in the case that group length is 1, use assign
											// instead of copy.
											if toAppend == 1 {
												{
													v := srcCol.Get(o.builderState.right.curSrcStartIdx)
													outCol.Set(outStartIdx, v)
												}
											} else {
												out.Copy(
													coldata.CopySliceArgs{
														SliceArgs: coldata.SliceArgs{
															Src:         src,
															Sel:         sel,
															DestIdx:     outStartIdx,
															SrcStartIdx: o.builderState.right.curSrcStartIdx,
															SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
														},
													},
												)
											}
										}

										outStartIdx += toAppend

										// If we haven't materialized all the rows from the group, then we are
										// done with the current column.
										if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
											// If it's the last column, save state and return.
											if colIdx == len(input.sourceTypes)-1 {
												o.builderState.right.curSrcStartIdx += toAppend
												return
											}
											// Otherwise, reset to the initial state and begin the next column.
											o.builderState.right.setBuilderColumnState(initialBuilderState)
											continue RightColLoop
										}
										o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
									}
									o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					}
				}

				o.builderState.right.setBuilderColumnState(initialBuilderState)
			}
			o.builderState.right.reset()
		})
}

// buildRightBufferedGroup is similar to buildRightGroupsFromBatch, but it
// builds the output columns corresponding to the right input based on the
// buffered group. The goal is to repeat the whole buffered group
// rightGroup.numRepeats times.
// Note that all other fields of rightGroup are ignored because, by definition,
// all rows in the buffered group are part of rightGroup (i.e. we don't need to
// look at rowStartIdx and rowEndIdx). Also, all rows in the buffered group do
// have a match, so the group can neither be "nullGroup" nor "unmatched".
func (o *mergeJoinLeftSemiOp) buildRightBufferedGroup(
	ctx context.Context,
	rightGroup group,
	colOffset int,
	input *mergeJoinInput,
	bufferedGroup mjBufferedGroup,
	destStartIdx int,
) {
	var err error
	o.unlimitedAllocator.PerformOperation(
		o.output.ColVecs()[colOffset:colOffset+len(input.sourceTypes)],
		func() {
			outStartIdx := destStartIdx
			// Repeat the buffered group numRepeats times.
			for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
				currentBatch := o.builderState.rBufferedGroupBatch
				if currentBatch == nil {
					currentBatch, err = bufferedGroup.dequeue(ctx)
					if err != nil {
						colexecerror.InternalError(err)
					}
					o.builderState.rBufferedGroupBatch = currentBatch
					o.builderState.right.curSrcStartIdx = 0
				}
				batchLength := currentBatch.Length()
				for batchLength > 0 {
					toAppend := batchLength - o.builderState.right.curSrcStartIdx
					if outStartIdx+toAppend > o.outputBatchSize {
						toAppend = o.outputBatchSize - outStartIdx
					}

					// Loop over every column.
					for colIdx := range input.sourceTypes {
						out := o.output.ColVec(colIdx + colOffset)
						src := currentBatch.ColVec(colIdx)
						switch input.canonicalTypeFamilies[colIdx] {
						case types.BoolFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								srcCol := src.Bool()
								outCol := out.Bool()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol[outStartIdx] = v
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							}
						case types.BytesFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								srcCol := src.Bytes()
								outCol := out.Bytes()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol.Set(outStartIdx, v)
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							}
						case types.DecimalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								srcCol := src.Decimal()
								outCol := out.Decimal()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol[outStartIdx].Set(&v)
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							}
						case types.IntFamily:
							switch input.sourceTypes[colIdx].Width() {
							case 16:
								srcCol := src.Int16()
								outCol := out.Int16()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol[outStartIdx] = v
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							case 32:
								srcCol := src.Int32()
								outCol := out.Int32()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol[outStartIdx] = v
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							case -1:
							default:
								srcCol := src.Int64()
								outCol := out.Int64()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol[outStartIdx] = v
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							}
						case types.FloatFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								srcCol := src.Float64()
								outCol := out.Float64()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol[outStartIdx] = v
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							}
						case types.TimestampTZFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								srcCol := src.Timestamp()
								outCol := out.Timestamp()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol[outStartIdx] = v
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							}
						case types.IntervalFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								srcCol := src.Interval()
								outCol := out.Interval()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx) //gcassert:inline
										outCol[outStartIdx] = v
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							}
						case typeconv.DatumVecCanonicalTypeFamily:
							switch input.sourceTypes[colIdx].Width() {
							case -1:
							default:
								srcCol := src.Datum()
								outCol := out.Datum()

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(o.builderState.right.curSrcStartIdx) {
										out.Nulls().SetNull(outStartIdx)
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx)
										outCol.Set(outStartIdx, v)
									}
								} else {
									out.Copy(
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												Src:         src,
												DestIdx:     outStartIdx,
												SrcStartIdx: o.builderState.right.curSrcStartIdx,
												SrcEndIdx:   o.builderState.right.curSrcStartIdx + toAppend,
											},
										},
									)
								}
							}
						default:
							colexecerror.InternalError(fmt.Sprintf("unhandled type %s", input.sourceTypes[colIdx].String()))
						}
					}
					outStartIdx += toAppend

					if toAppend < batchLength-o.builderState.right.curSrcStartIdx {
						// If we haven't materialized all the rows from the batch, then we
						// are ready to emit the output batch.
						o.builderState.right.curSrcStartIdx += toAppend
						return
					}
					// We have fully processed the current batch, so we need to get the
					// next one.
					o.unlimitedAllocator.ReleaseBatch(currentBatch)
					currentBatch, err = bufferedGroup.dequeue(ctx)
					if err != nil {
						colexecerror.InternalError(err)
					}
					o.builderState.rBufferedGroupBatch = currentBatch
					batchLength = currentBatch.Length()
					o.builderState.right.curSrcStartIdx = 0
				}
				// We have fully processed all the batches from the buffered group, so
				// we need to rewind it.
				if err := bufferedGroup.rewind(); err != nil {
					colexecerror.InternalError(err)
				}
				o.builderState.rBufferedGroupBatch = nil
			}
			o.builderState.right.reset()
		})
}

// probe is where we generate the groups slices that are used in the build
// phase. We do this by first assuming that every row in both batches
// contributes to the cross product. Then, with every equality column, we
// filter out the rows that don't contribute to the cross product (i.e. they
// don't have a matching row on the other side in the case of an inner join),
// and set the correct cardinality.
// Note that in this phase, we do this for every group, except the last group
// in the batch.
func (o *mergeJoinLeftSemiOp) probe(ctx context.Context) {
	o.groups.reset(o.proberState.lIdx, o.proberState.lLength, o.proberState.rIdx, o.proberState.rLength)
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
	if lSel != nil {
		if rSel != nil {
			o.probeBodyLSeltrueRSeltrue(ctx)
		} else {
			o.probeBodyLSeltrueRSelfalse(ctx)
		}
	} else {
		if rSel != nil {
			o.probeBodyLSelfalseRSeltrue(ctx)
		} else {
			o.probeBodyLSelfalseRSelfalse(ctx)
		}
	}
}

// setBuilderSourceToBufferedGroup sets up the builder state to use the
// buffered group.
func (o *mergeJoinLeftSemiOp) setBuilderSourceToBufferedGroup(ctx context.Context) {
	lGroupEndIdx := o.proberState.lBufferedGroup.numTuples
	rGroupEndIdx := o.proberState.rBufferedGroup.numTuples
	// The capacity of builder state lGroups and rGroups is always at least 1
	// given the init.
	o.builderState.lGroups = o.builderState.lGroups[:1]
	o.builderState.rGroups = o.builderState.rGroups[:1]
	numMatched := lGroupEndIdx
	// Remove unused warning.
	_ = rGroupEndIdx
	o.builderState.lGroups[0] = group{
		rowStartIdx: 0,
		rowEndIdx:   numMatched,
		numRepeats:  1,
		toBuild:     numMatched,
	}

	o.builderState.buildFrom = mjBuildFromBufferedGroup

	// We cannot yet reset the buffered groups because the builder will be taking
	// input from them. The actual reset will take place on the next call to
	// initProberState().
	o.proberState.lBufferedGroupNeedToReset = true
	o.proberState.rBufferedGroupNeedToReset = true
}

// exhaustLeftSource sets up the builder to process any remaining tuples from
// the left source. It should only be called when the right source has been
// exhausted.
func (o *mergeJoinLeftSemiOp) exhaustLeftSource(ctx context.Context) {
}

// exhaustRightSource sets up the builder to process any remaining tuples from
// the right source. It should only be called when the left source has been
// exhausted.
func (o *mergeJoinLeftSemiOp) exhaustRightSource() {
	// Remaining tuples from the right source do not have a match, so they are
	// ignored in all joins except for RIGHT OUTER and FULL OUTER.
}

// calculateOutputCount uses the toBuild field of each group and the output
// batch size to determine the output count. Note that as soon as a group is
// materialized partially or fully to output, its toBuild field is updated
// accordingly.
func (o *mergeJoinLeftSemiOp) calculateOutputCount(groups []group) int {
	count := o.builderState.outCount

	for i := 0; i < len(groups); i++ {
		count += groups[i].toBuild
		groups[i].toBuild = 0
		if count > o.outputBatchSize {
			groups[i].toBuild = count - o.outputBatchSize
			count = o.outputBatchSize
			return count
		}
	}
	o.builderState.outFinished = true
	return count
}

// build creates the cross product, and writes it to the output member.
func (o *mergeJoinLeftSemiOp) build(ctx context.Context) {
	outStartIdx := o.builderState.outCount
	o.builderState.outCount = o.calculateOutputCount(o.builderState.lGroups)
	if o.output.Width() != 0 && o.builderState.outCount > outStartIdx {
		// We will be actually building the output if we have columns in the output
		// batch (meaning that we're not doing query like 'SELECT count(*) ...')
		// and when builderState.outCount has increased (meaning that we have
		// something to build).
		switch o.builderState.buildFrom {
		case mjBuildFromBatch:
			o.buildLeftGroupsFromBatch(o.builderState.lGroups, &o.left, o.proberState.lBatch, outStartIdx)
		case mjBuildFromBufferedGroup:
			o.buildLeftBufferedGroup(ctx, o.builderState.lGroups[0], &o.left, o.proberState.lBufferedGroup, outStartIdx)

		default:
			colexecerror.InternalError(fmt.Sprintf("unsupported mjBuildFrom %d", o.builderState.buildFrom))
		}
	}
}

func (o *mergeJoinLeftSemiOp) Next(ctx context.Context) coldata.Batch {
	o.mu.Lock()
	defer o.mu.Unlock()
	o.output.ResetInternalBatch()
	for {
		switch o.state {
		case mjEntry:
			o.initProberState(ctx)

			if o.nonEmptyBufferedGroup() {
				o.state = mjFinishBufferedGroup
				break
			}

			if o.sourceFinished() {
				o.state = mjSourceFinished
				break
			}

			o.state = mjProbe
		case mjSourceFinished:

			o.outputReady = true
			o.builderState.buildFrom = mjBuildFromBatch
			o.setBuilderSourceToBufferedGroup(ctx)
			o.state = mjBuild
		case mjFinishBufferedGroup:
			o.finishProbe(ctx)
			o.setBuilderSourceToBufferedGroup(ctx)
			o.state = mjBuild
		case mjProbe:
			o.probe(ctx)
			o.setBuilderSourceToBatch()
			o.state = mjBuild
		case mjBuild:
			o.build(ctx)

			if o.builderState.outFinished {
				o.state = mjEntry
				o.builderState.outFinished = false
			}

			if o.outputReady || o.builderState.outCount == o.outputBatchSize {
				if o.builderState.outCount == 0 {
					// We have already fully emitted the result of the join, so we
					// transition to "finished" state.
					o.state = mjDone
					continue
				}
				o.output.SetLength(o.builderState.outCount)
				// Reset builder out count.
				o.builderState.outCount = 0
				o.outputReady = false
				return o.output
			}
		case mjDone:
			// Note that resetting of buffered groups will close disk queues
			// (if there are any).
			if o.proberState.lBufferedGroupNeedToReset {
				o.proberState.lBufferedGroup.reset(ctx)
				o.proberState.lBufferedGroupNeedToReset = false
			}
			if o.proberState.rBufferedGroupNeedToReset {
				o.proberState.rBufferedGroup.reset(ctx)
				o.proberState.rBufferedGroupNeedToReset = false
			}
			return coldata.ZeroBatch
		default:
			colexecerror.InternalError(fmt.Sprintf("unexpected merge joiner state in Next: %v", o.state))
		}
	}
}
