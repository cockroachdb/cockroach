// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"math"
	"time"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/pkg/errors"
)

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.UNSAFEGET

func newMinAgg(allocator *Allocator, t coltypes.T) (aggregateFunc, error) {
	switch t {
	case coltypes.Bool:
		return &minBoolAgg{allocator: allocator}, nil
	case coltypes.Bytes:
		return &minBytesAgg{allocator: allocator}, nil
	case coltypes.Decimal:
		return &minDecimalAgg{allocator: allocator}, nil
	case coltypes.Int16:
		return &minInt16Agg{allocator: allocator}, nil
	case coltypes.Int32:
		return &minInt32Agg{allocator: allocator}, nil
	case coltypes.Int64:
		return &minInt64Agg{allocator: allocator}, nil
	case coltypes.Float64:
		return &minFloat64Agg{allocator: allocator}, nil
	case coltypes.Timestamp:
		return &minTimestampAgg{allocator: allocator}, nil
	default:
		return nil, errors.Errorf("unsupported min agg type %s", t)
	}
}

type minBoolAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg bool
	// col points to the output vector we are updating.
	col []bool
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBoolAgg{}

func (a *minBoolAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bool()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minBoolAgg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroBoolColumn) {
	}
	a.curAgg = zeroBoolColumn[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroBoolColumn) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *minBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBoolColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBoolColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBoolColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBoolColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minBytesAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBytesAgg{}

func (a *minBytesAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bytes()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minBytesAgg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	a.col.Zero()
	a.curAgg = zeroBytesColumn[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := a.col.Len()
		target := a.col.Slice(idx+1, vecLen)
		target.Zero()
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *minBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col.Set(a.curIdx, a.curAgg)
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBytesColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col.Get(a.curIdx)
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col.Get(int(i))
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(int(i))

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, int(inputLen))
					for i := 0; i < col.Len(); i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBytesColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col.Get(a.curIdx)
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col.Get(int(i))
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(int(i))

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBytesColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col.Get(a.curIdx)
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col.Get(int(i))
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(int(i))

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, int(inputLen))
					for i := 0; i < col.Len(); i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBytesColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col.Get(a.curIdx)
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col.Get(int(i))
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(int(i))

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minDecimalAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col []apd.Decimal
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minDecimalAgg{}

func (a *minDecimalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Decimal()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minDecimalAgg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n++ {
		a.col[n].SetInt64(0)
	}
	a.curAgg = zeroDecimalColumn[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n++ {
			target[n].SetInt64(0)
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *minDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx].Set(&a.curAgg)
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroDecimalColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroDecimalColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroDecimalColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroDecimalColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt16Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg int16
	// col points to the output vector we are updating.
	col []int16
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt16Agg{}

func (a *minInt16Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int16()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt16Agg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroInt16Column) {
	}
	a.curAgg = zeroInt16Column[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt16Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *minInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt16Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt16Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt16Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt16Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt32Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg int32
	// col points to the output vector we are updating.
	col []int32
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt32Agg{}

func (a *minInt32Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int32()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt32Agg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroInt32Column) {
	}
	a.curAgg = zeroInt32Column[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt32Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *minInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt32Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt32Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt32Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt32Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt64Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt64Agg{}

func (a *minInt64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt64Agg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroInt64Column) {
	}
	a.curAgg = zeroInt64Column[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt64Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *minInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minFloat64Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg float64
	// col points to the output vector we are updating.
	col []float64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minFloat64Agg{}

func (a *minFloat64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Float64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minFloat64Agg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroFloat64Column) {
	}
	a.curAgg = zeroFloat64Column[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroFloat64Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *minFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroFloat64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroFloat64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroFloat64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroFloat64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minTimestampAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg time.Time
	// col points to the output vector we are updating.
	col []time.Time
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minTimestampAgg{}

func (a *minTimestampAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Timestamp()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minTimestampAgg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroTimestampColumn) {
	}
	a.curAgg = zeroTimestampColumn[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroTimestampColumn) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *minTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroTimestampColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroTimestampColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroTimestampColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroTimestampColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

func newMaxAgg(allocator *Allocator, t coltypes.T) (aggregateFunc, error) {
	switch t {
	case coltypes.Bool:
		return &maxBoolAgg{allocator: allocator}, nil
	case coltypes.Bytes:
		return &maxBytesAgg{allocator: allocator}, nil
	case coltypes.Decimal:
		return &maxDecimalAgg{allocator: allocator}, nil
	case coltypes.Int16:
		return &maxInt16Agg{allocator: allocator}, nil
	case coltypes.Int32:
		return &maxInt32Agg{allocator: allocator}, nil
	case coltypes.Int64:
		return &maxInt64Agg{allocator: allocator}, nil
	case coltypes.Float64:
		return &maxFloat64Agg{allocator: allocator}, nil
	case coltypes.Timestamp:
		return &maxTimestampAgg{allocator: allocator}, nil
	default:
		return nil, errors.Errorf("unsupported min agg type %s", t)
	}
}

type maxBoolAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg bool
	// col points to the output vector we are updating.
	col []bool
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBoolAgg{}

func (a *maxBoolAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bool()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxBoolAgg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroBoolColumn) {
	}
	a.curAgg = zeroBoolColumn[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroBoolColumn) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *maxBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBoolColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBoolColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBoolColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBoolColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxBytesAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBytesAgg{}

func (a *maxBytesAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bytes()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxBytesAgg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	a.col.Zero()
	a.curAgg = zeroBytesColumn[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := a.col.Len()
		target := a.col.Slice(idx+1, vecLen)
		target.Zero()
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *maxBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col.Set(a.curIdx, a.curAgg)
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBytesColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col.Get(a.curIdx)
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col.Get(int(i))
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(int(i))

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, int(inputLen))
					for i := 0; i < col.Len(); i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBytesColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col.Get(a.curIdx)
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col.Get(int(i))
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(int(i))

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBytesColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col.Get(a.curIdx)
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col.Get(int(i))
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(int(i))

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, int(inputLen))
					for i := 0; i < col.Len(); i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroBytesColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col.Get(a.curIdx)
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col.Get(int(i))
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(int(i))

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxDecimalAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col []apd.Decimal
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxDecimalAgg{}

func (a *maxDecimalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Decimal()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxDecimalAgg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n++ {
		a.col[n].SetInt64(0)
	}
	a.curAgg = zeroDecimalColumn[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n++ {
			target[n].SetInt64(0)
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *maxDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx].Set(&a.curAgg)
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroDecimalColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroDecimalColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroDecimalColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroDecimalColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt16Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg int16
	// col points to the output vector we are updating.
	col []int16
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt16Agg{}

func (a *maxInt16Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int16()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt16Agg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroInt16Column) {
	}
	a.curAgg = zeroInt16Column[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt16Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *maxInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt16Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt16Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt16Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt16Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt32Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg int32
	// col points to the output vector we are updating.
	col []int32
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt32Agg{}

func (a *maxInt32Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int32()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt32Agg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroInt32Column) {
	}
	a.curAgg = zeroInt32Column[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt32Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *maxInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt32Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt32Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt32Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt32Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt64Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt64Agg{}

func (a *maxInt64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt64Agg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroInt64Column) {
	}
	a.curAgg = zeroInt64Column[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt64Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *maxInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroInt64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxFloat64Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg float64
	// col points to the output vector we are updating.
	col []float64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxFloat64Agg{}

func (a *maxFloat64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Float64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxFloat64Agg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroFloat64Column) {
	}
	a.curAgg = zeroFloat64Column[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroFloat64Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *maxFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroFloat64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroFloat64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroFloat64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroFloat64Column here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxTimestampAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	curAgg time.Time
	// col points to the output vector we are updating.
	col []time.Time
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxTimestampAgg{}

func (a *maxTimestampAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Timestamp()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxTimestampAgg) Reset() {
	// TODO(asubiotto): Zeros don't seem necessary.
	for n := 0; n < len(a.col); n += copy(a.col[n:], zeroTimestampColumn) {
	}
	a.curAgg = zeroTimestampColumn[0]
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.col)
		target := a.col[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroTimestampColumn) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *maxTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.allocator.performOperation(
			[]coldata.Vec{a.vec},
			func() {
				a.col[a.curIdx] = a.curAgg
			},
		)
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.performOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroTimestampColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroTimestampColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroTimestampColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(uint16(a.curIdx))
								}
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
							// The next element of vec is guaranteed  to be initialized to the zero
							// value. We can't use zeroTimestampColumn here because this is outside of
							// the earlier template block.
							a.curAgg = a.col[a.curIdx]
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								a.curAgg = col[int(i)]
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[int(i)]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}
