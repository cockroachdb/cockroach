// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"math"
	"time"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/pkg/errors"
)

// OrderedDistinctColsToOperators is a utility function that given an input and
// a slice of columns, creates a chain of distinct operators and returns the
// last distinct operator in that chain as well as its output column.
func OrderedDistinctColsToOperators(
	input Operator, distinctCols []uint32, typs []coltypes.T,
) (Operator, []bool, error) {
	distinctCol := make([]bool, coldata.BatchSize())
	// zero the boolean column on every iteration.
	input = fnOp{
		OneInputNode: NewOneInputNode(input),
		fn:           func() { copy(distinctCol, zeroBoolColumn) },
	}
	var (
		err error
		r   resettableOperator
		ok  bool
	)
	for i := range distinctCols {
		input, err = newSingleOrderedDistinct(input, int(distinctCols[i]), distinctCol, typs[distinctCols[i]])
		if err != nil {
			return nil, nil, err
		}
	}
	if r, ok = input.(resettableOperator); !ok {
		execerror.VectorizedInternalPanic("unexpectedly an ordered distinct is not a resetter")
	}
	distinctChain := &distinctChainOps{
		resettableOperator: r,
	}
	return distinctChain, distinctCol, nil
}

type distinctChainOps struct {
	resettableOperator
}

var _ resettableOperator = &distinctChainOps{}

// NewOrderedDistinct creates a new ordered distinct operator on the given
// input columns with the given coltypes.
func NewOrderedDistinct(
	input Operator, distinctCols []uint32, typs []coltypes.T,
) (Operator, error) {
	op, outputCol, err := OrderedDistinctColsToOperators(input, distinctCols, typs)
	if err != nil {
		return nil, err
	}
	return &boolVecToSelOp{
		OneInputNode: NewOneInputNode(op),
		outputCol:    outputCol,
	}, nil
}

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.UNSAFEGET

func newSingleOrderedDistinct(
	input Operator, distinctColIdx int, outputCol []bool, t coltypes.T,
) (Operator, error) {
	switch t {
	case coltypes.Bool:
		return &sortedDistinctBoolOp{
			OneInputNode:      NewOneInputNode(input),
			sortedDistinctCol: distinctColIdx,
			outputCol:         outputCol,
		}, nil
	case coltypes.Bytes:
		return &sortedDistinctBytesOp{
			OneInputNode:      NewOneInputNode(input),
			sortedDistinctCol: distinctColIdx,
			outputCol:         outputCol,
		}, nil
	case coltypes.Decimal:
		return &sortedDistinctDecimalOp{
			OneInputNode:      NewOneInputNode(input),
			sortedDistinctCol: distinctColIdx,
			outputCol:         outputCol,
		}, nil
	case coltypes.Int16:
		return &sortedDistinctInt16Op{
			OneInputNode:      NewOneInputNode(input),
			sortedDistinctCol: distinctColIdx,
			outputCol:         outputCol,
		}, nil
	case coltypes.Int32:
		return &sortedDistinctInt32Op{
			OneInputNode:      NewOneInputNode(input),
			sortedDistinctCol: distinctColIdx,
			outputCol:         outputCol,
		}, nil
	case coltypes.Int64:
		return &sortedDistinctInt64Op{
			OneInputNode:      NewOneInputNode(input),
			sortedDistinctCol: distinctColIdx,
			outputCol:         outputCol,
		}, nil
	case coltypes.Float64:
		return &sortedDistinctFloat64Op{
			OneInputNode:      NewOneInputNode(input),
			sortedDistinctCol: distinctColIdx,
			outputCol:         outputCol,
		}, nil
	case coltypes.Timestamp:
		return &sortedDistinctTimestampOp{
			OneInputNode:      NewOneInputNode(input),
			sortedDistinctCol: distinctColIdx,
			outputCol:         outputCol,
		}, nil
	default:
		return nil, errors.Errorf("unsupported distinct type %s", t)
	}
}

// partitioner is a simple implementation of sorted distinct that's useful for
// other operators that need to partition an arbitrarily-sized Vec.
type partitioner interface {
	// partition partitions the input colVec of size n, writing true to the
	// outputCol for every value that differs from the previous one.
	partition(colVec coldata.Vec, outputCol []bool, n uint64)

	// partitionWithOrder is like partition, except it performs the partitioning
	// on the input Vec as if it were ordered via the input order vector, which is
	// a selection vector. The output is written in absolute order, however. For
	// example, with an input vector [a,b,b] and an order vector [1,2,0], which
	// implies a reordered input vector [b,b,a], the resultant outputCol would be
	// [true, false, true], indicating a distinct value at the 0th and 2nd
	// elements.
	partitionWithOrder(colVec coldata.Vec, order []uint64, outputCol []bool, n uint64)
}

// newPartitioner returns a new partitioner on type t.
func newPartitioner(t coltypes.T) (partitioner, error) {
	switch t {
	case coltypes.Bool:
		return partitionerBool{}, nil
	case coltypes.Bytes:
		return partitionerBytes{}, nil
	case coltypes.Decimal:
		return partitionerDecimal{}, nil
	case coltypes.Int16:
		return partitionerInt16{}, nil
	case coltypes.Int32:
		return partitionerInt32{}, nil
	case coltypes.Int64:
		return partitionerInt64{}, nil
	case coltypes.Float64:
		return partitionerFloat64{}, nil
	case coltypes.Timestamp:
		return partitionerTimestamp{}, nil
	default:
		return nil, errors.Errorf("unsupported partition type %s", t)
	}
}

// sortedDistinctBoolOp runs a distinct on the column in sortedDistinctCol,
// writing true to the resultant bool column for every value that differs from
// the previous one.
// TODO(solon): Update this name to remove "sorted". The input values are not
// necessarily in sorted order.
type sortedDistinctBoolOp struct {
	OneInputNode

	// sortedDistinctCol is the index of the column to distinct upon.
	sortedDistinctCol int

	// outputCol is the boolean output column. It is shared by all of the
	// other distinct operators in a distinct operator set.
	outputCol []bool

	// Set to true at runtime when we've seen the first row. Distinct always
	// outputs the first row that it sees.
	foundFirstRow bool

	// lastVal is the last value seen by the operator, so that the distincting
	// still works across batch boundaries.
	lastVal     bool
	lastValNull bool
}

var _ resettableOperator = &sortedDistinctBoolOp{}

func (p *sortedDistinctBoolOp) Init() {
	p.input.Init()
}

func (p *sortedDistinctBoolOp) reset() {
	p.foundFirstRow = false
	p.lastValNull = false
	if resetter, ok := p.input.(resetter); ok {
		resetter.reset()
	}
}

func (p *sortedDistinctBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}
	outputCol := p.outputCol
	vec := batch.ColVec(p.sortedDistinctCol)
	var nulls *coldata.Nulls
	if vec.MaybeHasNulls() {
		nulls = vec.Nulls()
	}
	col := vec.Bool()

	// We always output the first row.
	lastVal := p.lastVal
	lastValNull := p.lastValNull
	sel := batch.Selection()
	firstIdx := uint16(0)
	if sel != nil {
		firstIdx = sel[0]
	}
	if !p.foundFirstRow {
		outputCol[firstIdx] = true
		p.foundFirstRow = true
	} else if nulls == nil && lastValNull {
		// The last value of the previous batch was null, so the first value of this
		// non-null batch is distinct.
		outputCol[firstIdx] = true
		lastValNull = false
	}

	n := batch.Length()
	if sel != nil {
		// Bounds check elimination.
		sel = sel[:n]
		if nulls != nil {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							if !v && lastVal {
								cmpResult = -1
							} else if v && !lastVal {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					if !v && lastVal {
						cmpResult = -1
					} else if v && !lastVal {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	} else {
		// Bounds check elimination.
		col = col[0:int(n)]
		outputCol = outputCol[:n]
		_ = outputCol[len(col)-1]
		if nulls != nil {
			for checkIdx := range col {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							if !v && lastVal {
								cmpResult = -1
							} else if v && !lastVal {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for checkIdx := range col {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					if !v && lastVal {
						cmpResult = -1
					} else if v && !lastVal {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	}

	p.lastVal = lastVal
	p.lastValNull = lastValNull

	return batch
}

// partitionerBool partitions an arbitrary-length colVec by running a distinct
// operation over it. It writes the same format to outputCol that sorted
// distinct does: true for every row that differs from the previous row in the
// input column.
type partitionerBool struct{}

func (p partitionerBool) partitionWithOrder(
	colVec coldata.Vec, order []uint64, outputCol []bool, n uint64,
) {
	var lastVal bool
	var lastValNull bool
	var nulls *coldata.Nulls
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Bool()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for outputIdx, checkIdx := range order {
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						if !v && lastVal {
							cmpResult = -1
						} else if v && !lastVal {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				if !v && lastVal {
					cmpResult = -1
				} else if v && !lastVal {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

func (p partitionerBool) partition(colVec coldata.Vec, outputCol []bool, n uint64) {
	var (
		lastVal     bool
		lastValNull bool
		nulls       *coldata.Nulls
	)
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Bool()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for checkIdx := range col {
			outputIdx := checkIdx
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						if !v && lastVal {
							cmpResult = -1
						} else if v && !lastVal {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for checkIdx := range col {
			outputIdx := checkIdx
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				if !v && lastVal {
					cmpResult = -1
				} else if v && !lastVal {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

// sortedDistinctBytesOp runs a distinct on the column in sortedDistinctCol,
// writing true to the resultant bool column for every value that differs from
// the previous one.
// TODO(solon): Update this name to remove "sorted". The input values are not
// necessarily in sorted order.
type sortedDistinctBytesOp struct {
	OneInputNode

	// sortedDistinctCol is the index of the column to distinct upon.
	sortedDistinctCol int

	// outputCol is the boolean output column. It is shared by all of the
	// other distinct operators in a distinct operator set.
	outputCol []bool

	// Set to true at runtime when we've seen the first row. Distinct always
	// outputs the first row that it sees.
	foundFirstRow bool

	// lastVal is the last value seen by the operator, so that the distincting
	// still works across batch boundaries.
	lastVal     []byte
	lastValNull bool
}

var _ resettableOperator = &sortedDistinctBytesOp{}

func (p *sortedDistinctBytesOp) Init() {
	p.input.Init()
}

func (p *sortedDistinctBytesOp) reset() {
	p.foundFirstRow = false
	p.lastValNull = false
	if resetter, ok := p.input.(resetter); ok {
		resetter.reset()
	}
}

func (p *sortedDistinctBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}
	outputCol := p.outputCol
	vec := batch.ColVec(p.sortedDistinctCol)
	var nulls *coldata.Nulls
	if vec.MaybeHasNulls() {
		nulls = vec.Nulls()
	}
	col := vec.Bytes()

	// We always output the first row.
	lastVal := p.lastVal
	lastValNull := p.lastValNull
	sel := batch.Selection()
	firstIdx := uint16(0)
	if sel != nil {
		firstIdx = sel[0]
	}
	if !p.foundFirstRow {
		outputCol[firstIdx] = true
		p.foundFirstRow = true
	} else if nulls == nil && lastValNull {
		// The last value of the previous batch was null, so the first value of this
		// non-null batch is distinct.
		outputCol[firstIdx] = true
		lastValNull = false
	}

	n := batch.Length()
	if sel != nil {
		// Bounds check elimination.
		sel = sel[:n]
		if nulls != nil {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col.Get(int(checkIdx))
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int
							cmpResult = bytes.Compare(v, lastVal)
							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = append(lastVal[:0], v...)
				}
				lastValNull = null
			}
		} else {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				v := col.Get(int(checkIdx))
				var unique bool

				{
					var cmpResult int
					cmpResult = bytes.Compare(v, lastVal)
					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = append(lastVal[:0], v...)
			}
		}
	} else {
		// Bounds check elimination.
		col = col.Slice(0, int(n))
		outputCol = outputCol[:n]
		_ = outputCol[col.Len()-1]
		if nulls != nil {
			for checkIdx := 0; checkIdx < col.Len(); checkIdx++ {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col.Get(int(checkIdx))
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int
							cmpResult = bytes.Compare(v, lastVal)
							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = append(lastVal[:0], v...)
				}
				lastValNull = null
			}
		} else {
			for checkIdx := 0; checkIdx < col.Len(); checkIdx++ {
				outputIdx := checkIdx
				v := col.Get(int(checkIdx))
				var unique bool

				{
					var cmpResult int
					cmpResult = bytes.Compare(v, lastVal)
					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = append(lastVal[:0], v...)
			}
		}
	}

	p.lastVal = lastVal
	p.lastValNull = lastValNull

	return batch
}

// partitionerBytes partitions an arbitrary-length colVec by running a distinct
// operation over it. It writes the same format to outputCol that sorted
// distinct does: true for every row that differs from the previous row in the
// input column.
type partitionerBytes struct{}

func (p partitionerBytes) partitionWithOrder(
	colVec coldata.Vec, order []uint64, outputCol []bool, n uint64,
) {
	var lastVal []byte
	var lastValNull bool
	var nulls *coldata.Nulls
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Bytes()
	col = col.Slice(0, int(n))
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for outputIdx, checkIdx := range order {
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col.Get(int(checkIdx))
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int
						cmpResult = bytes.Compare(v, lastVal)
						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = append(lastVal[:0], v...)
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := col.Get(int(checkIdx))
			var unique bool

			{
				var cmpResult int
				cmpResult = bytes.Compare(v, lastVal)
				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = append(lastVal[:0], v...)
		}
	}
}

func (p partitionerBytes) partition(colVec coldata.Vec, outputCol []bool, n uint64) {
	var (
		lastVal     []byte
		lastValNull bool
		nulls       *coldata.Nulls
	)
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Bytes()
	col = col.Slice(0, int(n))
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for checkIdx := 0; checkIdx < col.Len(); checkIdx++ {
			outputIdx := checkIdx
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col.Get(int(checkIdx))
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int
						cmpResult = bytes.Compare(v, lastVal)
						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = append(lastVal[:0], v...)
			}
			lastValNull = null
		}
	} else {
		for checkIdx := 0; checkIdx < col.Len(); checkIdx++ {
			outputIdx := checkIdx
			v := col.Get(int(checkIdx))
			var unique bool

			{
				var cmpResult int
				cmpResult = bytes.Compare(v, lastVal)
				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = append(lastVal[:0], v...)
		}
	}
}

// sortedDistinctDecimalOp runs a distinct on the column in sortedDistinctCol,
// writing true to the resultant bool column for every value that differs from
// the previous one.
// TODO(solon): Update this name to remove "sorted". The input values are not
// necessarily in sorted order.
type sortedDistinctDecimalOp struct {
	OneInputNode

	// sortedDistinctCol is the index of the column to distinct upon.
	sortedDistinctCol int

	// outputCol is the boolean output column. It is shared by all of the
	// other distinct operators in a distinct operator set.
	outputCol []bool

	// Set to true at runtime when we've seen the first row. Distinct always
	// outputs the first row that it sees.
	foundFirstRow bool

	// lastVal is the last value seen by the operator, so that the distincting
	// still works across batch boundaries.
	lastVal     apd.Decimal
	lastValNull bool
}

var _ resettableOperator = &sortedDistinctDecimalOp{}

func (p *sortedDistinctDecimalOp) Init() {
	p.input.Init()
}

func (p *sortedDistinctDecimalOp) reset() {
	p.foundFirstRow = false
	p.lastValNull = false
	if resetter, ok := p.input.(resetter); ok {
		resetter.reset()
	}
}

func (p *sortedDistinctDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}
	outputCol := p.outputCol
	vec := batch.ColVec(p.sortedDistinctCol)
	var nulls *coldata.Nulls
	if vec.MaybeHasNulls() {
		nulls = vec.Nulls()
	}
	col := vec.Decimal()

	// We always output the first row.
	lastVal := p.lastVal
	lastValNull := p.lastValNull
	sel := batch.Selection()
	firstIdx := uint16(0)
	if sel != nil {
		firstIdx = sel[0]
	}
	if !p.foundFirstRow {
		outputCol[firstIdx] = true
		p.foundFirstRow = true
	} else if nulls == nil && lastValNull {
		// The last value of the previous batch was null, so the first value of this
		// non-null batch is distinct.
		outputCol[firstIdx] = true
		lastValNull = false
	}

	n := batch.Length()
	if sel != nil {
		// Bounds check elimination.
		sel = sel[:n]
		if nulls != nil {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&v, &lastVal)
							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal.Set(&v)
				}
				lastValNull = null
			}
		} else {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&v, &lastVal)
					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal.Set(&v)
			}
		}
	} else {
		// Bounds check elimination.
		col = col[0:int(n)]
		outputCol = outputCol[:n]
		_ = outputCol[len(col)-1]
		if nulls != nil {
			for checkIdx := range col {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&v, &lastVal)
							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal.Set(&v)
				}
				lastValNull = null
			}
		} else {
			for checkIdx := range col {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&v, &lastVal)
					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal.Set(&v)
			}
		}
	}

	p.lastVal = lastVal
	p.lastValNull = lastValNull

	return batch
}

// partitionerDecimal partitions an arbitrary-length colVec by running a distinct
// operation over it. It writes the same format to outputCol that sorted
// distinct does: true for every row that differs from the previous row in the
// input column.
type partitionerDecimal struct{}

func (p partitionerDecimal) partitionWithOrder(
	colVec coldata.Vec, order []uint64, outputCol []bool, n uint64,
) {
	var lastVal apd.Decimal
	var lastValNull bool
	var nulls *coldata.Nulls
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Decimal()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for outputIdx, checkIdx := range order {
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&v, &lastVal)
						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal.Set(&v)
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&v, &lastVal)
				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal.Set(&v)
		}
	}
}

func (p partitionerDecimal) partition(colVec coldata.Vec, outputCol []bool, n uint64) {
	var (
		lastVal     apd.Decimal
		lastValNull bool
		nulls       *coldata.Nulls
	)
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Decimal()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for checkIdx := range col {
			outputIdx := checkIdx
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&v, &lastVal)
						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal.Set(&v)
			}
			lastValNull = null
		}
	} else {
		for checkIdx := range col {
			outputIdx := checkIdx
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&v, &lastVal)
				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal.Set(&v)
		}
	}
}

// sortedDistinctInt16Op runs a distinct on the column in sortedDistinctCol,
// writing true to the resultant bool column for every value that differs from
// the previous one.
// TODO(solon): Update this name to remove "sorted". The input values are not
// necessarily in sorted order.
type sortedDistinctInt16Op struct {
	OneInputNode

	// sortedDistinctCol is the index of the column to distinct upon.
	sortedDistinctCol int

	// outputCol is the boolean output column. It is shared by all of the
	// other distinct operators in a distinct operator set.
	outputCol []bool

	// Set to true at runtime when we've seen the first row. Distinct always
	// outputs the first row that it sees.
	foundFirstRow bool

	// lastVal is the last value seen by the operator, so that the distincting
	// still works across batch boundaries.
	lastVal     int16
	lastValNull bool
}

var _ resettableOperator = &sortedDistinctInt16Op{}

func (p *sortedDistinctInt16Op) Init() {
	p.input.Init()
}

func (p *sortedDistinctInt16Op) reset() {
	p.foundFirstRow = false
	p.lastValNull = false
	if resetter, ok := p.input.(resetter); ok {
		resetter.reset()
	}
}

func (p *sortedDistinctInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}
	outputCol := p.outputCol
	vec := batch.ColVec(p.sortedDistinctCol)
	var nulls *coldata.Nulls
	if vec.MaybeHasNulls() {
		nulls = vec.Nulls()
	}
	col := vec.Int16()

	// We always output the first row.
	lastVal := p.lastVal
	lastValNull := p.lastValNull
	sel := batch.Selection()
	firstIdx := uint16(0)
	if sel != nil {
		firstIdx = sel[0]
	}
	if !p.foundFirstRow {
		outputCol[firstIdx] = true
		p.foundFirstRow = true
	} else if nulls == nil && lastValNull {
		// The last value of the previous batch was null, so the first value of this
		// non-null batch is distinct.
		outputCol[firstIdx] = true
		lastValNull = false
	}

	n := batch.Length()
	if sel != nil {
		// Bounds check elimination.
		sel = sel[:n]
		if nulls != nil {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							{
								a, b := int64(v), int64(lastVal)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					{
						a, b := int64(v), int64(lastVal)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	} else {
		// Bounds check elimination.
		col = col[0:int(n)]
		outputCol = outputCol[:n]
		_ = outputCol[len(col)-1]
		if nulls != nil {
			for checkIdx := range col {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							{
								a, b := int64(v), int64(lastVal)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for checkIdx := range col {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					{
						a, b := int64(v), int64(lastVal)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	}

	p.lastVal = lastVal
	p.lastValNull = lastValNull

	return batch
}

// partitionerInt16 partitions an arbitrary-length colVec by running a distinct
// operation over it. It writes the same format to outputCol that sorted
// distinct does: true for every row that differs from the previous row in the
// input column.
type partitionerInt16 struct{}

func (p partitionerInt16) partitionWithOrder(
	colVec coldata.Vec, order []uint64, outputCol []bool, n uint64,
) {
	var lastVal int16
	var lastValNull bool
	var nulls *coldata.Nulls
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Int16()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for outputIdx, checkIdx := range order {
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := int64(v), int64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				{
					a, b := int64(v), int64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

func (p partitionerInt16) partition(colVec coldata.Vec, outputCol []bool, n uint64) {
	var (
		lastVal     int16
		lastValNull bool
		nulls       *coldata.Nulls
	)
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Int16()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for checkIdx := range col {
			outputIdx := checkIdx
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := int64(v), int64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for checkIdx := range col {
			outputIdx := checkIdx
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				{
					a, b := int64(v), int64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

// sortedDistinctInt32Op runs a distinct on the column in sortedDistinctCol,
// writing true to the resultant bool column for every value that differs from
// the previous one.
// TODO(solon): Update this name to remove "sorted". The input values are not
// necessarily in sorted order.
type sortedDistinctInt32Op struct {
	OneInputNode

	// sortedDistinctCol is the index of the column to distinct upon.
	sortedDistinctCol int

	// outputCol is the boolean output column. It is shared by all of the
	// other distinct operators in a distinct operator set.
	outputCol []bool

	// Set to true at runtime when we've seen the first row. Distinct always
	// outputs the first row that it sees.
	foundFirstRow bool

	// lastVal is the last value seen by the operator, so that the distincting
	// still works across batch boundaries.
	lastVal     int32
	lastValNull bool
}

var _ resettableOperator = &sortedDistinctInt32Op{}

func (p *sortedDistinctInt32Op) Init() {
	p.input.Init()
}

func (p *sortedDistinctInt32Op) reset() {
	p.foundFirstRow = false
	p.lastValNull = false
	if resetter, ok := p.input.(resetter); ok {
		resetter.reset()
	}
}

func (p *sortedDistinctInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}
	outputCol := p.outputCol
	vec := batch.ColVec(p.sortedDistinctCol)
	var nulls *coldata.Nulls
	if vec.MaybeHasNulls() {
		nulls = vec.Nulls()
	}
	col := vec.Int32()

	// We always output the first row.
	lastVal := p.lastVal
	lastValNull := p.lastValNull
	sel := batch.Selection()
	firstIdx := uint16(0)
	if sel != nil {
		firstIdx = sel[0]
	}
	if !p.foundFirstRow {
		outputCol[firstIdx] = true
		p.foundFirstRow = true
	} else if nulls == nil && lastValNull {
		// The last value of the previous batch was null, so the first value of this
		// non-null batch is distinct.
		outputCol[firstIdx] = true
		lastValNull = false
	}

	n := batch.Length()
	if sel != nil {
		// Bounds check elimination.
		sel = sel[:n]
		if nulls != nil {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							{
								a, b := int64(v), int64(lastVal)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					{
						a, b := int64(v), int64(lastVal)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	} else {
		// Bounds check elimination.
		col = col[0:int(n)]
		outputCol = outputCol[:n]
		_ = outputCol[len(col)-1]
		if nulls != nil {
			for checkIdx := range col {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							{
								a, b := int64(v), int64(lastVal)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for checkIdx := range col {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					{
						a, b := int64(v), int64(lastVal)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	}

	p.lastVal = lastVal
	p.lastValNull = lastValNull

	return batch
}

// partitionerInt32 partitions an arbitrary-length colVec by running a distinct
// operation over it. It writes the same format to outputCol that sorted
// distinct does: true for every row that differs from the previous row in the
// input column.
type partitionerInt32 struct{}

func (p partitionerInt32) partitionWithOrder(
	colVec coldata.Vec, order []uint64, outputCol []bool, n uint64,
) {
	var lastVal int32
	var lastValNull bool
	var nulls *coldata.Nulls
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Int32()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for outputIdx, checkIdx := range order {
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := int64(v), int64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				{
					a, b := int64(v), int64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

func (p partitionerInt32) partition(colVec coldata.Vec, outputCol []bool, n uint64) {
	var (
		lastVal     int32
		lastValNull bool
		nulls       *coldata.Nulls
	)
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Int32()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for checkIdx := range col {
			outputIdx := checkIdx
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := int64(v), int64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for checkIdx := range col {
			outputIdx := checkIdx
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				{
					a, b := int64(v), int64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

// sortedDistinctInt64Op runs a distinct on the column in sortedDistinctCol,
// writing true to the resultant bool column for every value that differs from
// the previous one.
// TODO(solon): Update this name to remove "sorted". The input values are not
// necessarily in sorted order.
type sortedDistinctInt64Op struct {
	OneInputNode

	// sortedDistinctCol is the index of the column to distinct upon.
	sortedDistinctCol int

	// outputCol is the boolean output column. It is shared by all of the
	// other distinct operators in a distinct operator set.
	outputCol []bool

	// Set to true at runtime when we've seen the first row. Distinct always
	// outputs the first row that it sees.
	foundFirstRow bool

	// lastVal is the last value seen by the operator, so that the distincting
	// still works across batch boundaries.
	lastVal     int64
	lastValNull bool
}

var _ resettableOperator = &sortedDistinctInt64Op{}

func (p *sortedDistinctInt64Op) Init() {
	p.input.Init()
}

func (p *sortedDistinctInt64Op) reset() {
	p.foundFirstRow = false
	p.lastValNull = false
	if resetter, ok := p.input.(resetter); ok {
		resetter.reset()
	}
}

func (p *sortedDistinctInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}
	outputCol := p.outputCol
	vec := batch.ColVec(p.sortedDistinctCol)
	var nulls *coldata.Nulls
	if vec.MaybeHasNulls() {
		nulls = vec.Nulls()
	}
	col := vec.Int64()

	// We always output the first row.
	lastVal := p.lastVal
	lastValNull := p.lastValNull
	sel := batch.Selection()
	firstIdx := uint16(0)
	if sel != nil {
		firstIdx = sel[0]
	}
	if !p.foundFirstRow {
		outputCol[firstIdx] = true
		p.foundFirstRow = true
	} else if nulls == nil && lastValNull {
		// The last value of the previous batch was null, so the first value of this
		// non-null batch is distinct.
		outputCol[firstIdx] = true
		lastValNull = false
	}

	n := batch.Length()
	if sel != nil {
		// Bounds check elimination.
		sel = sel[:n]
		if nulls != nil {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							{
								a, b := int64(v), int64(lastVal)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					{
						a, b := int64(v), int64(lastVal)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	} else {
		// Bounds check elimination.
		col = col[0:int(n)]
		outputCol = outputCol[:n]
		_ = outputCol[len(col)-1]
		if nulls != nil {
			for checkIdx := range col {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							{
								a, b := int64(v), int64(lastVal)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for checkIdx := range col {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					{
						a, b := int64(v), int64(lastVal)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	}

	p.lastVal = lastVal
	p.lastValNull = lastValNull

	return batch
}

// partitionerInt64 partitions an arbitrary-length colVec by running a distinct
// operation over it. It writes the same format to outputCol that sorted
// distinct does: true for every row that differs from the previous row in the
// input column.
type partitionerInt64 struct{}

func (p partitionerInt64) partitionWithOrder(
	colVec coldata.Vec, order []uint64, outputCol []bool, n uint64,
) {
	var lastVal int64
	var lastValNull bool
	var nulls *coldata.Nulls
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Int64()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for outputIdx, checkIdx := range order {
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := int64(v), int64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				{
					a, b := int64(v), int64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

func (p partitionerInt64) partition(colVec coldata.Vec, outputCol []bool, n uint64) {
	var (
		lastVal     int64
		lastValNull bool
		nulls       *coldata.Nulls
	)
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Int64()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for checkIdx := range col {
			outputIdx := checkIdx
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := int64(v), int64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for checkIdx := range col {
			outputIdx := checkIdx
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				{
					a, b := int64(v), int64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

// sortedDistinctFloat64Op runs a distinct on the column in sortedDistinctCol,
// writing true to the resultant bool column for every value that differs from
// the previous one.
// TODO(solon): Update this name to remove "sorted". The input values are not
// necessarily in sorted order.
type sortedDistinctFloat64Op struct {
	OneInputNode

	// sortedDistinctCol is the index of the column to distinct upon.
	sortedDistinctCol int

	// outputCol is the boolean output column. It is shared by all of the
	// other distinct operators in a distinct operator set.
	outputCol []bool

	// Set to true at runtime when we've seen the first row. Distinct always
	// outputs the first row that it sees.
	foundFirstRow bool

	// lastVal is the last value seen by the operator, so that the distincting
	// still works across batch boundaries.
	lastVal     float64
	lastValNull bool
}

var _ resettableOperator = &sortedDistinctFloat64Op{}

func (p *sortedDistinctFloat64Op) Init() {
	p.input.Init()
}

func (p *sortedDistinctFloat64Op) reset() {
	p.foundFirstRow = false
	p.lastValNull = false
	if resetter, ok := p.input.(resetter); ok {
		resetter.reset()
	}
}

func (p *sortedDistinctFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}
	outputCol := p.outputCol
	vec := batch.ColVec(p.sortedDistinctCol)
	var nulls *coldata.Nulls
	if vec.MaybeHasNulls() {
		nulls = vec.Nulls()
	}
	col := vec.Float64()

	// We always output the first row.
	lastVal := p.lastVal
	lastValNull := p.lastValNull
	sel := batch.Selection()
	firstIdx := uint16(0)
	if sel != nil {
		firstIdx = sel[0]
	}
	if !p.foundFirstRow {
		outputCol[firstIdx] = true
		p.foundFirstRow = true
	} else if nulls == nil && lastValNull {
		// The last value of the previous batch was null, so the first value of this
		// non-null batch is distinct.
		outputCol[firstIdx] = true
		lastValNull = false
	}

	n := batch.Length()
	if sel != nil {
		// Bounds check elimination.
		sel = sel[:n]
		if nulls != nil {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							{
								a, b := float64(v), float64(lastVal)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					{
						a, b := float64(v), float64(lastVal)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	} else {
		// Bounds check elimination.
		col = col[0:int(n)]
		outputCol = outputCol[:n]
		_ = outputCol[len(col)-1]
		if nulls != nil {
			for checkIdx := range col {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							{
								a, b := float64(v), float64(lastVal)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for checkIdx := range col {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					{
						a, b := float64(v), float64(lastVal)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	}

	p.lastVal = lastVal
	p.lastValNull = lastValNull

	return batch
}

// partitionerFloat64 partitions an arbitrary-length colVec by running a distinct
// operation over it. It writes the same format to outputCol that sorted
// distinct does: true for every row that differs from the previous row in the
// input column.
type partitionerFloat64 struct{}

func (p partitionerFloat64) partitionWithOrder(
	colVec coldata.Vec, order []uint64, outputCol []bool, n uint64,
) {
	var lastVal float64
	var lastValNull bool
	var nulls *coldata.Nulls
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Float64()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for outputIdx, checkIdx := range order {
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := float64(v), float64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				{
					a, b := float64(v), float64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

func (p partitionerFloat64) partition(colVec coldata.Vec, outputCol []bool, n uint64) {
	var (
		lastVal     float64
		lastValNull bool
		nulls       *coldata.Nulls
	)
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Float64()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for checkIdx := range col {
			outputIdx := checkIdx
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := float64(v), float64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for checkIdx := range col {
			outputIdx := checkIdx
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				{
					a, b := float64(v), float64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

// sortedDistinctTimestampOp runs a distinct on the column in sortedDistinctCol,
// writing true to the resultant bool column for every value that differs from
// the previous one.
// TODO(solon): Update this name to remove "sorted". The input values are not
// necessarily in sorted order.
type sortedDistinctTimestampOp struct {
	OneInputNode

	// sortedDistinctCol is the index of the column to distinct upon.
	sortedDistinctCol int

	// outputCol is the boolean output column. It is shared by all of the
	// other distinct operators in a distinct operator set.
	outputCol []bool

	// Set to true at runtime when we've seen the first row. Distinct always
	// outputs the first row that it sees.
	foundFirstRow bool

	// lastVal is the last value seen by the operator, so that the distincting
	// still works across batch boundaries.
	lastVal     time.Time
	lastValNull bool
}

var _ resettableOperator = &sortedDistinctTimestampOp{}

func (p *sortedDistinctTimestampOp) Init() {
	p.input.Init()
}

func (p *sortedDistinctTimestampOp) reset() {
	p.foundFirstRow = false
	p.lastValNull = false
	if resetter, ok := p.input.(resetter); ok {
		resetter.reset()
	}
}

func (p *sortedDistinctTimestampOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	if batch.Length() == 0 {
		return batch
	}
	outputCol := p.outputCol
	vec := batch.ColVec(p.sortedDistinctCol)
	var nulls *coldata.Nulls
	if vec.MaybeHasNulls() {
		nulls = vec.Nulls()
	}
	col := vec.Timestamp()

	// We always output the first row.
	lastVal := p.lastVal
	lastValNull := p.lastValNull
	sel := batch.Selection()
	firstIdx := uint16(0)
	if sel != nil {
		firstIdx = sel[0]
	}
	if !p.foundFirstRow {
		outputCol[firstIdx] = true
		p.foundFirstRow = true
	} else if nulls == nil && lastValNull {
		// The last value of the previous batch was null, so the first value of this
		// non-null batch is distinct.
		outputCol[firstIdx] = true
		lastValNull = false
	}

	n := batch.Length()
	if sel != nil {
		// Bounds check elimination.
		sel = sel[:n]
		if nulls != nil {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							if v.Before(lastVal) {
								cmpResult = -1
							} else if lastVal.Before(v) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for _, checkIdx := range sel {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					if v.Before(lastVal) {
						cmpResult = -1
					} else if lastVal.Before(v) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	} else {
		// Bounds check elimination.
		col = col[0:int(n)]
		outputCol = outputCol[:n]
		_ = outputCol[len(col)-1]
		if nulls != nil {
			for checkIdx := range col {
				outputIdx := checkIdx
				null := nulls.NullAt(uint16(checkIdx))
				if null {
					if !lastValNull {
						// The current value is null while the previous was not.
						outputCol[outputIdx] = true
					}
				} else {
					v := col[int(checkIdx)]
					if lastValNull {
						// The previous value was null while the current is not.
						outputCol[outputIdx] = true
					} else {
						// Neither value is null, so we must compare.
						var unique bool

						{
							var cmpResult int

							if v.Before(lastVal) {
								cmpResult = -1
							} else if lastVal.Before(v) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							unique = cmpResult != 0
						}

						outputCol[outputIdx] = outputCol[outputIdx] || unique
					}
					lastVal = v
				}
				lastValNull = null
			}
		} else {
			for checkIdx := range col {
				outputIdx := checkIdx
				v := col[int(checkIdx)]
				var unique bool

				{
					var cmpResult int

					if v.Before(lastVal) {
						cmpResult = -1
					} else if lastVal.Before(v) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					unique = cmpResult != 0
				}

				outputCol[outputIdx] = outputCol[outputIdx] || unique
				lastVal = v
			}
		}
	}

	p.lastVal = lastVal
	p.lastValNull = lastValNull

	return batch
}

// partitionerTimestamp partitions an arbitrary-length colVec by running a distinct
// operation over it. It writes the same format to outputCol that sorted
// distinct does: true for every row that differs from the previous row in the
// input column.
type partitionerTimestamp struct{}

func (p partitionerTimestamp) partitionWithOrder(
	colVec coldata.Vec, order []uint64, outputCol []bool, n uint64,
) {
	var lastVal time.Time
	var lastValNull bool
	var nulls *coldata.Nulls
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Timestamp()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for outputIdx, checkIdx := range order {
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						if v.Before(lastVal) {
							cmpResult = -1
						} else if lastVal.Before(v) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				if v.Before(lastVal) {
					cmpResult = -1
				} else if lastVal.Before(v) {
					cmpResult = 1
				} else {
					cmpResult = 0
				}
				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}

func (p partitionerTimestamp) partition(colVec coldata.Vec, outputCol []bool, n uint64) {
	var (
		lastVal     time.Time
		lastValNull bool
		nulls       *coldata.Nulls
	)
	if colVec.MaybeHasNulls() {
		nulls = colVec.Nulls()
	}

	col := colVec.Timestamp()
	col = col[0:int(n)]
	outputCol = outputCol[:n]
	outputCol[0] = true
	if nulls != nil {
		for checkIdx := range col {
			outputIdx := checkIdx
			null := nulls.NullAt(uint16(checkIdx))
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					outputCol[outputIdx] = true
				}
			} else {
				v := col[int(checkIdx)]
				if lastValNull {
					// The previous value was null while the current is not.
					outputCol[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						if v.Before(lastVal) {
							cmpResult = -1
						} else if lastVal.Before(v) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						unique = cmpResult != 0
					}

					outputCol[outputIdx] = outputCol[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for checkIdx := range col {
			outputIdx := checkIdx
			v := col[int(checkIdx)]
			var unique bool

			{
				var cmpResult int

				if v.Before(lastVal) {
					cmpResult = -1
				} else if lastVal.Before(v) {
					cmpResult = 1
				} else {
					cmpResult = 0
				}
				unique = cmpResult != 0
			}

			outputCol[outputIdx] = outputCol[outputIdx] || unique
			lastVal = v
		}
	}
}
