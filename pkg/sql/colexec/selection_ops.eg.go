// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"math"
	"time"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

// selConstOpBase contains all of the fields for binary selections with a
// constant, except for the constant itself.
type selConstOpBase struct {
	OneInputNode
	colIdx         int
	overloadHelper overloadHelper
}

// selOpBase contains all of the fields for non-constant binary selections.
type selOpBase struct {
	OneInputNode
	col1Idx        int
	col2Idx        int
	overloadHelper overloadHelper
}

type selEQBoolBoolConstOp struct {
	selConstOpBase
	constArg bool
}

func (p *selEQBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQBoolBoolConstOp) Init() {
	p.input.Init()
}

type selEQBoolBoolOp struct {
	selOpBase
}

func (p *selEQBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQBoolBoolOp) Init() {
	p.input.Init()
}

type selEQBytesBytesConstOp struct {
	selConstOpBase
	constArg []byte
}

func (p *selEQBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQBytesBytesConstOp) Init() {
	p.input.Init()
}

type selEQBytesBytesOp struct {
	selOpBase
}

func (p *selEQBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQBytesBytesOp) Init() {
	p.input.Init()
}

type selEQDecimalInt16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selEQDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalInt16Op struct {
	selOpBase
}

func (p *selEQDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalInt16Op) Init() {
	p.input.Init()
}

type selEQDecimalInt32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selEQDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalInt32Op struct {
	selOpBase
}

func (p *selEQDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalInt32Op) Init() {
	p.input.Init()
}

type selEQDecimalInt64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selEQDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalInt64Op struct {
	selOpBase
}

func (p *selEQDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalInt64Op) Init() {
	p.input.Init()
}

type selEQDecimalFloat64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selEQDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalFloat64Op struct {
	selOpBase
}

func (p *selEQDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalFloat64Op) Init() {
	p.input.Init()
}

type selEQDecimalDecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selEQDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selEQDecimalDecimalOp struct {
	selOpBase
}

func (p *selEQDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDecimalDecimalOp) Init() {
	p.input.Init()
}

type selEQInt16Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selEQInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Int16Op struct {
	selOpBase
}

func (p *selEQInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16Int16Op) Init() {
	p.input.Init()
}

type selEQInt16Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selEQInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Int32Op struct {
	selOpBase
}

func (p *selEQInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16Int32Op) Init() {
	p.input.Init()
}

type selEQInt16Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selEQInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Int64Op struct {
	selOpBase
}

func (p *selEQInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16Int64Op) Init() {
	p.input.Init()
}

type selEQInt16Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selEQInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Float64Op struct {
	selOpBase
}

func (p *selEQInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16Float64Op) Init() {
	p.input.Init()
}

type selEQInt16DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selEQInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selEQInt16DecimalOp struct {
	selOpBase
}

func (p *selEQInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt16DecimalOp) Init() {
	p.input.Init()
}

type selEQInt32Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selEQInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Int16Op struct {
	selOpBase
}

func (p *selEQInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32Int16Op) Init() {
	p.input.Init()
}

type selEQInt32Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selEQInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Int32Op struct {
	selOpBase
}

func (p *selEQInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32Int32Op) Init() {
	p.input.Init()
}

type selEQInt32Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selEQInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Int64Op struct {
	selOpBase
}

func (p *selEQInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32Int64Op) Init() {
	p.input.Init()
}

type selEQInt32Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selEQInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Float64Op struct {
	selOpBase
}

func (p *selEQInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32Float64Op) Init() {
	p.input.Init()
}

type selEQInt32DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selEQInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selEQInt32DecimalOp struct {
	selOpBase
}

func (p *selEQInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt32DecimalOp) Init() {
	p.input.Init()
}

type selEQInt64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selEQInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Int16Op struct {
	selOpBase
}

func (p *selEQInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64Int16Op) Init() {
	p.input.Init()
}

type selEQInt64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selEQInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Int32Op struct {
	selOpBase
}

func (p *selEQInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64Int32Op) Init() {
	p.input.Init()
}

type selEQInt64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selEQInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Int64Op struct {
	selOpBase
}

func (p *selEQInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64Int64Op) Init() {
	p.input.Init()
}

type selEQInt64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selEQInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Float64Op struct {
	selOpBase
}

func (p *selEQInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64Float64Op) Init() {
	p.input.Init()
}

type selEQInt64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selEQInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selEQInt64DecimalOp struct {
	selOpBase
}

func (p *selEQInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQInt64DecimalOp) Init() {
	p.input.Init()
}

type selEQFloat64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selEQFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Int16Op struct {
	selOpBase
}

func (p *selEQFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64Int16Op) Init() {
	p.input.Init()
}

type selEQFloat64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selEQFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Int32Op struct {
	selOpBase
}

func (p *selEQFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64Int32Op) Init() {
	p.input.Init()
}

type selEQFloat64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selEQFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Int64Op struct {
	selOpBase
}

func (p *selEQFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64Int64Op) Init() {
	p.input.Init()
}

type selEQFloat64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selEQFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Float64Op struct {
	selOpBase
}

func (p *selEQFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64Float64Op) Init() {
	p.input.Init()
}

type selEQFloat64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selEQFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selEQFloat64DecimalOp struct {
	selOpBase
}

func (p *selEQFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQFloat64DecimalOp) Init() {
	p.input.Init()
}

type selEQTimestampTimestampConstOp struct {
	selConstOpBase
	constArg time.Time
}

func (p *selEQTimestampTimestampConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Timestamp()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQTimestampTimestampConstOp) Init() {
	p.input.Init()
}

type selEQTimestampTimestampOp struct {
	selOpBase
}

func (p *selEQTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQTimestampTimestampOp) Init() {
	p.input.Init()
}

type selEQIntervalIntervalConstOp struct {
	selConstOpBase
	constArg duration.Duration
}

func (p *selEQIntervalIntervalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Interval()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQIntervalIntervalConstOp) Init() {
	p.input.Init()
}

type selEQIntervalIntervalOp struct {
	selOpBase
}

func (p *selEQIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQIntervalIntervalOp) Init() {
	p.input.Init()
}

type selEQDatumDatumConstOp struct {
	selConstOpBase
	constArg interface{}
}

func (p *selEQDatumDatumConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Datum()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDatumDatumConstOp) Init() {
	p.input.Init()
}

type selEQDatumDatumOp struct {
	selOpBase
}

func (p *selEQDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult == 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult == 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selEQDatumDatumOp) Init() {
	p.input.Init()
}

type selNEBoolBoolConstOp struct {
	selConstOpBase
	constArg bool
}

func (p *selNEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEBoolBoolConstOp) Init() {
	p.input.Init()
}

type selNEBoolBoolOp struct {
	selOpBase
}

func (p *selNEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEBoolBoolOp) Init() {
	p.input.Init()
}

type selNEBytesBytesConstOp struct {
	selConstOpBase
	constArg []byte
}

func (p *selNEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEBytesBytesConstOp) Init() {
	p.input.Init()
}

type selNEBytesBytesOp struct {
	selOpBase
}

func (p *selNEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEBytesBytesOp) Init() {
	p.input.Init()
}

type selNEDecimalInt16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selNEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalInt16Op struct {
	selOpBase
}

func (p *selNEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalInt16Op) Init() {
	p.input.Init()
}

type selNEDecimalInt32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selNEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalInt32Op struct {
	selOpBase
}

func (p *selNEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalInt32Op) Init() {
	p.input.Init()
}

type selNEDecimalInt64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selNEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalInt64Op struct {
	selOpBase
}

func (p *selNEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalInt64Op) Init() {
	p.input.Init()
}

type selNEDecimalFloat64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selNEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalFloat64Op struct {
	selOpBase
}

func (p *selNEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalFloat64Op) Init() {
	p.input.Init()
}

type selNEDecimalDecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selNEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selNEDecimalDecimalOp struct {
	selOpBase
}

func (p *selNEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDecimalDecimalOp) Init() {
	p.input.Init()
}

type selNEInt16Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selNEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Int16Op struct {
	selOpBase
}

func (p *selNEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16Int16Op) Init() {
	p.input.Init()
}

type selNEInt16Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selNEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Int32Op struct {
	selOpBase
}

func (p *selNEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16Int32Op) Init() {
	p.input.Init()
}

type selNEInt16Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selNEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Int64Op struct {
	selOpBase
}

func (p *selNEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16Int64Op) Init() {
	p.input.Init()
}

type selNEInt16Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selNEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Float64Op struct {
	selOpBase
}

func (p *selNEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16Float64Op) Init() {
	p.input.Init()
}

type selNEInt16DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selNEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selNEInt16DecimalOp struct {
	selOpBase
}

func (p *selNEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt16DecimalOp) Init() {
	p.input.Init()
}

type selNEInt32Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selNEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Int16Op struct {
	selOpBase
}

func (p *selNEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32Int16Op) Init() {
	p.input.Init()
}

type selNEInt32Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selNEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Int32Op struct {
	selOpBase
}

func (p *selNEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32Int32Op) Init() {
	p.input.Init()
}

type selNEInt32Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selNEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Int64Op struct {
	selOpBase
}

func (p *selNEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32Int64Op) Init() {
	p.input.Init()
}

type selNEInt32Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selNEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Float64Op struct {
	selOpBase
}

func (p *selNEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32Float64Op) Init() {
	p.input.Init()
}

type selNEInt32DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selNEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selNEInt32DecimalOp struct {
	selOpBase
}

func (p *selNEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt32DecimalOp) Init() {
	p.input.Init()
}

type selNEInt64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selNEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Int16Op struct {
	selOpBase
}

func (p *selNEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64Int16Op) Init() {
	p.input.Init()
}

type selNEInt64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selNEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Int32Op struct {
	selOpBase
}

func (p *selNEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64Int32Op) Init() {
	p.input.Init()
}

type selNEInt64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selNEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Int64Op struct {
	selOpBase
}

func (p *selNEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64Int64Op) Init() {
	p.input.Init()
}

type selNEInt64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selNEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Float64Op struct {
	selOpBase
}

func (p *selNEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64Float64Op) Init() {
	p.input.Init()
}

type selNEInt64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selNEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selNEInt64DecimalOp struct {
	selOpBase
}

func (p *selNEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEInt64DecimalOp) Init() {
	p.input.Init()
}

type selNEFloat64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selNEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Int16Op struct {
	selOpBase
}

func (p *selNEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64Int16Op) Init() {
	p.input.Init()
}

type selNEFloat64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selNEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Int32Op struct {
	selOpBase
}

func (p *selNEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64Int32Op) Init() {
	p.input.Init()
}

type selNEFloat64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selNEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Int64Op struct {
	selOpBase
}

func (p *selNEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64Int64Op) Init() {
	p.input.Init()
}

type selNEFloat64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selNEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Float64Op struct {
	selOpBase
}

func (p *selNEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64Float64Op) Init() {
	p.input.Init()
}

type selNEFloat64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selNEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selNEFloat64DecimalOp struct {
	selOpBase
}

func (p *selNEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEFloat64DecimalOp) Init() {
	p.input.Init()
}

type selNETimestampTimestampConstOp struct {
	selConstOpBase
	constArg time.Time
}

func (p *selNETimestampTimestampConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Timestamp()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNETimestampTimestampConstOp) Init() {
	p.input.Init()
}

type selNETimestampTimestampOp struct {
	selOpBase
}

func (p *selNETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNETimestampTimestampOp) Init() {
	p.input.Init()
}

type selNEIntervalIntervalConstOp struct {
	selConstOpBase
	constArg duration.Duration
}

func (p *selNEIntervalIntervalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Interval()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEIntervalIntervalConstOp) Init() {
	p.input.Init()
}

type selNEIntervalIntervalOp struct {
	selOpBase
}

func (p *selNEIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEIntervalIntervalOp) Init() {
	p.input.Init()
}

type selNEDatumDatumConstOp struct {
	selConstOpBase
	constArg interface{}
}

func (p *selNEDatumDatumConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Datum()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDatumDatumConstOp) Init() {
	p.input.Init()
}

type selNEDatumDatumOp struct {
	selOpBase
}

func (p *selNEDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult != 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult != 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selNEDatumDatumOp) Init() {
	p.input.Init()
}

type selLTBoolBoolConstOp struct {
	selConstOpBase
	constArg bool
}

func (p *selLTBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTBoolBoolConstOp) Init() {
	p.input.Init()
}

type selLTBoolBoolOp struct {
	selOpBase
}

func (p *selLTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTBoolBoolOp) Init() {
	p.input.Init()
}

type selLTBytesBytesConstOp struct {
	selConstOpBase
	constArg []byte
}

func (p *selLTBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTBytesBytesConstOp) Init() {
	p.input.Init()
}

type selLTBytesBytesOp struct {
	selOpBase
}

func (p *selLTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTBytesBytesOp) Init() {
	p.input.Init()
}

type selLTDecimalInt16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLTDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalInt16Op struct {
	selOpBase
}

func (p *selLTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalInt16Op) Init() {
	p.input.Init()
}

type selLTDecimalInt32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLTDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalInt32Op struct {
	selOpBase
}

func (p *selLTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalInt32Op) Init() {
	p.input.Init()
}

type selLTDecimalInt64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLTDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalInt64Op struct {
	selOpBase
}

func (p *selLTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalInt64Op) Init() {
	p.input.Init()
}

type selLTDecimalFloat64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLTDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalFloat64Op struct {
	selOpBase
}

func (p *selLTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalFloat64Op) Init() {
	p.input.Init()
}

type selLTDecimalDecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLTDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selLTDecimalDecimalOp struct {
	selOpBase
}

func (p *selLTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDecimalDecimalOp) Init() {
	p.input.Init()
}

type selLTInt16Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLTInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Int16Op struct {
	selOpBase
}

func (p *selLTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16Int16Op) Init() {
	p.input.Init()
}

type selLTInt16Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLTInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Int32Op struct {
	selOpBase
}

func (p *selLTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16Int32Op) Init() {
	p.input.Init()
}

type selLTInt16Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLTInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Int64Op struct {
	selOpBase
}

func (p *selLTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16Int64Op) Init() {
	p.input.Init()
}

type selLTInt16Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLTInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Float64Op struct {
	selOpBase
}

func (p *selLTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16Float64Op) Init() {
	p.input.Init()
}

type selLTInt16DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLTInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selLTInt16DecimalOp struct {
	selOpBase
}

func (p *selLTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt16DecimalOp) Init() {
	p.input.Init()
}

type selLTInt32Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLTInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Int16Op struct {
	selOpBase
}

func (p *selLTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32Int16Op) Init() {
	p.input.Init()
}

type selLTInt32Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLTInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Int32Op struct {
	selOpBase
}

func (p *selLTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32Int32Op) Init() {
	p.input.Init()
}

type selLTInt32Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLTInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Int64Op struct {
	selOpBase
}

func (p *selLTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32Int64Op) Init() {
	p.input.Init()
}

type selLTInt32Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLTInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Float64Op struct {
	selOpBase
}

func (p *selLTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32Float64Op) Init() {
	p.input.Init()
}

type selLTInt32DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLTInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selLTInt32DecimalOp struct {
	selOpBase
}

func (p *selLTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt32DecimalOp) Init() {
	p.input.Init()
}

type selLTInt64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLTInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Int16Op struct {
	selOpBase
}

func (p *selLTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64Int16Op) Init() {
	p.input.Init()
}

type selLTInt64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLTInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Int32Op struct {
	selOpBase
}

func (p *selLTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64Int32Op) Init() {
	p.input.Init()
}

type selLTInt64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLTInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Int64Op struct {
	selOpBase
}

func (p *selLTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64Int64Op) Init() {
	p.input.Init()
}

type selLTInt64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLTInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Float64Op struct {
	selOpBase
}

func (p *selLTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64Float64Op) Init() {
	p.input.Init()
}

type selLTInt64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLTInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selLTInt64DecimalOp struct {
	selOpBase
}

func (p *selLTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTInt64DecimalOp) Init() {
	p.input.Init()
}

type selLTFloat64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLTFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Int16Op struct {
	selOpBase
}

func (p *selLTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64Int16Op) Init() {
	p.input.Init()
}

type selLTFloat64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLTFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Int32Op struct {
	selOpBase
}

func (p *selLTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64Int32Op) Init() {
	p.input.Init()
}

type selLTFloat64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLTFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Int64Op struct {
	selOpBase
}

func (p *selLTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64Int64Op) Init() {
	p.input.Init()
}

type selLTFloat64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLTFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Float64Op struct {
	selOpBase
}

func (p *selLTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64Float64Op) Init() {
	p.input.Init()
}

type selLTFloat64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLTFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selLTFloat64DecimalOp struct {
	selOpBase
}

func (p *selLTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTFloat64DecimalOp) Init() {
	p.input.Init()
}

type selLTTimestampTimestampConstOp struct {
	selConstOpBase
	constArg time.Time
}

func (p *selLTTimestampTimestampConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Timestamp()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTTimestampTimestampConstOp) Init() {
	p.input.Init()
}

type selLTTimestampTimestampOp struct {
	selOpBase
}

func (p *selLTTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTTimestampTimestampOp) Init() {
	p.input.Init()
}

type selLTIntervalIntervalConstOp struct {
	selConstOpBase
	constArg duration.Duration
}

func (p *selLTIntervalIntervalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Interval()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTIntervalIntervalConstOp) Init() {
	p.input.Init()
}

type selLTIntervalIntervalOp struct {
	selOpBase
}

func (p *selLTIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTIntervalIntervalOp) Init() {
	p.input.Init()
}

type selLTDatumDatumConstOp struct {
	selConstOpBase
	constArg interface{}
}

func (p *selLTDatumDatumConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Datum()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDatumDatumConstOp) Init() {
	p.input.Init()
}

type selLTDatumDatumOp struct {
	selOpBase
}

func (p *selLTDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult < 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult < 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLTDatumDatumOp) Init() {
	p.input.Init()
}

type selLEBoolBoolConstOp struct {
	selConstOpBase
	constArg bool
}

func (p *selLEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEBoolBoolConstOp) Init() {
	p.input.Init()
}

type selLEBoolBoolOp struct {
	selOpBase
}

func (p *selLEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEBoolBoolOp) Init() {
	p.input.Init()
}

type selLEBytesBytesConstOp struct {
	selConstOpBase
	constArg []byte
}

func (p *selLEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEBytesBytesConstOp) Init() {
	p.input.Init()
}

type selLEBytesBytesOp struct {
	selOpBase
}

func (p *selLEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEBytesBytesOp) Init() {
	p.input.Init()
}

type selLEDecimalInt16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalInt16Op struct {
	selOpBase
}

func (p *selLEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalInt16Op) Init() {
	p.input.Init()
}

type selLEDecimalInt32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalInt32Op struct {
	selOpBase
}

func (p *selLEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalInt32Op) Init() {
	p.input.Init()
}

type selLEDecimalInt64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalInt64Op struct {
	selOpBase
}

func (p *selLEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalInt64Op) Init() {
	p.input.Init()
}

type selLEDecimalFloat64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalFloat64Op struct {
	selOpBase
}

func (p *selLEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalFloat64Op) Init() {
	p.input.Init()
}

type selLEDecimalDecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selLEDecimalDecimalOp struct {
	selOpBase
}

func (p *selLEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDecimalDecimalOp) Init() {
	p.input.Init()
}

type selLEInt16Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Int16Op struct {
	selOpBase
}

func (p *selLEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16Int16Op) Init() {
	p.input.Init()
}

type selLEInt16Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Int32Op struct {
	selOpBase
}

func (p *selLEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16Int32Op) Init() {
	p.input.Init()
}

type selLEInt16Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Int64Op struct {
	selOpBase
}

func (p *selLEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16Int64Op) Init() {
	p.input.Init()
}

type selLEInt16Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Float64Op struct {
	selOpBase
}

func (p *selLEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16Float64Op) Init() {
	p.input.Init()
}

type selLEInt16DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selLEInt16DecimalOp struct {
	selOpBase
}

func (p *selLEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt16DecimalOp) Init() {
	p.input.Init()
}

type selLEInt32Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Int16Op struct {
	selOpBase
}

func (p *selLEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32Int16Op) Init() {
	p.input.Init()
}

type selLEInt32Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Int32Op struct {
	selOpBase
}

func (p *selLEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32Int32Op) Init() {
	p.input.Init()
}

type selLEInt32Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Int64Op struct {
	selOpBase
}

func (p *selLEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32Int64Op) Init() {
	p.input.Init()
}

type selLEInt32Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Float64Op struct {
	selOpBase
}

func (p *selLEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32Float64Op) Init() {
	p.input.Init()
}

type selLEInt32DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selLEInt32DecimalOp struct {
	selOpBase
}

func (p *selLEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt32DecimalOp) Init() {
	p.input.Init()
}

type selLEInt64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Int16Op struct {
	selOpBase
}

func (p *selLEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64Int16Op) Init() {
	p.input.Init()
}

type selLEInt64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Int32Op struct {
	selOpBase
}

func (p *selLEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64Int32Op) Init() {
	p.input.Init()
}

type selLEInt64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Int64Op struct {
	selOpBase
}

func (p *selLEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64Int64Op) Init() {
	p.input.Init()
}

type selLEInt64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Float64Op struct {
	selOpBase
}

func (p *selLEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64Float64Op) Init() {
	p.input.Init()
}

type selLEInt64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selLEInt64DecimalOp struct {
	selOpBase
}

func (p *selLEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEInt64DecimalOp) Init() {
	p.input.Init()
}

type selLEFloat64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selLEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Int16Op struct {
	selOpBase
}

func (p *selLEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64Int16Op) Init() {
	p.input.Init()
}

type selLEFloat64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selLEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Int32Op struct {
	selOpBase
}

func (p *selLEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64Int32Op) Init() {
	p.input.Init()
}

type selLEFloat64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selLEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Int64Op struct {
	selOpBase
}

func (p *selLEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64Int64Op) Init() {
	p.input.Init()
}

type selLEFloat64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selLEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Float64Op struct {
	selOpBase
}

func (p *selLEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64Float64Op) Init() {
	p.input.Init()
}

type selLEFloat64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selLEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selLEFloat64DecimalOp struct {
	selOpBase
}

func (p *selLEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEFloat64DecimalOp) Init() {
	p.input.Init()
}

type selLETimestampTimestampConstOp struct {
	selConstOpBase
	constArg time.Time
}

func (p *selLETimestampTimestampConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Timestamp()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLETimestampTimestampConstOp) Init() {
	p.input.Init()
}

type selLETimestampTimestampOp struct {
	selOpBase
}

func (p *selLETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLETimestampTimestampOp) Init() {
	p.input.Init()
}

type selLEIntervalIntervalConstOp struct {
	selConstOpBase
	constArg duration.Duration
}

func (p *selLEIntervalIntervalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Interval()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEIntervalIntervalConstOp) Init() {
	p.input.Init()
}

type selLEIntervalIntervalOp struct {
	selOpBase
}

func (p *selLEIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEIntervalIntervalOp) Init() {
	p.input.Init()
}

type selLEDatumDatumConstOp struct {
	selConstOpBase
	constArg interface{}
}

func (p *selLEDatumDatumConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Datum()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDatumDatumConstOp) Init() {
	p.input.Init()
}

type selLEDatumDatumOp struct {
	selOpBase
}

func (p *selLEDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult <= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult <= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selLEDatumDatumOp) Init() {
	p.input.Init()
}

type selGTBoolBoolConstOp struct {
	selConstOpBase
	constArg bool
}

func (p *selGTBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTBoolBoolConstOp) Init() {
	p.input.Init()
}

type selGTBoolBoolOp struct {
	selOpBase
}

func (p *selGTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTBoolBoolOp) Init() {
	p.input.Init()
}

type selGTBytesBytesConstOp struct {
	selConstOpBase
	constArg []byte
}

func (p *selGTBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTBytesBytesConstOp) Init() {
	p.input.Init()
}

type selGTBytesBytesOp struct {
	selOpBase
}

func (p *selGTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTBytesBytesOp) Init() {
	p.input.Init()
}

type selGTDecimalInt16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGTDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalInt16Op struct {
	selOpBase
}

func (p *selGTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalInt16Op) Init() {
	p.input.Init()
}

type selGTDecimalInt32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGTDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalInt32Op struct {
	selOpBase
}

func (p *selGTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalInt32Op) Init() {
	p.input.Init()
}

type selGTDecimalInt64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGTDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalInt64Op struct {
	selOpBase
}

func (p *selGTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalInt64Op) Init() {
	p.input.Init()
}

type selGTDecimalFloat64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGTDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalFloat64Op struct {
	selOpBase
}

func (p *selGTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalFloat64Op) Init() {
	p.input.Init()
}

type selGTDecimalDecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGTDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selGTDecimalDecimalOp struct {
	selOpBase
}

func (p *selGTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDecimalDecimalOp) Init() {
	p.input.Init()
}

type selGTInt16Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGTInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Int16Op struct {
	selOpBase
}

func (p *selGTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16Int16Op) Init() {
	p.input.Init()
}

type selGTInt16Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGTInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Int32Op struct {
	selOpBase
}

func (p *selGTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16Int32Op) Init() {
	p.input.Init()
}

type selGTInt16Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGTInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Int64Op struct {
	selOpBase
}

func (p *selGTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16Int64Op) Init() {
	p.input.Init()
}

type selGTInt16Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGTInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Float64Op struct {
	selOpBase
}

func (p *selGTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16Float64Op) Init() {
	p.input.Init()
}

type selGTInt16DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGTInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selGTInt16DecimalOp struct {
	selOpBase
}

func (p *selGTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt16DecimalOp) Init() {
	p.input.Init()
}

type selGTInt32Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGTInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Int16Op struct {
	selOpBase
}

func (p *selGTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32Int16Op) Init() {
	p.input.Init()
}

type selGTInt32Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGTInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Int32Op struct {
	selOpBase
}

func (p *selGTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32Int32Op) Init() {
	p.input.Init()
}

type selGTInt32Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGTInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Int64Op struct {
	selOpBase
}

func (p *selGTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32Int64Op) Init() {
	p.input.Init()
}

type selGTInt32Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGTInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Float64Op struct {
	selOpBase
}

func (p *selGTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32Float64Op) Init() {
	p.input.Init()
}

type selGTInt32DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGTInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selGTInt32DecimalOp struct {
	selOpBase
}

func (p *selGTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt32DecimalOp) Init() {
	p.input.Init()
}

type selGTInt64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGTInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Int16Op struct {
	selOpBase
}

func (p *selGTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64Int16Op) Init() {
	p.input.Init()
}

type selGTInt64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGTInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Int32Op struct {
	selOpBase
}

func (p *selGTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64Int32Op) Init() {
	p.input.Init()
}

type selGTInt64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGTInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Int64Op struct {
	selOpBase
}

func (p *selGTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64Int64Op) Init() {
	p.input.Init()
}

type selGTInt64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGTInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Float64Op struct {
	selOpBase
}

func (p *selGTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64Float64Op) Init() {
	p.input.Init()
}

type selGTInt64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGTInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selGTInt64DecimalOp struct {
	selOpBase
}

func (p *selGTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTInt64DecimalOp) Init() {
	p.input.Init()
}

type selGTFloat64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGTFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Int16Op struct {
	selOpBase
}

func (p *selGTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64Int16Op) Init() {
	p.input.Init()
}

type selGTFloat64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGTFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Int32Op struct {
	selOpBase
}

func (p *selGTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64Int32Op) Init() {
	p.input.Init()
}

type selGTFloat64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGTFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Int64Op struct {
	selOpBase
}

func (p *selGTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64Int64Op) Init() {
	p.input.Init()
}

type selGTFloat64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGTFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Float64Op struct {
	selOpBase
}

func (p *selGTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64Float64Op) Init() {
	p.input.Init()
}

type selGTFloat64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGTFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selGTFloat64DecimalOp struct {
	selOpBase
}

func (p *selGTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTFloat64DecimalOp) Init() {
	p.input.Init()
}

type selGTTimestampTimestampConstOp struct {
	selConstOpBase
	constArg time.Time
}

func (p *selGTTimestampTimestampConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Timestamp()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTTimestampTimestampConstOp) Init() {
	p.input.Init()
}

type selGTTimestampTimestampOp struct {
	selOpBase
}

func (p *selGTTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTTimestampTimestampOp) Init() {
	p.input.Init()
}

type selGTIntervalIntervalConstOp struct {
	selConstOpBase
	constArg duration.Duration
}

func (p *selGTIntervalIntervalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Interval()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTIntervalIntervalConstOp) Init() {
	p.input.Init()
}

type selGTIntervalIntervalOp struct {
	selOpBase
}

func (p *selGTIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTIntervalIntervalOp) Init() {
	p.input.Init()
}

type selGTDatumDatumConstOp struct {
	selConstOpBase
	constArg interface{}
}

func (p *selGTDatumDatumConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Datum()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDatumDatumConstOp) Init() {
	p.input.Init()
}

type selGTDatumDatumOp struct {
	selOpBase
}

func (p *selGTDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult > 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult > 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGTDatumDatumOp) Init() {
	p.input.Init()
}

type selGEBoolBoolConstOp struct {
	selConstOpBase
	constArg bool
}

func (p *selGEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEBoolBoolConstOp) Init() {
	p.input.Init()
}

type selGEBoolBoolOp struct {
	selOpBase
}

func (p *selGEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEBoolBoolOp) Init() {
	p.input.Init()
}

type selGEBytesBytesConstOp struct {
	selConstOpBase
	constArg []byte
}

func (p *selGEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEBytesBytesConstOp) Init() {
	p.input.Init()
}

type selGEBytesBytesOp struct {
	selOpBase
}

func (p *selGEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEBytesBytesOp) Init() {
	p.input.Init()
}

type selGEDecimalInt16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalInt16Op struct {
	selOpBase
}

func (p *selGEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalInt16Op) Init() {
	p.input.Init()
}

type selGEDecimalInt32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalInt32Op struct {
	selOpBase
}

func (p *selGEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalInt32Op) Init() {
	p.input.Init()
}

type selGEDecimalInt64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalInt64Op struct {
	selOpBase
}

func (p *selGEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalInt64Op) Init() {
	p.input.Init()
}

type selGEDecimalFloat64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalFloat64Op struct {
	selOpBase
}

func (p *selGEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalFloat64Op) Init() {
	p.input.Init()
}

type selGEDecimalDecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selGEDecimalDecimalOp struct {
	selOpBase
}

func (p *selGEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDecimalDecimalOp) Init() {
	p.input.Init()
}

type selGEInt16Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Int16Op struct {
	selOpBase
}

func (p *selGEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16Int16Op) Init() {
	p.input.Init()
}

type selGEInt16Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Int32Op struct {
	selOpBase
}

func (p *selGEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16Int32Op) Init() {
	p.input.Init()
}

type selGEInt16Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Int64Op struct {
	selOpBase
}

func (p *selGEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16Int64Op) Init() {
	p.input.Init()
}

type selGEInt16Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Float64Op struct {
	selOpBase
}

func (p *selGEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16Float64Op) Init() {
	p.input.Init()
}

type selGEInt16DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selGEInt16DecimalOp struct {
	selOpBase
}

func (p *selGEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt16DecimalOp) Init() {
	p.input.Init()
}

type selGEInt32Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Int16Op struct {
	selOpBase
}

func (p *selGEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32Int16Op) Init() {
	p.input.Init()
}

type selGEInt32Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Int32Op struct {
	selOpBase
}

func (p *selGEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32Int32Op) Init() {
	p.input.Init()
}

type selGEInt32Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Int64Op struct {
	selOpBase
}

func (p *selGEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32Int64Op) Init() {
	p.input.Init()
}

type selGEInt32Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Float64Op struct {
	selOpBase
}

func (p *selGEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32Float64Op) Init() {
	p.input.Init()
}

type selGEInt32DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selGEInt32DecimalOp struct {
	selOpBase
}

func (p *selGEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt32DecimalOp) Init() {
	p.input.Init()
}

type selGEInt64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Int16Op struct {
	selOpBase
}

func (p *selGEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64Int16Op) Init() {
	p.input.Init()
}

type selGEInt64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Int32Op struct {
	selOpBase
}

func (p *selGEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64Int32Op) Init() {
	p.input.Init()
}

type selGEInt64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Int64Op struct {
	selOpBase
}

func (p *selGEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64Int64Op) Init() {
	p.input.Init()
}

type selGEInt64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Float64Op struct {
	selOpBase
}

func (p *selGEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64Float64Op) Init() {
	p.input.Init()
}

type selGEInt64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selGEInt64DecimalOp struct {
	selOpBase
}

func (p *selGEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEInt64DecimalOp) Init() {
	p.input.Init()
}

type selGEFloat64Int16ConstOp struct {
	selConstOpBase
	constArg int16
}

func (p *selGEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Int16Op struct {
	selOpBase
}

func (p *selGEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64Int16Op) Init() {
	p.input.Init()
}

type selGEFloat64Int32ConstOp struct {
	selConstOpBase
	constArg int32
}

func (p *selGEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Int32Op struct {
	selOpBase
}

func (p *selGEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64Int32Op) Init() {
	p.input.Init()
}

type selGEFloat64Int64ConstOp struct {
	selConstOpBase
	constArg int64
}

func (p *selGEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Int64Op struct {
	selOpBase
}

func (p *selGEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64Int64Op) Init() {
	p.input.Init()
}

type selGEFloat64Float64ConstOp struct {
	selConstOpBase
	constArg float64
}

func (p *selGEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Float64Op struct {
	selOpBase
}

func (p *selGEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64Float64Op) Init() {
	p.input.Init()
}

type selGEFloat64DecimalConstOp struct {
	selConstOpBase
	constArg apd.Decimal
}

func (p *selGEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selGEFloat64DecimalOp struct {
	selOpBase
}

func (p *selGEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEFloat64DecimalOp) Init() {
	p.input.Init()
}

type selGETimestampTimestampConstOp struct {
	selConstOpBase
	constArg time.Time
}

func (p *selGETimestampTimestampConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Timestamp()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGETimestampTimestampConstOp) Init() {
	p.input.Init()
}

type selGETimestampTimestampOp struct {
	selOpBase
}

func (p *selGETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGETimestampTimestampOp) Init() {
	p.input.Init()
}

type selGEIntervalIntervalConstOp struct {
	selConstOpBase
	constArg duration.Duration
}

func (p *selGEIntervalIntervalConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Interval()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEIntervalIntervalConstOp) Init() {
	p.input.Init()
}

type selGEIntervalIntervalOp struct {
	selOpBase
}

func (p *selGEIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1) //gcassert:inline
				_ = col2.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEIntervalIntervalOp) Init() {
	p.input.Init()
}

type selGEDatumDatumConstOp struct {
	selConstOpBase
	constArg interface{}
}

func (p *selGEDatumDatumConstOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Datum()
		var idx int
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = arg.(*coldataext.Datum).CompareDatum(col, p.constArg)

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDatumDatumConstOp) Init() {
	p.input.Init()
}

type selGEDatumDatumOp struct {
	selOpBase
}

func (p *selGEDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the selection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	var isNull bool
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		n := batch.Length()

		var idx int
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult >= 0
					}

					isNull = nulls.NullAt(i)
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						cmp = cmpResult >= 0
					}

					isNull = false
					if cmp && !isNull {
						sel[idx] = i
						idx++
					}
				}
			}
		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p *selGEDatumDatumOp) Init() {
	p.input.Init()
}

// GetSelectionConstOperator returns the appropriate constant selection operator
// for the given left and right column types and comparison.
func GetSelectionConstOperator(
	leftType *types.T,
	constType *types.T,
	cmpOp tree.ComparisonOperator,
	input colexecbase.Operator,
	colIdx int,
	constArg tree.Datum,
	binFn *tree.BinOp,
) (colexecbase.Operator, error) {
	c, err := GetDatumToPhysicalFn(constType)(constArg)
	if err != nil {
		return nil, err
	}
	selConstOpBase := selConstOpBase{
		OneInputNode:   NewOneInputNode(input),
		colIdx:         colIdx,
		overloadHelper: overloadHelper{binFn: binFn},
	}
	switch cmpOp {
	case tree.EQ:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BoolFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQBoolBoolConstOp{selConstOpBase: selConstOpBase, constArg: c.(bool)}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BytesFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQBytesBytesConstOp{selConstOpBase: selConstOpBase, constArg: c.([]byte)}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selEQDecimalInt16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selEQDecimalInt32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selEQDecimalInt64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQDecimalFloat64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQDecimalDecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selEQInt16Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selEQInt16Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selEQInt16Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQInt16Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQInt16DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selEQInt32Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selEQInt32Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selEQInt32Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQInt32Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQInt32DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selEQInt64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selEQInt64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selEQInt64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQInt64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQInt64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selEQFloat64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selEQFloat64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selEQFloat64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQFloat64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQFloat64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.TimestampTZFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQTimestampTimestampConstOp{selConstOpBase: selConstOpBase, constArg: c.(time.Time)}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntervalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQIntervalIntervalConstOp{selConstOpBase: selConstOpBase, constArg: c.(duration.Duration)}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selEQDatumDatumConstOp{selConstOpBase: selConstOpBase, constArg: c.(interface{})}, nil
					}
				}
			}
		}
	case tree.NE:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BoolFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEBoolBoolConstOp{selConstOpBase: selConstOpBase, constArg: c.(bool)}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BytesFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEBytesBytesConstOp{selConstOpBase: selConstOpBase, constArg: c.([]byte)}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selNEDecimalInt16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selNEDecimalInt32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selNEDecimalInt64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEDecimalFloat64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEDecimalDecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selNEInt16Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selNEInt16Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selNEInt16Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEInt16Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEInt16DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selNEInt32Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selNEInt32Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selNEInt32Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEInt32Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEInt32DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selNEInt64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selNEInt64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selNEInt64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEInt64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEInt64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selNEFloat64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selNEFloat64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selNEFloat64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEFloat64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEFloat64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.TimestampTZFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNETimestampTimestampConstOp{selConstOpBase: selConstOpBase, constArg: c.(time.Time)}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntervalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEIntervalIntervalConstOp{selConstOpBase: selConstOpBase, constArg: c.(duration.Duration)}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selNEDatumDatumConstOp{selConstOpBase: selConstOpBase, constArg: c.(interface{})}, nil
					}
				}
			}
		}
	case tree.LT:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BoolFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTBoolBoolConstOp{selConstOpBase: selConstOpBase, constArg: c.(bool)}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BytesFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTBytesBytesConstOp{selConstOpBase: selConstOpBase, constArg: c.([]byte)}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLTDecimalInt16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLTDecimalInt32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLTDecimalInt64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTDecimalFloat64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTDecimalDecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLTInt16Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLTInt16Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLTInt16Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTInt16Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTInt16DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLTInt32Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLTInt32Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLTInt32Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTInt32Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTInt32DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLTInt64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLTInt64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLTInt64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTInt64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTInt64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLTFloat64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLTFloat64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLTFloat64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTFloat64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTFloat64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.TimestampTZFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTTimestampTimestampConstOp{selConstOpBase: selConstOpBase, constArg: c.(time.Time)}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntervalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTIntervalIntervalConstOp{selConstOpBase: selConstOpBase, constArg: c.(duration.Duration)}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLTDatumDatumConstOp{selConstOpBase: selConstOpBase, constArg: c.(interface{})}, nil
					}
				}
			}
		}
	case tree.LE:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BoolFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEBoolBoolConstOp{selConstOpBase: selConstOpBase, constArg: c.(bool)}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BytesFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEBytesBytesConstOp{selConstOpBase: selConstOpBase, constArg: c.([]byte)}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLEDecimalInt16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLEDecimalInt32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLEDecimalInt64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEDecimalFloat64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEDecimalDecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLEInt16Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLEInt16Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLEInt16Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEInt16Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEInt16DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLEInt32Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLEInt32Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLEInt32Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEInt32Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEInt32DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLEInt64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLEInt64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLEInt64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEInt64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEInt64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selLEFloat64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selLEFloat64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selLEFloat64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEFloat64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEFloat64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.TimestampTZFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLETimestampTimestampConstOp{selConstOpBase: selConstOpBase, constArg: c.(time.Time)}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntervalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEIntervalIntervalConstOp{selConstOpBase: selConstOpBase, constArg: c.(duration.Duration)}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selLEDatumDatumConstOp{selConstOpBase: selConstOpBase, constArg: c.(interface{})}, nil
					}
				}
			}
		}
	case tree.GT:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BoolFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTBoolBoolConstOp{selConstOpBase: selConstOpBase, constArg: c.(bool)}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BytesFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTBytesBytesConstOp{selConstOpBase: selConstOpBase, constArg: c.([]byte)}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGTDecimalInt16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGTDecimalInt32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGTDecimalInt64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTDecimalFloat64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTDecimalDecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGTInt16Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGTInt16Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGTInt16Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTInt16Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTInt16DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGTInt32Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGTInt32Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGTInt32Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTInt32Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTInt32DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGTInt64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGTInt64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGTInt64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTInt64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTInt64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGTFloat64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGTFloat64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGTFloat64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTFloat64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTFloat64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.TimestampTZFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTTimestampTimestampConstOp{selConstOpBase: selConstOpBase, constArg: c.(time.Time)}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntervalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTIntervalIntervalConstOp{selConstOpBase: selConstOpBase, constArg: c.(duration.Duration)}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGTDatumDatumConstOp{selConstOpBase: selConstOpBase, constArg: c.(interface{})}, nil
					}
				}
			}
		}
	case tree.GE:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BoolFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEBoolBoolConstOp{selConstOpBase: selConstOpBase, constArg: c.(bool)}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.BytesFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEBytesBytesConstOp{selConstOpBase: selConstOpBase, constArg: c.([]byte)}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGEDecimalInt16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGEDecimalInt32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGEDecimalInt64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEDecimalFloat64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEDecimalDecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGEInt16Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGEInt16Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGEInt16Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEInt16Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEInt16DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGEInt32Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGEInt32Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGEInt32Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEInt32Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEInt32DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGEInt64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGEInt64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGEInt64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEInt64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEInt64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntFamily:
					switch constType.Width() {
					case 16:
						return &selGEFloat64Int16ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int16)}, nil
					case 32:
						return &selGEFloat64Int32ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int32)}, nil
					case -1:
					default:
						return &selGEFloat64Int64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(int64)}, nil
					}
				case types.FloatFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEFloat64Float64ConstOp{selConstOpBase: selConstOpBase, constArg: c.(float64)}, nil
					}
				case types.DecimalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEFloat64DecimalConstOp{selConstOpBase: selConstOpBase, constArg: c.(apd.Decimal)}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.TimestampTZFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGETimestampTimestampConstOp{selConstOpBase: selConstOpBase, constArg: c.(time.Time)}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case types.IntervalFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEIntervalIntervalConstOp{selConstOpBase: selConstOpBase, constArg: c.(duration.Duration)}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(constType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch constType.Width() {
					case -1:
					default:
						return &selGEDatumDatumConstOp{selConstOpBase: selConstOpBase, constArg: c.(interface{})}, nil
					}
				}
			}
		}
	}
	return nil, errors.Errorf("couldn't find overload for %s %s %s", leftType.Name(), cmpOp, constType.Name())
}

// GetSelectionOperator returns the appropriate two column selection operator
// for the given left and right column types and comparison.
func GetSelectionOperator(
	leftType *types.T,
	rightType *types.T,
	cmpOp tree.ComparisonOperator,
	input colexecbase.Operator,
	col1Idx int,
	col2Idx int,
	binFn *tree.BinOp,
) (colexecbase.Operator, error) {
	selOpBase := selOpBase{
		OneInputNode:   NewOneInputNode(input),
		col1Idx:        col1Idx,
		col2Idx:        col2Idx,
		overloadHelper: overloadHelper{binFn: binFn},
	}
	switch cmpOp {
	case tree.EQ:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BoolFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQBoolBoolOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BytesFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQBytesBytesOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selEQDecimalInt16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selEQDecimalInt32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selEQDecimalInt64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQDecimalFloat64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQDecimalDecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selEQInt16Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selEQInt16Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selEQInt16Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQInt16Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQInt16DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selEQInt32Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selEQInt32Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selEQInt32Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQInt32Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQInt32DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selEQInt64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selEQInt64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selEQInt64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQInt64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQInt64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selEQFloat64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selEQFloat64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selEQFloat64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQFloat64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQFloat64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.TimestampTZFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQTimestampTimestampOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntervalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQIntervalIntervalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selEQDatumDatumOp{selOpBase: selOpBase}, nil
					}
				}
			}
		}
	case tree.NE:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BoolFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEBoolBoolOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BytesFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEBytesBytesOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selNEDecimalInt16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selNEDecimalInt32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selNEDecimalInt64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEDecimalFloat64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEDecimalDecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selNEInt16Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selNEInt16Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selNEInt16Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEInt16Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEInt16DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selNEInt32Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selNEInt32Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selNEInt32Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEInt32Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEInt32DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selNEInt64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selNEInt64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selNEInt64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEInt64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEInt64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selNEFloat64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selNEFloat64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selNEFloat64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEFloat64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEFloat64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.TimestampTZFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNETimestampTimestampOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntervalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEIntervalIntervalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selNEDatumDatumOp{selOpBase: selOpBase}, nil
					}
				}
			}
		}
	case tree.LT:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BoolFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTBoolBoolOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BytesFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTBytesBytesOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLTDecimalInt16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLTDecimalInt32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLTDecimalInt64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTDecimalFloat64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTDecimalDecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLTInt16Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLTInt16Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLTInt16Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTInt16Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTInt16DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLTInt32Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLTInt32Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLTInt32Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTInt32Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTInt32DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLTInt64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLTInt64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLTInt64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTInt64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTInt64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLTFloat64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLTFloat64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLTFloat64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTFloat64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTFloat64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.TimestampTZFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTTimestampTimestampOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntervalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTIntervalIntervalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLTDatumDatumOp{selOpBase: selOpBase}, nil
					}
				}
			}
		}
	case tree.LE:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BoolFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEBoolBoolOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BytesFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEBytesBytesOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLEDecimalInt16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLEDecimalInt32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLEDecimalInt64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEDecimalFloat64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEDecimalDecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLEInt16Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLEInt16Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLEInt16Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEInt16Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEInt16DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLEInt32Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLEInt32Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLEInt32Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEInt32Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEInt32DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLEInt64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLEInt64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLEInt64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEInt64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEInt64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selLEFloat64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selLEFloat64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selLEFloat64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEFloat64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEFloat64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.TimestampTZFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLETimestampTimestampOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntervalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEIntervalIntervalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selLEDatumDatumOp{selOpBase: selOpBase}, nil
					}
				}
			}
		}
	case tree.GT:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BoolFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTBoolBoolOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BytesFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTBytesBytesOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGTDecimalInt16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGTDecimalInt32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGTDecimalInt64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTDecimalFloat64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTDecimalDecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGTInt16Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGTInt16Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGTInt16Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTInt16Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTInt16DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGTInt32Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGTInt32Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGTInt32Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTInt32Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTInt32DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGTInt64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGTInt64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGTInt64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTInt64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTInt64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGTFloat64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGTFloat64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGTFloat64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTFloat64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTFloat64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.TimestampTZFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTTimestampTimestampOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntervalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTIntervalIntervalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGTDatumDatumOp{selOpBase: selOpBase}, nil
					}
				}
			}
		}
	case tree.GE:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
		case types.BoolFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BoolFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEBoolBoolOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.BytesFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.BytesFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEBytesBytesOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.DecimalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGEDecimalInt16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGEDecimalInt32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGEDecimalInt64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEDecimalFloat64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEDecimalDecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntFamily:
			switch leftType.Width() {
			case 16:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGEInt16Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGEInt16Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGEInt16Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEInt16Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEInt16DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case 32:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGEInt32Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGEInt32Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGEInt32Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEInt32Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEInt32DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGEInt64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGEInt64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGEInt64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEInt64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEInt64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.FloatFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntFamily:
					switch rightType.Width() {
					case 16:
						return &selGEFloat64Int16Op{selOpBase: selOpBase}, nil
					case 32:
						return &selGEFloat64Int32Op{selOpBase: selOpBase}, nil
					case -1:
					default:
						return &selGEFloat64Int64Op{selOpBase: selOpBase}, nil
					}
				case types.FloatFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEFloat64Float64Op{selOpBase: selOpBase}, nil
					}
				case types.DecimalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEFloat64DecimalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.TimestampTZFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.TimestampTZFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGETimestampTimestampOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case types.IntervalFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case types.IntervalFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEIntervalIntervalOp{selOpBase: selOpBase}, nil
					}
				}
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch leftType.Width() {
			case -1:
			default:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
				case typeconv.DatumVecCanonicalTypeFamily:
					switch rightType.Width() {
					case -1:
					default:
						return &selGEDatumDatumOp{selOpBase: selOpBase}, nil
					}
				}
			}
		}
	}
	return nil, errors.Errorf("couldn't find overload for %s %s %s", leftType.Name(), cmpOp, rightType.Name())
}
