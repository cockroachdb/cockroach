// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"math"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/pkg/errors"
)

type projEQBoolBoolOp struct {
	projOpBase
}

func (p projEQBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQBoolBoolOp) Init() {
	p.input.Init()
}

type projNEBoolBoolOp struct {
	projOpBase
}

func (p projNEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEBoolBoolOp) Init() {
	p.input.Init()
}

type projLTBoolBoolOp struct {
	projOpBase
}

func (p projLTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTBoolBoolOp) Init() {
	p.input.Init()
}

type projLEBoolBoolOp struct {
	projOpBase
}

func (p projLEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEBoolBoolOp) Init() {
	p.input.Init()
}

type projGTBoolBoolOp struct {
	projOpBase
}

func (p projGTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTBoolBoolOp) Init() {
	p.input.Init()
}

type projGEBoolBoolOp struct {
	projOpBase
}

func (p projGEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEBoolBoolOp) Init() {
	p.input.Init()
}

type projEQBytesBytesOp struct {
	projOpBase
}

func (p projEQBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQBytesBytesOp) Init() {
	p.input.Init()
}

type projNEBytesBytesOp struct {
	projOpBase
}

func (p projNEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEBytesBytesOp) Init() {
	p.input.Init()
}

type projLTBytesBytesOp struct {
	projOpBase
}

func (p projLTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTBytesBytesOp) Init() {
	p.input.Init()
}

type projLEBytesBytesOp struct {
	projOpBase
}

func (p projLEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEBytesBytesOp) Init() {
	p.input.Init()
}

type projGTBytesBytesOp struct {
	projOpBase
}

func (p projGTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTBytesBytesOp) Init() {
	p.input.Init()
}

type projGEBytesBytesOp struct {
	projOpBase
}

func (p projGEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1.Slice(0, int(n))
			colLen := col1.Len()
			_ = projCol[colLen-1]
			_ = col2.Get(colLen - 1)
			for i := 0; i < col1.Len(); i++ {
				arg1 := col1.Get(int(i))
				arg2 := col2.Get(int(i))

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEBytesBytesOp) Init() {
	p.input.Init()
}

type projPlusDecimalDecimalOp struct {
	projOpBase
}

func (p projPlusDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2); err != nil {
					execerror.NonVectorizedPanic(err)
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2); err != nil {
					execerror.NonVectorizedPanic(err)
				}
			}
		}
	}

	return batch
}

func (p projPlusDecimalDecimalOp) Init() {
	p.input.Init()
}

type projMinusDecimalDecimalOp struct {
	projOpBase
}

func (p projMinusDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2); err != nil {
					execerror.NonVectorizedPanic(err)
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2); err != nil {
					execerror.NonVectorizedPanic(err)
				}
			}
		}
	}

	return batch
}

func (p projMinusDecimalDecimalOp) Init() {
	p.input.Init()
}

type projMultDecimalDecimalOp struct {
	projOpBase
}

func (p projMultDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2); err != nil {
					execerror.NonVectorizedPanic(err)
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2); err != nil {
					execerror.NonVectorizedPanic(err)
				}
			}
		}
	}

	return batch
}

func (p projMultDecimalDecimalOp) Init() {
	p.input.Init()
}

type projDivDecimalDecimalOp struct {
	projOpBase
}

func (p projDivDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						cond, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
						if cond.DivisionByZero() {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						cond, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
						if cond.DivisionByZero() {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					cond, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
					if cond.DivisionByZero() {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					cond, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
					if cond.DivisionByZero() {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivDecimalDecimalOp) Init() {
	p.input.Init()
}

type projEQDecimalDecimalOp struct {
	projOpBase
}

func (p projEQDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQDecimalDecimalOp) Init() {
	p.input.Init()
}

type projNEDecimalDecimalOp struct {
	projOpBase
}

func (p projNEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projLTDecimalDecimalOp struct {
	projOpBase
}

func (p projLTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTDecimalDecimalOp) Init() {
	p.input.Init()
}

type projLEDecimalDecimalOp struct {
	projOpBase
}

func (p projLEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projGTDecimalDecimalOp struct {
	projOpBase
}

func (p projGTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTDecimalDecimalOp) Init() {
	p.input.Init()
}

type projGEDecimalDecimalOp struct {
	projOpBase
}

func (p projGEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projPlusDecimalInt16Op struct {
	projOpBase
}

func (p projPlusDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projPlusDecimalInt16Op) Init() {
	p.input.Init()
}

type projMinusDecimalInt16Op struct {
	projOpBase
}

func (p projMinusDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMinusDecimalInt16Op) Init() {
	p.input.Init()
}

type projMultDecimalInt16Op struct {
	projOpBase
}

func (p projMultDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMultDecimalInt16Op) Init() {
	p.input.Init()
}

type projDivDecimalInt16Op struct {
	projOpBase
}

func (p projDivDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivDecimalInt16Op) Init() {
	p.input.Init()
}

type projEQDecimalInt16Op struct {
	projOpBase
}

func (p projEQDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQDecimalInt16Op) Init() {
	p.input.Init()
}

type projNEDecimalInt16Op struct {
	projOpBase
}

func (p projNEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEDecimalInt16Op) Init() {
	p.input.Init()
}

type projLTDecimalInt16Op struct {
	projOpBase
}

func (p projLTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTDecimalInt16Op) Init() {
	p.input.Init()
}

type projLEDecimalInt16Op struct {
	projOpBase
}

func (p projLEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEDecimalInt16Op) Init() {
	p.input.Init()
}

type projGTDecimalInt16Op struct {
	projOpBase
}

func (p projGTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTDecimalInt16Op) Init() {
	p.input.Init()
}

type projGEDecimalInt16Op struct {
	projOpBase
}

func (p projGEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEDecimalInt16Op) Init() {
	p.input.Init()
}

type projPlusDecimalInt32Op struct {
	projOpBase
}

func (p projPlusDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projPlusDecimalInt32Op) Init() {
	p.input.Init()
}

type projMinusDecimalInt32Op struct {
	projOpBase
}

func (p projMinusDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMinusDecimalInt32Op) Init() {
	p.input.Init()
}

type projMultDecimalInt32Op struct {
	projOpBase
}

func (p projMultDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMultDecimalInt32Op) Init() {
	p.input.Init()
}

type projDivDecimalInt32Op struct {
	projOpBase
}

func (p projDivDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivDecimalInt32Op) Init() {
	p.input.Init()
}

type projEQDecimalInt32Op struct {
	projOpBase
}

func (p projEQDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQDecimalInt32Op) Init() {
	p.input.Init()
}

type projNEDecimalInt32Op struct {
	projOpBase
}

func (p projNEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEDecimalInt32Op) Init() {
	p.input.Init()
}

type projLTDecimalInt32Op struct {
	projOpBase
}

func (p projLTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTDecimalInt32Op) Init() {
	p.input.Init()
}

type projLEDecimalInt32Op struct {
	projOpBase
}

func (p projLEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEDecimalInt32Op) Init() {
	p.input.Init()
}

type projGTDecimalInt32Op struct {
	projOpBase
}

func (p projGTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTDecimalInt32Op) Init() {
	p.input.Init()
}

type projGEDecimalInt32Op struct {
	projOpBase
}

func (p projGEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEDecimalInt32Op) Init() {
	p.input.Init()
}

type projPlusDecimalInt64Op struct {
	projOpBase
}

func (p projPlusDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projPlusDecimalInt64Op) Init() {
	p.input.Init()
}

type projMinusDecimalInt64Op struct {
	projOpBase
}

func (p projMinusDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMinusDecimalInt64Op) Init() {
	p.input.Init()
}

type projMultDecimalInt64Op struct {
	projOpBase
}

func (p projMultDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMultDecimalInt64Op) Init() {
	p.input.Init()
}

type projDivDecimalInt64Op struct {
	projOpBase
}

func (p projDivDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{

						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{

					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivDecimalInt64Op) Init() {
	p.input.Init()
}

type projEQDecimalInt64Op struct {
	projOpBase
}

func (p projEQDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQDecimalInt64Op) Init() {
	p.input.Init()
}

type projNEDecimalInt64Op struct {
	projOpBase
}

func (p projNEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEDecimalInt64Op) Init() {
	p.input.Init()
}

type projLTDecimalInt64Op struct {
	projOpBase
}

func (p projLTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTDecimalInt64Op) Init() {
	p.input.Init()
}

type projLEDecimalInt64Op struct {
	projOpBase
}

func (p projLEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEDecimalInt64Op) Init() {
	p.input.Init()
}

type projGTDecimalInt64Op struct {
	projOpBase
}

func (p projGTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTDecimalInt64Op) Init() {
	p.input.Init()
}

type projGEDecimalInt64Op struct {
	projOpBase
}

func (p projGEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg2), 0)
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEDecimalInt64Op) Init() {
	p.input.Init()
}

type projEQDecimalFloat64Op struct {
	projOpBase
}

func (p projEQDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQDecimalFloat64Op) Init() {
	p.input.Init()
}

type projNEDecimalFloat64Op struct {
	projOpBase
}

func (p projNEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projLTDecimalFloat64Op struct {
	projOpBase
}

func (p projLTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTDecimalFloat64Op) Init() {
	p.input.Init()
}

type projLEDecimalFloat64Op struct {
	projOpBase
}

func (p projLEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projGTDecimalFloat64Op struct {
	projOpBase
}

func (p projGTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTDecimalFloat64Op) Init() {
	p.input.Init()
}

type projGEDecimalFloat64Op struct {
	projOpBase
}

func (p projGEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projPlusInt16DecimalOp struct {
	projOpBase
}

func (p projPlusInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projPlusInt16DecimalOp) Init() {
	p.input.Init()
}

type projMinusInt16DecimalOp struct {
	projOpBase
}

func (p projMinusInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMinusInt16DecimalOp) Init() {
	p.input.Init()
}

type projMultInt16DecimalOp struct {
	projOpBase
}

func (p projMultInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMultInt16DecimalOp) Init() {
	p.input.Init()
}

type projDivInt16DecimalOp struct {
	projOpBase
}

func (p projDivInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if cond.DivisionByZero() {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if cond.DivisionByZero() {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if cond.DivisionByZero() {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if cond.DivisionByZero() {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt16DecimalOp) Init() {
	p.input.Init()
}

type projEQInt16DecimalOp struct {
	projOpBase
}

func (p projEQInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt16DecimalOp) Init() {
	p.input.Init()
}

type projNEInt16DecimalOp struct {
	projOpBase
}

func (p projNEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt16DecimalOp) Init() {
	p.input.Init()
}

type projLTInt16DecimalOp struct {
	projOpBase
}

func (p projLTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt16DecimalOp) Init() {
	p.input.Init()
}

type projLEInt16DecimalOp struct {
	projOpBase
}

func (p projLEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt16DecimalOp) Init() {
	p.input.Init()
}

type projGTInt16DecimalOp struct {
	projOpBase
}

func (p projGTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt16DecimalOp) Init() {
	p.input.Init()
}

type projGEInt16DecimalOp struct {
	projOpBase
}

func (p projGEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt16DecimalOp) Init() {
	p.input.Init()
}

type projPlusInt16Int16Op struct {
	projOpBase
}

func (p projPlusInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 + arg2
						if (result < arg1) != (arg2 < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 + arg2
						if (result < arg1) != (arg2 < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 + arg2
					if (result < arg1) != (arg2 < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 + arg2
					if (result < arg1) != (arg2 < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt16Int16Op) Init() {
	p.input.Init()
}

type projMinusInt16Int16Op struct {
	projOpBase
}

func (p projMinusInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 - arg2
						if (result < arg1) != (arg2 > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 - arg2
						if (result < arg1) != (arg2 > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 - arg2
					if (result < arg1) != (arg2 > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 - arg2
					if (result < arg1) != (arg2 > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt16Int16Op) Init() {
	p.input.Init()
}

type projMultInt16Int16Op struct {
	projOpBase
}

func (p projMultInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 * arg2
						if arg1 > math.MaxInt8 || arg1 < math.MinInt8 || arg2 > math.MaxInt8 || arg2 < math.MinInt8 {
							if arg1 != 0 && arg2 != 0 {
								sameSign := (arg1 < 0) == (arg2 < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/arg2 != arg1 {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 * arg2
						if arg1 > math.MaxInt8 || arg1 < math.MinInt8 || arg2 > math.MaxInt8 || arg2 < math.MinInt8 {
							if arg1 != 0 && arg2 != 0 {
								sameSign := (arg1 < 0) == (arg2 < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/arg2 != arg1 {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 * arg2
					if arg1 > math.MaxInt8 || arg1 < math.MinInt8 || arg2 > math.MaxInt8 || arg2 < math.MinInt8 {
						if arg1 != 0 && arg2 != 0 {
							sameSign := (arg1 < 0) == (arg2 < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/arg2 != arg1 {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 * arg2
					if arg1 > math.MaxInt8 || arg1 < math.MinInt8 || arg2 > math.MaxInt8 || arg2 < math.MinInt8 {
						if arg1 != 0 && arg2 != 0 {
							sameSign := (arg1 < 0) == (arg2 < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/arg2 != arg1 {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt16Int16Op) Init() {
	p.input.Init()
}

type projDivInt16Int16Op struct {
	projOpBase
}

func (p projDivInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(arg1), 0)
						rightTmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(arg1), 0)
						rightTmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(arg1), 0)
					rightTmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(arg1), 0)
					rightTmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt16Int16Op) Init() {
	p.input.Init()
}

type projEQInt16Int16Op struct {
	projOpBase
}

func (p projEQInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt16Int16Op) Init() {
	p.input.Init()
}

type projNEInt16Int16Op struct {
	projOpBase
}

func (p projNEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt16Int16Op) Init() {
	p.input.Init()
}

type projLTInt16Int16Op struct {
	projOpBase
}

func (p projLTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt16Int16Op) Init() {
	p.input.Init()
}

type projLEInt16Int16Op struct {
	projOpBase
}

func (p projLEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt16Int16Op) Init() {
	p.input.Init()
}

type projGTInt16Int16Op struct {
	projOpBase
}

func (p projGTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt16Int16Op) Init() {
	p.input.Init()
}

type projGEInt16Int16Op struct {
	projOpBase
}

func (p projGEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt16Int16Op) Init() {
	p.input.Init()
}

type projPlusInt16Int32Op struct {
	projOpBase
}

func (p projPlusInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt16Int32Op) Init() {
	p.input.Init()
}

type projMinusInt16Int32Op struct {
	projOpBase
}

func (p projMinusInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt16Int32Op) Init() {
	p.input.Init()
}

type projMultInt16Int32Op struct {
	projOpBase
}

func (p projMultInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt16Int32Op) Init() {
	p.input.Init()
}

type projDivInt16Int32Op struct {
	projOpBase
}

func (p projDivInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt16Int32Op) Init() {
	p.input.Init()
}

type projEQInt16Int32Op struct {
	projOpBase
}

func (p projEQInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt16Int32Op) Init() {
	p.input.Init()
}

type projNEInt16Int32Op struct {
	projOpBase
}

func (p projNEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt16Int32Op) Init() {
	p.input.Init()
}

type projLTInt16Int32Op struct {
	projOpBase
}

func (p projLTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt16Int32Op) Init() {
	p.input.Init()
}

type projLEInt16Int32Op struct {
	projOpBase
}

func (p projLEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt16Int32Op) Init() {
	p.input.Init()
}

type projGTInt16Int32Op struct {
	projOpBase
}

func (p projGTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt16Int32Op) Init() {
	p.input.Init()
}

type projGEInt16Int32Op struct {
	projOpBase
}

func (p projGEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt16Int32Op) Init() {
	p.input.Init()
}

type projPlusInt16Int64Op struct {
	projOpBase
}

func (p projPlusInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt16Int64Op) Init() {
	p.input.Init()
}

type projMinusInt16Int64Op struct {
	projOpBase
}

func (p projMinusInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt16Int64Op) Init() {
	p.input.Init()
}

type projMultInt16Int64Op struct {
	projOpBase
}

func (p projMultInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt16Int64Op) Init() {
	p.input.Init()
}

type projDivInt16Int64Op struct {
	projOpBase
}

func (p projDivInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt16Int64Op) Init() {
	p.input.Init()
}

type projEQInt16Int64Op struct {
	projOpBase
}

func (p projEQInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt16Int64Op) Init() {
	p.input.Init()
}

type projNEInt16Int64Op struct {
	projOpBase
}

func (p projNEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt16Int64Op) Init() {
	p.input.Init()
}

type projLTInt16Int64Op struct {
	projOpBase
}

func (p projLTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt16Int64Op) Init() {
	p.input.Init()
}

type projLEInt16Int64Op struct {
	projOpBase
}

func (p projLEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt16Int64Op) Init() {
	p.input.Init()
}

type projGTInt16Int64Op struct {
	projOpBase
}

func (p projGTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt16Int64Op) Init() {
	p.input.Init()
}

type projGEInt16Int64Op struct {
	projOpBase
}

func (p projGEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt16Int64Op) Init() {
	p.input.Init()
}

type projEQInt16Float64Op struct {
	projOpBase
}

func (p projEQInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt16Float64Op) Init() {
	p.input.Init()
}

type projNEInt16Float64Op struct {
	projOpBase
}

func (p projNEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt16Float64Op) Init() {
	p.input.Init()
}

type projLTInt16Float64Op struct {
	projOpBase
}

func (p projLTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt16Float64Op) Init() {
	p.input.Init()
}

type projLEInt16Float64Op struct {
	projOpBase
}

func (p projLEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt16Float64Op) Init() {
	p.input.Init()
}

type projGTInt16Float64Op struct {
	projOpBase
}

func (p projGTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt16Float64Op) Init() {
	p.input.Init()
}

type projGEInt16Float64Op struct {
	projOpBase
}

func (p projGEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt16Float64Op) Init() {
	p.input.Init()
}

type projPlusInt32DecimalOp struct {
	projOpBase
}

func (p projPlusInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projPlusInt32DecimalOp) Init() {
	p.input.Init()
}

type projMinusInt32DecimalOp struct {
	projOpBase
}

func (p projMinusInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMinusInt32DecimalOp) Init() {
	p.input.Init()
}

type projMultInt32DecimalOp struct {
	projOpBase
}

func (p projMultInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMultInt32DecimalOp) Init() {
	p.input.Init()
}

type projDivInt32DecimalOp struct {
	projOpBase
}

func (p projDivInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if cond.DivisionByZero() {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if cond.DivisionByZero() {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if cond.DivisionByZero() {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if cond.DivisionByZero() {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt32DecimalOp) Init() {
	p.input.Init()
}

type projEQInt32DecimalOp struct {
	projOpBase
}

func (p projEQInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt32DecimalOp) Init() {
	p.input.Init()
}

type projNEInt32DecimalOp struct {
	projOpBase
}

func (p projNEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt32DecimalOp) Init() {
	p.input.Init()
}

type projLTInt32DecimalOp struct {
	projOpBase
}

func (p projLTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt32DecimalOp) Init() {
	p.input.Init()
}

type projLEInt32DecimalOp struct {
	projOpBase
}

func (p projLEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt32DecimalOp) Init() {
	p.input.Init()
}

type projGTInt32DecimalOp struct {
	projOpBase
}

func (p projGTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt32DecimalOp) Init() {
	p.input.Init()
}

type projGEInt32DecimalOp struct {
	projOpBase
}

func (p projGEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt32DecimalOp) Init() {
	p.input.Init()
}

type projPlusInt32Int16Op struct {
	projOpBase
}

func (p projPlusInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt32Int16Op) Init() {
	p.input.Init()
}

type projMinusInt32Int16Op struct {
	projOpBase
}

func (p projMinusInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt32Int16Op) Init() {
	p.input.Init()
}

type projMultInt32Int16Op struct {
	projOpBase
}

func (p projMultInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt32Int16Op) Init() {
	p.input.Init()
}

type projDivInt32Int16Op struct {
	projOpBase
}

func (p projDivInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt32Int16Op) Init() {
	p.input.Init()
}

type projEQInt32Int16Op struct {
	projOpBase
}

func (p projEQInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt32Int16Op) Init() {
	p.input.Init()
}

type projNEInt32Int16Op struct {
	projOpBase
}

func (p projNEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt32Int16Op) Init() {
	p.input.Init()
}

type projLTInt32Int16Op struct {
	projOpBase
}

func (p projLTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt32Int16Op) Init() {
	p.input.Init()
}

type projLEInt32Int16Op struct {
	projOpBase
}

func (p projLEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt32Int16Op) Init() {
	p.input.Init()
}

type projGTInt32Int16Op struct {
	projOpBase
}

func (p projGTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt32Int16Op) Init() {
	p.input.Init()
}

type projGEInt32Int16Op struct {
	projOpBase
}

func (p projGEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt32Int16Op) Init() {
	p.input.Init()
}

type projPlusInt32Int32Op struct {
	projOpBase
}

func (p projPlusInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 + arg2
						if (result < arg1) != (arg2 < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 + arg2
						if (result < arg1) != (arg2 < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 + arg2
					if (result < arg1) != (arg2 < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 + arg2
					if (result < arg1) != (arg2 < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt32Int32Op) Init() {
	p.input.Init()
}

type projMinusInt32Int32Op struct {
	projOpBase
}

func (p projMinusInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 - arg2
						if (result < arg1) != (arg2 > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 - arg2
						if (result < arg1) != (arg2 > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 - arg2
					if (result < arg1) != (arg2 > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 - arg2
					if (result < arg1) != (arg2 > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt32Int32Op) Init() {
	p.input.Init()
}

type projMultInt32Int32Op struct {
	projOpBase
}

func (p projMultInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 * arg2
						if arg1 > math.MaxInt16 || arg1 < math.MinInt16 || arg2 > math.MaxInt16 || arg2 < math.MinInt16 {
							if arg1 != 0 && arg2 != 0 {
								sameSign := (arg1 < 0) == (arg2 < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/arg2 != arg1 {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := arg1 * arg2
						if arg1 > math.MaxInt16 || arg1 < math.MinInt16 || arg2 > math.MaxInt16 || arg2 < math.MinInt16 {
							if arg1 != 0 && arg2 != 0 {
								sameSign := (arg1 < 0) == (arg2 < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/arg2 != arg1 {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 * arg2
					if arg1 > math.MaxInt16 || arg1 < math.MinInt16 || arg2 > math.MaxInt16 || arg2 < math.MinInt16 {
						if arg1 != 0 && arg2 != 0 {
							sameSign := (arg1 < 0) == (arg2 < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/arg2 != arg1 {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := arg1 * arg2
					if arg1 > math.MaxInt16 || arg1 < math.MinInt16 || arg2 > math.MaxInt16 || arg2 < math.MinInt16 {
						if arg1 != 0 && arg2 != 0 {
							sameSign := (arg1 < 0) == (arg2 < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/arg2 != arg1 {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt32Int32Op) Init() {
	p.input.Init()
}

type projDivInt32Int32Op struct {
	projOpBase
}

func (p projDivInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(arg1), 0)
						rightTmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if arg2 == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(arg1), 0)
						rightTmpDec.SetFinite(int64(arg2), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(arg1), 0)
					rightTmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if arg2 == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(arg1), 0)
					rightTmpDec.SetFinite(int64(arg2), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt32Int32Op) Init() {
	p.input.Init()
}

type projEQInt32Int32Op struct {
	projOpBase
}

func (p projEQInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt32Int32Op) Init() {
	p.input.Init()
}

type projNEInt32Int32Op struct {
	projOpBase
}

func (p projNEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt32Int32Op) Init() {
	p.input.Init()
}

type projLTInt32Int32Op struct {
	projOpBase
}

func (p projLTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt32Int32Op) Init() {
	p.input.Init()
}

type projLEInt32Int32Op struct {
	projOpBase
}

func (p projLEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt32Int32Op) Init() {
	p.input.Init()
}

type projGTInt32Int32Op struct {
	projOpBase
}

func (p projGTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt32Int32Op) Init() {
	p.input.Init()
}

type projGEInt32Int32Op struct {
	projOpBase
}

func (p projGEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt32Int32Op) Init() {
	p.input.Init()
}

type projPlusInt32Int64Op struct {
	projOpBase
}

func (p projPlusInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt32Int64Op) Init() {
	p.input.Init()
}

type projMinusInt32Int64Op struct {
	projOpBase
}

func (p projMinusInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt32Int64Op) Init() {
	p.input.Init()
}

type projMultInt32Int64Op struct {
	projOpBase
}

func (p projMultInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt32Int64Op) Init() {
	p.input.Init()
}

type projDivInt32Int64Op struct {
	projOpBase
}

func (p projDivInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt32Int64Op) Init() {
	p.input.Init()
}

type projEQInt32Int64Op struct {
	projOpBase
}

func (p projEQInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt32Int64Op) Init() {
	p.input.Init()
}

type projNEInt32Int64Op struct {
	projOpBase
}

func (p projNEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt32Int64Op) Init() {
	p.input.Init()
}

type projLTInt32Int64Op struct {
	projOpBase
}

func (p projLTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt32Int64Op) Init() {
	p.input.Init()
}

type projLEInt32Int64Op struct {
	projOpBase
}

func (p projLEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt32Int64Op) Init() {
	p.input.Init()
}

type projGTInt32Int64Op struct {
	projOpBase
}

func (p projGTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt32Int64Op) Init() {
	p.input.Init()
}

type projGEInt32Int64Op struct {
	projOpBase
}

func (p projGEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt32Int64Op) Init() {
	p.input.Init()
}

type projEQInt32Float64Op struct {
	projOpBase
}

func (p projEQInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt32Float64Op) Init() {
	p.input.Init()
}

type projNEInt32Float64Op struct {
	projOpBase
}

func (p projNEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt32Float64Op) Init() {
	p.input.Init()
}

type projLTInt32Float64Op struct {
	projOpBase
}

func (p projLTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt32Float64Op) Init() {
	p.input.Init()
}

type projLEInt32Float64Op struct {
	projOpBase
}

func (p projLEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt32Float64Op) Init() {
	p.input.Init()
}

type projGTInt32Float64Op struct {
	projOpBase
}

func (p projGTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt32Float64Op) Init() {
	p.input.Init()
}

type projGEInt32Float64Op struct {
	projOpBase
}

func (p projGEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt32Float64Op) Init() {
	p.input.Init()
}

type projPlusInt64DecimalOp struct {
	projOpBase
}

func (p projPlusInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projPlusInt64DecimalOp) Init() {
	p.input.Init()
}

type projMinusInt64DecimalOp struct {
	projOpBase
}

func (p projMinusInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMinusInt64DecimalOp) Init() {
	p.input.Init()
}

type projMultInt64DecimalOp struct {
	projOpBase
}

func (p projMultInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projMultInt64DecimalOp) Init() {
	p.input.Init()
}

type projDivInt64DecimalOp struct {
	projOpBase
}

func (p projDivInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if cond.DivisionByZero() {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)

						cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if cond.DivisionByZero() {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}

						if err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if cond.DivisionByZero() {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)

					cond, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if cond.DivisionByZero() {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}

					if err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt64DecimalOp) Init() {
	p.input.Init()
}

type projEQInt64DecimalOp struct {
	projOpBase
}

func (p projEQInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt64DecimalOp) Init() {
	p.input.Init()
}

type projNEInt64DecimalOp struct {
	projOpBase
}

func (p projNEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt64DecimalOp) Init() {
	p.input.Init()
}

type projLTInt64DecimalOp struct {
	projOpBase
}

func (p projLTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt64DecimalOp) Init() {
	p.input.Init()
}

type projLEInt64DecimalOp struct {
	projOpBase
}

func (p projLEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt64DecimalOp) Init() {
	p.input.Init()
}

type projGTInt64DecimalOp struct {
	projOpBase
}

func (p projGTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt64DecimalOp) Init() {
	p.input.Init()
}

type projGEInt64DecimalOp struct {
	projOpBase
}

func (p projGEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						tmpDec.SetFinite(int64(arg1), 0)
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt64DecimalOp) Init() {
	p.input.Init()
}

type projPlusInt64Int16Op struct {
	projOpBase
}

func (p projPlusInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt64Int16Op) Init() {
	p.input.Init()
}

type projMinusInt64Int16Op struct {
	projOpBase
}

func (p projMinusInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt64Int16Op) Init() {
	p.input.Init()
}

type projMultInt64Int16Op struct {
	projOpBase
}

func (p projMultInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt64Int16Op) Init() {
	p.input.Init()
}

type projDivInt64Int16Op struct {
	projOpBase
}

func (p projDivInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt64Int16Op) Init() {
	p.input.Init()
}

type projEQInt64Int16Op struct {
	projOpBase
}

func (p projEQInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt64Int16Op) Init() {
	p.input.Init()
}

type projNEInt64Int16Op struct {
	projOpBase
}

func (p projNEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt64Int16Op) Init() {
	p.input.Init()
}

type projLTInt64Int16Op struct {
	projOpBase
}

func (p projLTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt64Int16Op) Init() {
	p.input.Init()
}

type projLEInt64Int16Op struct {
	projOpBase
}

func (p projLEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt64Int16Op) Init() {
	p.input.Init()
}

type projGTInt64Int16Op struct {
	projOpBase
}

func (p projGTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt64Int16Op) Init() {
	p.input.Init()
}

type projGEInt64Int16Op struct {
	projOpBase
}

func (p projGEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt64Int16Op) Init() {
	p.input.Init()
}

type projPlusInt64Int32Op struct {
	projOpBase
}

func (p projPlusInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt64Int32Op) Init() {
	p.input.Init()
}

type projMinusInt64Int32Op struct {
	projOpBase
}

func (p projMinusInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt64Int32Op) Init() {
	p.input.Init()
}

type projMultInt64Int32Op struct {
	projOpBase
}

func (p projMultInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt64Int32Op) Init() {
	p.input.Init()
}

type projDivInt64Int32Op struct {
	projOpBase
}

func (p projDivInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt64Int32Op) Init() {
	p.input.Init()
}

type projEQInt64Int32Op struct {
	projOpBase
}

func (p projEQInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt64Int32Op) Init() {
	p.input.Init()
}

type projNEInt64Int32Op struct {
	projOpBase
}

func (p projNEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt64Int32Op) Init() {
	p.input.Init()
}

type projLTInt64Int32Op struct {
	projOpBase
}

func (p projLTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt64Int32Op) Init() {
	p.input.Init()
}

type projLEInt64Int32Op struct {
	projOpBase
}

func (p projLEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt64Int32Op) Init() {
	p.input.Init()
}

type projGTInt64Int32Op struct {
	projOpBase
}

func (p projGTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt64Int32Op) Init() {
	p.input.Init()
}

type projGEInt64Int32Op struct {
	projOpBase
}

func (p projGEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt64Int32Op) Init() {
	p.input.Init()
}

type projPlusInt64Int64Op struct {
	projOpBase
}

func (p projPlusInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projPlusInt64Int64Op) Init() {
	p.input.Init()
}

type projMinusInt64Int64Op struct {
	projOpBase
}

func (p projMinusInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMinusInt64Int64Op) Init() {
	p.input.Init()
}

type projMultInt64Int64Op struct {
	projOpBase
}

func (p projMultInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						result := int64(arg1) * int64(arg2)
						if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
							if int64(arg1) != 0 && int64(arg2) != 0 {
								sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
								if (result < 0) == sameSign {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								} else if result/int64(arg2) != int64(arg1) {
									execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					result := int64(arg1) * int64(arg2)
					if int64(arg1) > math.MaxInt32 || int64(arg1) < math.MinInt32 || int64(arg2) > math.MaxInt32 || int64(arg2) < math.MinInt32 {
						if int64(arg1) != 0 && int64(arg2) != 0 {
							sameSign := (int64(arg1) < 0) == (int64(arg2) < 0)
							if (result < 0) == sameSign {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							} else if result/int64(arg2) != int64(arg1) {
								execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	return batch
}

func (p projMultInt64Int64Op) Init() {
	p.input.Init()
}

type projDivInt64Int64Op struct {
	projOpBase
}

func (p projDivInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						if int64(arg2) == 0 {
							execerror.NonVectorizedPanic(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
						leftTmpDec.SetFinite(int64(int64(arg1)), 0)
						rightTmpDec.SetFinite(int64(int64(arg2)), 0)
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							execerror.NonVectorizedPanic(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					if int64(arg2) == 0 {
						execerror.NonVectorizedPanic(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &apd.Decimal{}, &apd.Decimal{}
					leftTmpDec.SetFinite(int64(int64(arg1)), 0)
					rightTmpDec.SetFinite(int64(int64(arg2)), 0)
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						execerror.NonVectorizedPanic(err)
					}
				}

			}
		}
	}

	return batch
}

func (p projDivInt64Int64Op) Init() {
	p.input.Init()
}

type projEQInt64Int64Op struct {
	projOpBase
}

func (p projEQInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt64Int64Op) Init() {
	p.input.Init()
}

type projNEInt64Int64Op struct {
	projOpBase
}

func (p projNEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt64Int64Op) Init() {
	p.input.Init()
}

type projLTInt64Int64Op struct {
	projOpBase
}

func (p projLTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt64Int64Op) Init() {
	p.input.Init()
}

type projLEInt64Int64Op struct {
	projOpBase
}

func (p projLEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt64Int64Op) Init() {
	p.input.Init()
}

type projGTInt64Int64Op struct {
	projOpBase
}

func (p projGTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt64Int64Op) Init() {
	p.input.Init()
}

type projGEInt64Int64Op struct {
	projOpBase
}

func (p projGEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt64Int64Op) Init() {
	p.input.Init()
}

type projEQInt64Float64Op struct {
	projOpBase
}

func (p projEQInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQInt64Float64Op) Init() {
	p.input.Init()
}

type projNEInt64Float64Op struct {
	projOpBase
}

func (p projNEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEInt64Float64Op) Init() {
	p.input.Init()
}

type projLTInt64Float64Op struct {
	projOpBase
}

func (p projLTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTInt64Float64Op) Init() {
	p.input.Init()
}

type projLEInt64Float64Op struct {
	projOpBase
}

func (p projLEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEInt64Float64Op) Init() {
	p.input.Init()
}

type projGTInt64Float64Op struct {
	projOpBase
}

func (p projGTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTInt64Float64Op) Init() {
	p.input.Init()
}

type projGEInt64Float64Op struct {
	projOpBase
}

func (p projGEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEInt64Float64Op) Init() {
	p.input.Init()
}

type projEQFloat64DecimalOp struct {
	projOpBase
}

func (p projEQFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQFloat64DecimalOp) Init() {
	p.input.Init()
}

type projNEFloat64DecimalOp struct {
	projOpBase
}

func (p projNEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projLTFloat64DecimalOp struct {
	projOpBase
}

func (p projLTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTFloat64DecimalOp) Init() {
	p.input.Init()
}

type projLEFloat64DecimalOp struct {
	projOpBase
}

func (p projLEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projGTFloat64DecimalOp struct {
	projOpBase
}

func (p projGTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTFloat64DecimalOp) Init() {
	p.input.Init()
}

type projGEFloat64DecimalOp struct {
	projOpBase
}

func (p projGEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						tmpDec := &apd.Decimal{}
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							execerror.NonVectorizedPanic(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projEQFloat64Int16Op struct {
	projOpBase
}

func (p projEQFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQFloat64Int16Op) Init() {
	p.input.Init()
}

type projNEFloat64Int16Op struct {
	projOpBase
}

func (p projNEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEFloat64Int16Op) Init() {
	p.input.Init()
}

type projLTFloat64Int16Op struct {
	projOpBase
}

func (p projLTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTFloat64Int16Op) Init() {
	p.input.Init()
}

type projLEFloat64Int16Op struct {
	projOpBase
}

func (p projLEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEFloat64Int16Op) Init() {
	p.input.Init()
}

type projGTFloat64Int16Op struct {
	projOpBase
}

func (p projGTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTFloat64Int16Op) Init() {
	p.input.Init()
}

type projGEFloat64Int16Op struct {
	projOpBase
}

func (p projGEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEFloat64Int16Op) Init() {
	p.input.Init()
}

type projEQFloat64Int32Op struct {
	projOpBase
}

func (p projEQFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQFloat64Int32Op) Init() {
	p.input.Init()
}

type projNEFloat64Int32Op struct {
	projOpBase
}

func (p projNEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEFloat64Int32Op) Init() {
	p.input.Init()
}

type projLTFloat64Int32Op struct {
	projOpBase
}

func (p projLTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTFloat64Int32Op) Init() {
	p.input.Init()
}

type projLEFloat64Int32Op struct {
	projOpBase
}

func (p projLEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEFloat64Int32Op) Init() {
	p.input.Init()
}

type projGTFloat64Int32Op struct {
	projOpBase
}

func (p projGTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTFloat64Int32Op) Init() {
	p.input.Init()
}

type projGEFloat64Int32Op struct {
	projOpBase
}

func (p projGEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEFloat64Int32Op) Init() {
	p.input.Init()
}

type projEQFloat64Int64Op struct {
	projOpBase
}

func (p projEQFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQFloat64Int64Op) Init() {
	p.input.Init()
}

type projNEFloat64Int64Op struct {
	projOpBase
}

func (p projNEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEFloat64Int64Op) Init() {
	p.input.Init()
}

type projLTFloat64Int64Op struct {
	projOpBase
}

func (p projLTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTFloat64Int64Op) Init() {
	p.input.Init()
}

type projLEFloat64Int64Op struct {
	projOpBase
}

func (p projLEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEFloat64Int64Op) Init() {
	p.input.Init()
}

type projGTFloat64Int64Op struct {
	projOpBase
}

func (p projGTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTFloat64Int64Op) Init() {
	p.input.Init()
}

type projGEFloat64Int64Op struct {
	projOpBase
}

func (p projGEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEFloat64Int64Op) Init() {
	p.input.Init()
}

type projPlusFloat64Float64Op struct {
	projOpBase
}

func (p projPlusFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					projCol[i] = float64(arg1) + float64(arg2)
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					projCol[i] = float64(arg1) + float64(arg2)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				projCol[i] = float64(arg1) + float64(arg2)
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				projCol[i] = float64(arg1) + float64(arg2)
			}
		}
	}

	return batch
}

func (p projPlusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMinusFloat64Float64Op struct {
	projOpBase
}

func (p projMinusFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					projCol[i] = float64(arg1) - float64(arg2)
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					projCol[i] = float64(arg1) - float64(arg2)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				projCol[i] = float64(arg1) - float64(arg2)
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				projCol[i] = float64(arg1) - float64(arg2)
			}
		}
	}

	return batch
}

func (p projMinusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMultFloat64Float64Op struct {
	projOpBase
}

func (p projMultFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					projCol[i] = float64(arg1) * float64(arg2)
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					projCol[i] = float64(arg1) * float64(arg2)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				projCol[i] = float64(arg1) * float64(arg2)
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				projCol[i] = float64(arg1) * float64(arg2)
			}
		}
	}

	return batch
}

func (p projMultFloat64Float64Op) Init() {
	p.input.Init()
}

type projDivFloat64Float64Op struct {
	projOpBase
}

func (p projDivFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					projCol[i] = float64(arg1) / float64(arg2)
				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]
					projCol[i] = float64(arg1) / float64(arg2)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				projCol[i] = float64(arg1) / float64(arg2)
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]
				projCol[i] = float64(arg1) / float64(arg2)
			}
		}
	}

	return batch
}

func (p projDivFloat64Float64Op) Init() {
	p.input.Init()
}

type projEQFloat64Float64Op struct {
	projOpBase
}

func (p projEQFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQFloat64Float64Op) Init() {
	p.input.Init()
}

type projNEFloat64Float64Op struct {
	projOpBase
}

func (p projNEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNEFloat64Float64Op) Init() {
	p.input.Init()
}

type projLTFloat64Float64Op struct {
	projOpBase
}

func (p projLTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTFloat64Float64Op) Init() {
	p.input.Init()
}

type projLEFloat64Float64Op struct {
	projOpBase
}

func (p projLEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLEFloat64Float64Op) Init() {
	p.input.Init()
}

type projGTFloat64Float64Op struct {
	projOpBase
}

func (p projGTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTFloat64Float64Op) Init() {
	p.input.Init()
}

type projGEFloat64Float64Op struct {
	projOpBase
}

func (p projGEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGEFloat64Float64Op) Init() {
	p.input.Init()
}

type projEQTimestampTimestampOp struct {
	projOpBase
}

func (p projEQTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	return batch
}

func (p projEQTimestampTimestampOp) Init() {
	p.input.Init()
}

type projNETimestampTimestampOp struct {
	projOpBase
}

func (p projNETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	return batch
}

func (p projNETimestampTimestampOp) Init() {
	p.input.Init()
}

type projLTTimestampTimestampOp struct {
	projOpBase
}

func (p projLTTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	return batch
}

func (p projLTTimestampTimestampOp) Init() {
	p.input.Init()
}

type projLETimestampTimestampOp struct {
	projOpBase
}

func (p projLETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	return batch
}

func (p projLETimestampTimestampOp) Init() {
	p.input.Init()
}

type projGTTimestampTimestampOp struct {
	projOpBase
}

func (p projGTTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	return batch
}

func (p projGTTimestampTimestampOp) Init() {
	p.input.Init()
}

type projGETimestampTimestampOp struct {
	projOpBase
}

func (p projGETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		p.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				if !col1Nulls.NullAt(uint16(i)) && !col2Nulls.NullAt(uint16(i)) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:int(n)]
			colLen := len(col1)
			_ = projCol[colLen-1]
			_ = col2[colLen-1]
			for i := range col1 {
				arg1 := col1[int(i)]
				arg2 := col2[int(i)]

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	return batch
}

func (p projGETimestampTimestampOp) Init() {
	p.input.Init()
}

// GetProjectionOperator returns the appropriate projection operator for the
// given left and right column types and operation.
func GetProjectionOperator(
	allocator *Allocator,
	leftColType *types.T,
	rightColType *types.T,
	op tree.Operator,
	input Operator,
	col1Idx int,
	col2Idx int,
	outputIdx int,
) (Operator, error) {
	projOpBase := projOpBase{
		OneInputNode: NewOneInputNode(input),
		allocator:    allocator,
		col1Idx:      col1Idx,
		col2Idx:      col2Idx,
		outputIdx:    outputIdx,
	}
	switch leftType := typeconv.FromColumnType(leftColType); leftType {
	case coltypes.Bool:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {
		case coltypes.Bool:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQBoolBoolOp{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEBoolBoolOp{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTBoolBoolOp{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEBoolBoolOp{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTBoolBoolOp{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEBoolBoolOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}
	case coltypes.Bytes:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {
		case coltypes.Bytes:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQBytesBytesOp{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEBytesBytesOp{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTBytesBytesOp{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEBytesBytesOp{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTBytesBytesOp{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEBytesBytesOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}
	case coltypes.Decimal:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {
		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusDecimalDecimalOp{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusDecimalDecimalOp{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultDecimalDecimalOp{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivDecimalDecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQDecimalDecimalOp{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEDecimalDecimalOp{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTDecimalDecimalOp{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEDecimalDecimalOp{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTDecimalDecimalOp{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEDecimalDecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusDecimalInt16Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusDecimalInt16Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultDecimalInt16Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivDecimalInt16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQDecimalInt16Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEDecimalInt16Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTDecimalInt16Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEDecimalInt16Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTDecimalInt16Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEDecimalInt16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusDecimalInt32Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusDecimalInt32Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultDecimalInt32Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivDecimalInt32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQDecimalInt32Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEDecimalInt32Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTDecimalInt32Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEDecimalInt32Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTDecimalInt32Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEDecimalInt32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusDecimalInt64Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusDecimalInt64Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultDecimalInt64Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivDecimalInt64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQDecimalInt64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEDecimalInt64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTDecimalInt64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEDecimalInt64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTDecimalInt64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEDecimalInt64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQDecimalFloat64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEDecimalFloat64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTDecimalFloat64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEDecimalFloat64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTDecimalFloat64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEDecimalFloat64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}
	case coltypes.Int16:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {
		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt16DecimalOp{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt16DecimalOp{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt16DecimalOp{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt16DecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt16DecimalOp{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt16DecimalOp{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt16DecimalOp{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt16DecimalOp{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt16DecimalOp{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt16DecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt16Int16Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt16Int16Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt16Int16Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt16Int16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt16Int16Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt16Int16Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt16Int16Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt16Int16Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt16Int16Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt16Int16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt16Int32Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt16Int32Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt16Int32Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt16Int32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt16Int32Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt16Int32Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt16Int32Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt16Int32Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt16Int32Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt16Int32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt16Int64Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt16Int64Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt16Int64Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt16Int64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt16Int64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt16Int64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt16Int64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt16Int64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt16Int64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt16Int64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt16Float64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt16Float64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt16Float64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt16Float64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt16Float64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt16Float64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}
	case coltypes.Int32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {
		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt32DecimalOp{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt32DecimalOp{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt32DecimalOp{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt32DecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt32DecimalOp{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt32DecimalOp{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt32DecimalOp{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt32DecimalOp{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt32DecimalOp{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt32DecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt32Int16Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt32Int16Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt32Int16Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt32Int16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt32Int16Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt32Int16Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt32Int16Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt32Int16Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt32Int16Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt32Int16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt32Int32Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt32Int32Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt32Int32Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt32Int32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt32Int32Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt32Int32Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt32Int32Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt32Int32Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt32Int32Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt32Int32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt32Int64Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt32Int64Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt32Int64Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt32Int64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt32Int64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt32Int64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt32Int64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt32Int64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt32Int64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt32Int64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt32Float64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt32Float64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt32Float64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt32Float64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt32Float64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt32Float64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}
	case coltypes.Int64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {
		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt64DecimalOp{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt64DecimalOp{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt64DecimalOp{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt64DecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt64DecimalOp{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt64DecimalOp{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt64DecimalOp{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt64DecimalOp{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt64DecimalOp{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt64DecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt64Int16Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt64Int16Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt64Int16Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt64Int16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt64Int16Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt64Int16Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt64Int16Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt64Int16Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt64Int16Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt64Int16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt64Int32Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt64Int32Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt64Int32Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt64Int32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt64Int32Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt64Int32Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt64Int32Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt64Int32Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt64Int32Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt64Int32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusInt64Int64Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusInt64Int64Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultInt64Int64Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivInt64Int64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt64Int64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt64Int64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt64Int64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt64Int64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt64Int64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt64Int64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQInt64Float64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEInt64Float64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTInt64Float64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEInt64Float64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTInt64Float64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEInt64Float64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}
	case coltypes.Float64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {
		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQFloat64DecimalOp{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEFloat64DecimalOp{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTFloat64DecimalOp{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEFloat64DecimalOp{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTFloat64DecimalOp{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEFloat64DecimalOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQFloat64Int16Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEFloat64Int16Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTFloat64Int16Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEFloat64Int16Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTFloat64Int16Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEFloat64Int16Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQFloat64Int32Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEFloat64Int32Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTFloat64Int32Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEFloat64Int32Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTFloat64Int32Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEFloat64Int32Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQFloat64Int64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEFloat64Int64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTFloat64Int64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEFloat64Int64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTFloat64Int64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEFloat64Int64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				case tree.Plus:
					return &projPlusFloat64Float64Op{projOpBase: projOpBase}, nil
				case tree.Minus:
					return &projMinusFloat64Float64Op{projOpBase: projOpBase}, nil
				case tree.Mult:
					return &projMultFloat64Float64Op{projOpBase: projOpBase}, nil
				case tree.Div:
					return &projDivFloat64Float64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQFloat64Float64Op{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNEFloat64Float64Op{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTFloat64Float64Op{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLEFloat64Float64Op{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTFloat64Float64Op{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGEFloat64Float64Op{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}
	case coltypes.Timestamp:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {
		case coltypes.Timestamp:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {
				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {
				case tree.EQ:
					return &projEQTimestampTimestampOp{projOpBase: projOpBase}, nil
				case tree.NE:
					return &projNETimestampTimestampOp{projOpBase: projOpBase}, nil
				case tree.LT:
					return &projLTTimestampTimestampOp{projOpBase: projOpBase}, nil
				case tree.LE:
					return &projLETimestampTimestampOp{projOpBase: projOpBase}, nil
				case tree.GT:
					return &projGTTimestampTimestampOp{projOpBase: projOpBase}, nil
				case tree.GE:
					return &projGETimestampTimestampOp{projOpBase: projOpBase}, nil
				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}
		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}
	default:
		return nil, errors.Errorf("unhandled left type: %s", leftType)
	}
}
