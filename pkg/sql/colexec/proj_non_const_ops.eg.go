// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"math"

	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/server/telemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sqltelemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

// projConstOpBase contains all of the fields for projections with a constant,
// except for the constant itself.
// NOTE: this struct should be declared in proj_const_ops_tmpl.go, but if we do
// so, it'll be redeclared because we execute that template twice. To go
// around the problem we specify it here.
type projConstOpBase struct {
	OneInputNode
	allocator      *colmem.Allocator
	colIdx         int
	outputIdx      int
	overloadHelper overloadHelper
}

// projOpBase contains all of the fields for non-constant projections.
type projOpBase struct {
	OneInputNode
	allocator      *colmem.Allocator
	col1Idx        int
	col2Idx        int
	outputIdx      int
	overloadHelper overloadHelper
}

type projBitandInt16Int16Op struct {
	projOpBase
}

func (p projBitandInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt16Int16Op) Init() {
	p.input.Init()
}

type projBitandInt16Int32Op struct {
	projOpBase
}

func (p projBitandInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt16Int32Op) Init() {
	p.input.Init()
}

type projBitandInt16Int64Op struct {
	projOpBase
}

func (p projBitandInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt16Int64Op) Init() {
	p.input.Init()
}

type projBitandInt32Int16Op struct {
	projOpBase
}

func (p projBitandInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt32Int16Op) Init() {
	p.input.Init()
}

type projBitandInt32Int32Op struct {
	projOpBase
}

func (p projBitandInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt32Int32Op) Init() {
	p.input.Init()
}

type projBitandInt32Int64Op struct {
	projOpBase
}

func (p projBitandInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt32Int64Op) Init() {
	p.input.Init()
}

type projBitandInt64Int16Op struct {
	projOpBase
}

func (p projBitandInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt64Int16Op) Init() {
	p.input.Init()
}

type projBitandInt64Int32Op struct {
	projOpBase
}

func (p projBitandInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt64Int32Op) Init() {
	p.input.Init()
}

type projBitandInt64Int64Op struct {
	projOpBase
}

func (p projBitandInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) & int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt64Int64Op) Init() {
	p.input.Init()
}

type projBitandDatumDatumOp struct {
	projOpBase
}

func (p projBitandDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandDatumDatumOp) Init() {
	p.input.Init()
}

type projBitorInt16Int16Op struct {
	projOpBase
}

func (p projBitorInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt16Int16Op) Init() {
	p.input.Init()
}

type projBitorInt16Int32Op struct {
	projOpBase
}

func (p projBitorInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt16Int32Op) Init() {
	p.input.Init()
}

type projBitorInt16Int64Op struct {
	projOpBase
}

func (p projBitorInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt16Int64Op) Init() {
	p.input.Init()
}

type projBitorInt32Int16Op struct {
	projOpBase
}

func (p projBitorInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt32Int16Op) Init() {
	p.input.Init()
}

type projBitorInt32Int32Op struct {
	projOpBase
}

func (p projBitorInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt32Int32Op) Init() {
	p.input.Init()
}

type projBitorInt32Int64Op struct {
	projOpBase
}

func (p projBitorInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt32Int64Op) Init() {
	p.input.Init()
}

type projBitorInt64Int16Op struct {
	projOpBase
}

func (p projBitorInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt64Int16Op) Init() {
	p.input.Init()
}

type projBitorInt64Int32Op struct {
	projOpBase
}

func (p projBitorInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt64Int32Op) Init() {
	p.input.Init()
}

type projBitorInt64Int64Op struct {
	projOpBase
}

func (p projBitorInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) | int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt64Int64Op) Init() {
	p.input.Init()
}

type projBitorDatumDatumOp struct {
	projOpBase
}

func (p projBitorDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorDatumDatumOp) Init() {
	p.input.Init()
}

type projBitxorInt16Int16Op struct {
	projOpBase
}

func (p projBitxorInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt16Int16Op) Init() {
	p.input.Init()
}

type projBitxorInt16Int32Op struct {
	projOpBase
}

func (p projBitxorInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt16Int32Op) Init() {
	p.input.Init()
}

type projBitxorInt16Int64Op struct {
	projOpBase
}

func (p projBitxorInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt16Int64Op) Init() {
	p.input.Init()
}

type projBitxorInt32Int16Op struct {
	projOpBase
}

func (p projBitxorInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt32Int16Op) Init() {
	p.input.Init()
}

type projBitxorInt32Int32Op struct {
	projOpBase
}

func (p projBitxorInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt32Int32Op) Init() {
	p.input.Init()
}

type projBitxorInt32Int64Op struct {
	projOpBase
}

func (p projBitxorInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt32Int64Op) Init() {
	p.input.Init()
}

type projBitxorInt64Int16Op struct {
	projOpBase
}

func (p projBitxorInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt64Int16Op) Init() {
	p.input.Init()
}

type projBitxorInt64Int32Op struct {
	projOpBase
}

func (p projBitxorInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt64Int32Op) Init() {
	p.input.Init()
}

type projBitxorInt64Int64Op struct {
	projOpBase
}

func (p projBitxorInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				projCol[i] = int64(arg1) ^ int64(arg2)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt64Int64Op) Init() {
	p.input.Init()
}

type projBitxorDatumDatumOp struct {
	projOpBase
}

func (p projBitxorDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorDatumDatumOp) Init() {
	p.input.Init()
}

type projPlusDecimalInt16Op struct {
	projOpBase
}

func (p projPlusDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDecimalInt16Op) Init() {
	p.input.Init()
}

type projPlusDecimalInt32Op struct {
	projOpBase
}

func (p projPlusDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDecimalInt32Op) Init() {
	p.input.Init()
}

type projPlusDecimalInt64Op struct {
	projOpBase
}

func (p projPlusDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDecimalInt64Op) Init() {
	p.input.Init()
}

type projPlusDecimalDecimalOp struct {
	projOpBase
}

func (p projPlusDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						_, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						_, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					_, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					_, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDecimalDecimalOp) Init() {
	p.input.Init()
}

type projPlusInt16Int16Op struct {
	projOpBase
}

func (p projPlusInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16Int16Op) Init() {
	p.input.Init()
}

type projPlusInt16Int32Op struct {
	projOpBase
}

func (p projPlusInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16Int32Op) Init() {
	p.input.Init()
}

type projPlusInt16Int64Op struct {
	projOpBase
}

func (p projPlusInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16Int64Op) Init() {
	p.input.Init()
}

type projPlusInt16DecimalOp struct {
	projOpBase
}

func (p projPlusInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16DecimalOp) Init() {
	p.input.Init()
}

type projPlusInt16DatumOp struct {
	projOpBase
}

func (p projPlusInt16DatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16DatumOp) Init() {
	p.input.Init()
}

type projPlusInt32Int16Op struct {
	projOpBase
}

func (p projPlusInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32Int16Op) Init() {
	p.input.Init()
}

type projPlusInt32Int32Op struct {
	projOpBase
}

func (p projPlusInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32Int32Op) Init() {
	p.input.Init()
}

type projPlusInt32Int64Op struct {
	projOpBase
}

func (p projPlusInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32Int64Op) Init() {
	p.input.Init()
}

type projPlusInt32DecimalOp struct {
	projOpBase
}

func (p projPlusInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32DecimalOp) Init() {
	p.input.Init()
}

type projPlusInt32DatumOp struct {
	projOpBase
}

func (p projPlusInt32DatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32DatumOp) Init() {
	p.input.Init()
}

type projPlusInt64Int16Op struct {
	projOpBase
}

func (p projPlusInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64Int16Op) Init() {
	p.input.Init()
}

type projPlusInt64Int32Op struct {
	projOpBase
}

func (p projPlusInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64Int32Op) Init() {
	p.input.Init()
}

type projPlusInt64Int64Op struct {
	projOpBase
}

func (p projPlusInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) + int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64Int64Op) Init() {
	p.input.Init()
}

type projPlusInt64DecimalOp struct {
	projOpBase
}

func (p projPlusInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64DecimalOp) Init() {
	p.input.Init()
}

type projPlusInt64DatumOp struct {
	projOpBase
}

func (p projPlusInt64DatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64DatumOp) Init() {
	p.input.Init()
}

type projPlusFloat64Float64Op struct {
	projOpBase
}

func (p projPlusFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						projCol[i] = float64(arg1) + float64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						projCol[i] = float64(arg1) + float64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					projCol[i] = float64(arg1) + float64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					projCol[i] = float64(arg1) + float64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusFloat64Float64Op) Init() {
	p.input.Init()
}

type projPlusTimestampIntervalOp struct {
	projOpBase
}

func (p projPlusTimestampIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Timestamp()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = duration.Add(arg1, arg2)
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = duration.Add(arg1, arg2)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = duration.Add(arg1, arg2)
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = duration.Add(arg1, arg2)
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusTimestampIntervalOp) Init() {
	p.input.Init()
}

type projPlusIntervalTimestampOp struct {
	projOpBase
}

func (p projPlusIntervalTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Timestamp()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = duration.Add(arg2, arg1)
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = duration.Add(arg2, arg1)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = duration.Add(arg2, arg1)
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = duration.Add(arg2, arg1)
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusIntervalTimestampOp) Init() {
	p.input.Init()
}

type projPlusIntervalIntervalOp struct {
	projOpBase
}

func (p projPlusIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Add(arg2)
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Add(arg2)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Add(arg2)
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Add(arg2)
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusIntervalIntervalOp) Init() {
	p.input.Init()
}

type projPlusIntervalDatumOp struct {
	projOpBase
}

func (p projPlusIntervalDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg1}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg1}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInterval{Duration: arg1}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInterval{Duration: arg1}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusIntervalDatumOp) Init() {
	p.input.Init()
}

type projPlusDatumIntervalOp struct {
	projOpBase
}

func (p projPlusDatumIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInterval{Duration: arg2}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInterval{Duration: arg2}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInterval{Duration: arg2}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInterval{Duration: arg2}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDatumIntervalOp) Init() {
	p.input.Init()
}

type projPlusDatumInt16Op struct {
	projOpBase
}

func (p projPlusDatumInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDatumInt16Op) Init() {
	p.input.Init()
}

type projPlusDatumInt32Op struct {
	projOpBase
}

func (p projPlusDatumInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDatumInt32Op) Init() {
	p.input.Init()
}

type projPlusDatumInt64Op struct {
	projOpBase
}

func (p projPlusDatumInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDatumInt64Op) Init() {
	p.input.Init()
}

type projMinusDecimalInt16Op struct {
	projOpBase
}

func (p projMinusDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDecimalInt16Op) Init() {
	p.input.Init()
}

type projMinusDecimalInt32Op struct {
	projOpBase
}

func (p projMinusDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDecimalInt32Op) Init() {
	p.input.Init()
}

type projMinusDecimalInt64Op struct {
	projOpBase
}

func (p projMinusDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDecimalInt64Op) Init() {
	p.input.Init()
}

type projMinusDecimalDecimalOp struct {
	projOpBase
}

func (p projMinusDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						_, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						_, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					_, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					_, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDecimalDecimalOp) Init() {
	p.input.Init()
}

type projMinusInt16Int16Op struct {
	projOpBase
}

func (p projMinusInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16Int16Op) Init() {
	p.input.Init()
}

type projMinusInt16Int32Op struct {
	projOpBase
}

func (p projMinusInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16Int32Op) Init() {
	p.input.Init()
}

type projMinusInt16Int64Op struct {
	projOpBase
}

func (p projMinusInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16Int64Op) Init() {
	p.input.Init()
}

type projMinusInt16DecimalOp struct {
	projOpBase
}

func (p projMinusInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16DecimalOp) Init() {
	p.input.Init()
}

type projMinusInt16DatumOp struct {
	projOpBase
}

func (p projMinusInt16DatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16DatumOp) Init() {
	p.input.Init()
}

type projMinusInt32Int16Op struct {
	projOpBase
}

func (p projMinusInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32Int16Op) Init() {
	p.input.Init()
}

type projMinusInt32Int32Op struct {
	projOpBase
}

func (p projMinusInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32Int32Op) Init() {
	p.input.Init()
}

type projMinusInt32Int64Op struct {
	projOpBase
}

func (p projMinusInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32Int64Op) Init() {
	p.input.Init()
}

type projMinusInt32DecimalOp struct {
	projOpBase
}

func (p projMinusInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32DecimalOp) Init() {
	p.input.Init()
}

type projMinusInt32DatumOp struct {
	projOpBase
}

func (p projMinusInt32DatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32DatumOp) Init() {
	p.input.Init()
}

type projMinusInt64Int16Op struct {
	projOpBase
}

func (p projMinusInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64Int16Op) Init() {
	p.input.Init()
}

type projMinusInt64Int32Op struct {
	projOpBase
}

func (p projMinusInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64Int32Op) Init() {
	p.input.Init()
}

type projMinusInt64Int64Op struct {
	projOpBase
}

func (p projMinusInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					result := int64(arg1) - int64(arg2)
					if (result < int64(arg1)) != (int64(arg2) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64Int64Op) Init() {
	p.input.Init()
}

type projMinusInt64DecimalOp struct {
	projOpBase
}

func (p projMinusInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64DecimalOp) Init() {
	p.input.Init()
}

type projMinusInt64DatumOp struct {
	projOpBase
}

func (p projMinusInt64DatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInt(arg1)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64DatumOp) Init() {
	p.input.Init()
}

type projMinusFloat64Float64Op struct {
	projOpBase
}

func (p projMinusFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						projCol[i] = float64(arg1) - float64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						projCol[i] = float64(arg1) - float64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					projCol[i] = float64(arg1) - float64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					projCol[i] = float64(arg1) - float64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMinusTimestampTimestampOp struct {
	projOpBase
}

func (p projMinusTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					nanos := arg1.Sub(arg2).Nanoseconds()
					projCol[i] = duration.MakeDuration(nanos, 0, 0)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					nanos := arg1.Sub(arg2).Nanoseconds()
					projCol[i] = duration.MakeDuration(nanos, 0, 0)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				nanos := arg1.Sub(arg2).Nanoseconds()
				projCol[i] = duration.MakeDuration(nanos, 0, 0)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				nanos := arg1.Sub(arg2).Nanoseconds()
				projCol[i] = duration.MakeDuration(nanos, 0, 0)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusTimestampTimestampOp) Init() {
	p.input.Init()
}

type projMinusTimestampIntervalOp struct {
	projOpBase
}

func (p projMinusTimestampIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Timestamp()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = duration.Add(arg1, arg2.Mul(-1))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = duration.Add(arg1, arg2.Mul(-1))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = duration.Add(arg1, arg2.Mul(-1))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = duration.Add(arg1, arg2.Mul(-1))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusTimestampIntervalOp) Init() {
	p.input.Init()
}

type projMinusIntervalIntervalOp struct {
	projOpBase
}

func (p projMinusIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Sub(arg2)
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Sub(arg2)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Sub(arg2)
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Sub(arg2)
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusIntervalIntervalOp) Init() {
	p.input.Init()
}

type projMinusIntervalDatumOp struct {
	projOpBase
}

func (p projMinusIntervalDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg1}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg1}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInterval{Duration: arg1}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i)

				_convertedNativeElem := tree.DInterval{Duration: arg1}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusIntervalDatumOp) Init() {
	p.input.Init()
}

type projMinusDatumDatumOp struct {
	projOpBase
}

func (p projMinusDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumDatumOp) Init() {
	p.input.Init()
}

type projMinusDatumIntervalOp struct {
	projOpBase
}

func (p projMinusDatumIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInterval{Duration: arg2}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInterval{Duration: arg2}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInterval{Duration: arg2}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInterval{Duration: arg2}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumIntervalOp) Init() {
	p.input.Init()
}

type projMinusDatumBytesOp struct {
	projOpBase
}

func (p projMinusDatumBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DBytes(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DBytes(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DBytes(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DBytes(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumBytesOp) Init() {
	p.input.Init()
}

type projMinusDatumInt16Op struct {
	projOpBase
}

func (p projMinusDatumInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumInt16Op) Init() {
	p.input.Init()
}

type projMinusDatumInt32Op struct {
	projOpBase
}

func (p projMinusDatumInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumInt32Op) Init() {
	p.input.Init()
}

type projMinusDatumInt64Op struct {
	projOpBase
}

func (p projMinusDatumInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumInt64Op) Init() {
	p.input.Init()
}

type projMultDecimalInt16Op struct {
	projOpBase
}

func (p projMultDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalInt16Op) Init() {
	p.input.Init()
}

type projMultDecimalInt32Op struct {
	projOpBase
}

func (p projMultDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalInt32Op) Init() {
	p.input.Init()
}

type projMultDecimalInt64Op struct {
	projOpBase
}

func (p projMultDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalInt64Op) Init() {
	p.input.Init()
}

type projMultDecimalDecimalOp struct {
	projOpBase
}

func (p projMultDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						_, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						_, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					_, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					_, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalDecimalOp) Init() {
	p.input.Init()
}

type projMultDecimalIntervalOp struct {
	projOpBase
}

func (p projMultDecimalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					f, err := arg1.Float64()
					if err != nil {
						colexecerror.InternalError(err)
					}
					projCol[i] = arg2.MulFloat(f)
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					f, err := arg1.Float64()
					if err != nil {
						colexecerror.InternalError(err)
					}
					projCol[i] = arg2.MulFloat(f)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				f, err := arg1.Float64()
				if err != nil {
					colexecerror.InternalError(err)
				}
				projCol[i] = arg2.MulFloat(f)
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				f, err := arg1.Float64()
				if err != nil {
					colexecerror.InternalError(err)
				}
				projCol[i] = arg2.MulFloat(f)
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalIntervalOp) Init() {
	p.input.Init()
}

type projMultInt16Int16Op struct {
	projOpBase
}

func (p projMultInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16Int16Op) Init() {
	p.input.Init()
}

type projMultInt16Int32Op struct {
	projOpBase
}

func (p projMultInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16Int32Op) Init() {
	p.input.Init()
}

type projMultInt16Int64Op struct {
	projOpBase
}

func (p projMultInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16Int64Op) Init() {
	p.input.Init()
}

type projMultInt16DecimalOp struct {
	projOpBase
}

func (p projMultInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16DecimalOp) Init() {
	p.input.Init()
}

type projMultInt16IntervalOp struct {
	projOpBase
}

func (p projMultInt16IntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg2.Mul(int64(arg1))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg2.Mul(int64(arg1))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16IntervalOp) Init() {
	p.input.Init()
}

type projMultInt32Int16Op struct {
	projOpBase
}

func (p projMultInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32Int16Op) Init() {
	p.input.Init()
}

type projMultInt32Int32Op struct {
	projOpBase
}

func (p projMultInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32Int32Op) Init() {
	p.input.Init()
}

type projMultInt32Int64Op struct {
	projOpBase
}

func (p projMultInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32Int64Op) Init() {
	p.input.Init()
}

type projMultInt32DecimalOp struct {
	projOpBase
}

func (p projMultInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32DecimalOp) Init() {
	p.input.Init()
}

type projMultInt32IntervalOp struct {
	projOpBase
}

func (p projMultInt32IntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg2.Mul(int64(arg1))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg2.Mul(int64(arg1))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32IntervalOp) Init() {
	p.input.Init()
}

type projMultInt64Int16Op struct {
	projOpBase
}

func (p projMultInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64Int16Op) Init() {
	p.input.Init()
}

type projMultInt64Int32Op struct {
	projOpBase
}

func (p projMultInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64Int32Op) Init() {
	p.input.Init()
}

type projMultInt64Int64Op struct {
	projOpBase
}

func (p projMultInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					_left, _right := int64(arg1), int64(arg2)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64Int64Op) Init() {
	p.input.Init()
}

type projMultInt64DecimalOp struct {
	projOpBase
}

func (p projMultInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64DecimalOp) Init() {
	p.input.Init()
}

type projMultInt64IntervalOp struct {
	projOpBase
}

func (p projMultInt64IntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg2.Mul(int64(arg1))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg2.Mul(int64(arg1))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64IntervalOp) Init() {
	p.input.Init()
}

type projMultFloat64Float64Op struct {
	projOpBase
}

func (p projMultFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						projCol[i] = float64(arg1) * float64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						projCol[i] = float64(arg1) * float64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					projCol[i] = float64(arg1) * float64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					projCol[i] = float64(arg1) * float64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultFloat64Float64Op) Init() {
	p.input.Init()
}

type projMultFloat64IntervalOp struct {
	projOpBase
}

func (p projMultFloat64IntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg2.MulFloat(float64(arg1))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg2.MulFloat(float64(arg1))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg2.MulFloat(float64(arg1))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg2.MulFloat(float64(arg1))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultFloat64IntervalOp) Init() {
	p.input.Init()
}

type projMultIntervalInt16Op struct {
	projOpBase
}

func (p projMultIntervalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Mul(int64(arg2))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Mul(int64(arg2))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalInt16Op) Init() {
	p.input.Init()
}

type projMultIntervalInt32Op struct {
	projOpBase
}

func (p projMultIntervalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Mul(int64(arg2))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Mul(int64(arg2))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalInt32Op) Init() {
	p.input.Init()
}

type projMultIntervalInt64Op struct {
	projOpBase
}

func (p projMultIntervalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Mul(int64(arg2))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.Mul(int64(arg2))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalInt64Op) Init() {
	p.input.Init()
}

type projMultIntervalFloat64Op struct {
	projOpBase
}

func (p projMultIntervalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.MulFloat(float64(arg2))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline
					projCol[i] = arg1.MulFloat(float64(arg2))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.MulFloat(float64(arg2))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline
				projCol[i] = arg1.MulFloat(float64(arg2))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalFloat64Op) Init() {
	p.input.Init()
}

type projMultIntervalDecimalOp struct {
	projOpBase
}

func (p projMultIntervalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					f, err := arg2.Float64()
					if err != nil {
						colexecerror.InternalError(err)
					}
					projCol[i] = arg1.MulFloat(f)
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					f, err := arg2.Float64()
					if err != nil {
						colexecerror.InternalError(err)
					}
					projCol[i] = arg1.MulFloat(f)
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				f, err := arg2.Float64()
				if err != nil {
					colexecerror.InternalError(err)
				}
				projCol[i] = arg1.MulFloat(f)
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				f, err := arg2.Float64()
				if err != nil {
					colexecerror.InternalError(err)
				}
				projCol[i] = arg1.MulFloat(f)
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalDecimalOp) Init() {
	p.input.Init()
}

type projDivDecimalInt16Op struct {
	projOpBase
}

func (p projDivDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivDecimalInt16Op) Init() {
	p.input.Init()
}

type projDivDecimalInt32Op struct {
	projOpBase
}

func (p projDivDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivDecimalInt32Op) Init() {
	p.input.Init()
}

type projDivDecimalInt64Op struct {
	projOpBase
}

func (p projDivDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivDecimalInt64Op) Init() {
	p.input.Init()
}

type projDivDecimalDecimalOp struct {
	projOpBase
}

func (p projDivDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivDecimalDecimalOp) Init() {
	p.input.Init()
}

type projDivInt16Int16Op struct {
	projOpBase
}

func (p projDivInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt16Int16Op) Init() {
	p.input.Init()
}

type projDivInt16Int32Op struct {
	projOpBase
}

func (p projDivInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt16Int32Op) Init() {
	p.input.Init()
}

type projDivInt16Int64Op struct {
	projOpBase
}

func (p projDivInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt16Int64Op) Init() {
	p.input.Init()
}

type projDivInt16DecimalOp struct {
	projOpBase
}

func (p projDivInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt16DecimalOp) Init() {
	p.input.Init()
}

type projDivInt32Int16Op struct {
	projOpBase
}

func (p projDivInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt32Int16Op) Init() {
	p.input.Init()
}

type projDivInt32Int32Op struct {
	projOpBase
}

func (p projDivInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt32Int32Op) Init() {
	p.input.Init()
}

type projDivInt32Int64Op struct {
	projOpBase
}

func (p projDivInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt32Int64Op) Init() {
	p.input.Init()
}

type projDivInt32DecimalOp struct {
	projOpBase
}

func (p projDivInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt32DecimalOp) Init() {
	p.input.Init()
}

type projDivInt64Int16Op struct {
	projOpBase
}

func (p projDivInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt64Int16Op) Init() {
	p.input.Init()
}

type projDivInt64Int32Op struct {
	projOpBase
}

func (p projDivInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt64Int32Op) Init() {
	p.input.Init()
}

type projDivInt64Int64Op struct {
	projOpBase
}

func (p projDivInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt64Int64Op) Init() {
	p.input.Init()
}

type projDivInt64DecimalOp struct {
	projOpBase
}

func (p projDivInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt64DecimalOp) Init() {
	p.input.Init()
}

type projDivFloat64Float64Op struct {
	projOpBase
}

func (p projDivFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = float64(arg1) / float64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = float64(arg1) / float64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = float64(arg1) / float64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = float64(arg1) / float64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivFloat64Float64Op) Init() {
	p.input.Init()
}

type projDivIntervalInt64Op struct {
	projOpBase
}

func (p projDivIntervalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.Div(int64(arg2))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.Div(int64(arg2))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				if arg2 == 0 {
					colexecerror.ExpectedError(tree.ErrDivByZero)
				}
				projCol[i] = arg1.Div(int64(arg2))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				if arg2 == 0 {
					colexecerror.ExpectedError(tree.ErrDivByZero)
				}
				projCol[i] = arg1.Div(int64(arg2))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivIntervalInt64Op) Init() {
	p.input.Init()
}

type projDivIntervalFloat64Op struct {
	projOpBase
}

func (p projDivIntervalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.DivFloat(float64(arg2))
				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.DivFloat(float64(arg2))
				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				if arg2 == 0.0 {
					colexecerror.ExpectedError(tree.ErrDivByZero)
				}
				projCol[i] = arg1.DivFloat(float64(arg2))
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				if arg2 == 0.0 {
					colexecerror.ExpectedError(tree.ErrDivByZero)
				}
				projCol[i] = arg1.DivFloat(float64(arg2))
			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivIntervalFloat64Op) Init() {
	p.input.Init()
}

type projFloorDivDecimalInt16Op struct {
	projOpBase
}

func (p projFloorDivDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivDecimalInt16Op) Init() {
	p.input.Init()
}

type projFloorDivDecimalInt32Op struct {
	projOpBase
}

func (p projFloorDivDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivDecimalInt32Op) Init() {
	p.input.Init()
}

type projFloorDivDecimalInt64Op struct {
	projOpBase
}

func (p projFloorDivDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivDecimalInt64Op) Init() {
	p.input.Init()
}

type projFloorDivDecimalDecimalOp struct {
	projOpBase
}

func (p projFloorDivDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivDecimalDecimalOp) Init() {
	p.input.Init()
}

type projFloorDivInt16Int16Op struct {
	projOpBase
}

func (p projFloorDivInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt16Int16Op) Init() {
	p.input.Init()
}

type projFloorDivInt16Int32Op struct {
	projOpBase
}

func (p projFloorDivInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt16Int32Op) Init() {
	p.input.Init()
}

type projFloorDivInt16Int64Op struct {
	projOpBase
}

func (p projFloorDivInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt16Int64Op) Init() {
	p.input.Init()
}

type projFloorDivInt16DecimalOp struct {
	projOpBase
}

func (p projFloorDivInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt16DecimalOp) Init() {
	p.input.Init()
}

type projFloorDivInt32Int16Op struct {
	projOpBase
}

func (p projFloorDivInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt32Int16Op) Init() {
	p.input.Init()
}

type projFloorDivInt32Int32Op struct {
	projOpBase
}

func (p projFloorDivInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt32Int32Op) Init() {
	p.input.Init()
}

type projFloorDivInt32Int64Op struct {
	projOpBase
}

func (p projFloorDivInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt32Int64Op) Init() {
	p.input.Init()
}

type projFloorDivInt32DecimalOp struct {
	projOpBase
}

func (p projFloorDivInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt32DecimalOp) Init() {
	p.input.Init()
}

type projFloorDivInt64Int16Op struct {
	projOpBase
}

func (p projFloorDivInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt64Int16Op) Init() {
	p.input.Init()
}

type projFloorDivInt64Int32Op struct {
	projOpBase
}

func (p projFloorDivInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt64Int32Op) Init() {
	p.input.Init()
}

type projFloorDivInt64Int64Op struct {
	projOpBase
}

func (p projFloorDivInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) // int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) // int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt64Int64Op) Init() {
	p.input.Init()
}

type projFloorDivInt64DecimalOp struct {
	projOpBase
}

func (p projFloorDivInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt64DecimalOp) Init() {
	p.input.Init()
}

type projFloorDivFloat64Float64Op struct {
	projOpBase
}

func (p projFloorDivFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Trunc(float64(arg1) / float64(arg2))
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Trunc(float64(arg1) / float64(arg2))
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = math.Trunc(float64(arg1) / float64(arg2))
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = math.Trunc(float64(arg1) / float64(arg2))
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivFloat64Float64Op) Init() {
	p.input.Init()
}

type projModDecimalInt16Op struct {
	projOpBase
}

func (p projModDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModDecimalInt16Op) Init() {
	p.input.Init()
}

type projModDecimalInt32Op struct {
	projOpBase
}

func (p projModDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModDecimalInt32Op) Init() {
	p.input.Init()
}

type projModDecimalInt64Op struct {
	projOpBase
}

func (p projModDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModDecimalInt64Op) Init() {
	p.input.Init()
}

type projModDecimalDecimalOp struct {
	projOpBase
}

func (p projModDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModDecimalDecimalOp) Init() {
	p.input.Init()
}

type projModInt16Int16Op struct {
	projOpBase
}

func (p projModInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt16Int16Op) Init() {
	p.input.Init()
}

type projModInt16Int32Op struct {
	projOpBase
}

func (p projModInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt16Int32Op) Init() {
	p.input.Init()
}

type projModInt16Int64Op struct {
	projOpBase
}

func (p projModInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt16Int64Op) Init() {
	p.input.Init()
}

type projModInt16DecimalOp struct {
	projOpBase
}

func (p projModInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt16DecimalOp) Init() {
	p.input.Init()
}

type projModInt32Int16Op struct {
	projOpBase
}

func (p projModInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt32Int16Op) Init() {
	p.input.Init()
}

type projModInt32Int32Op struct {
	projOpBase
}

func (p projModInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt32Int32Op) Init() {
	p.input.Init()
}

type projModInt32Int64Op struct {
	projOpBase
}

func (p projModInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt32Int64Op) Init() {
	p.input.Init()
}

type projModInt32DecimalOp struct {
	projOpBase
}

func (p projModInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt32DecimalOp) Init() {
	p.input.Init()
}

type projModInt64Int16Op struct {
	projOpBase
}

func (p projModInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt64Int16Op) Init() {
	p.input.Init()
}

type projModInt64Int32Op struct {
	projOpBase
}

func (p projModInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt64Int32Op) Init() {
	p.input.Init()
}

type projModInt64Int64Op struct {
	projOpBase
}

func (p projModInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(arg1) % int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt64Int64Op) Init() {
	p.input.Init()
}

type projModInt64DecimalOp struct {
	projOpBase
}

func (p projModInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt64DecimalOp) Init() {
	p.input.Init()
}

type projModFloat64Float64Op struct {
	projOpBase
}

func (p projModFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Mod(float64(arg1), float64(arg2))
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Mod(float64(arg1), float64(arg2))
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = math.Mod(float64(arg1), float64(arg2))
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = math.Mod(float64(arg1), float64(arg2))
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModFloat64Float64Op) Init() {
	p.input.Init()
}

type projPowDecimalInt16Op struct {
	projOpBase
}

func (p projPowDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowDecimalInt16Op) Init() {
	p.input.Init()
}

type projPowDecimalInt32Op struct {
	projOpBase
}

func (p projPowDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowDecimalInt32Op) Init() {
	p.input.Init()
}

type projPowDecimalInt64Op struct {
	projOpBase
}

func (p projPowDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg2))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowDecimalInt64Op) Init() {
	p.input.Init()
}

type projPowDecimalDecimalOp struct {
	projOpBase
}

func (p projPowDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						_, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						_, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					_, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					_, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowDecimalDecimalOp) Init() {
	p.input.Init()
}

type projPowInt16Int16Op struct {
	projOpBase
}

func (p projPowInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt16Int16Op) Init() {
	p.input.Init()
}

type projPowInt16Int32Op struct {
	projOpBase
}

func (p projPowInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt16Int32Op) Init() {
	p.input.Init()
}

type projPowInt16Int64Op struct {
	projOpBase
}

func (p projPowInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt16Int64Op) Init() {
	p.input.Init()
}

type projPowInt16DecimalOp struct {
	projOpBase
}

func (p projPowInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt16DecimalOp) Init() {
	p.input.Init()
}

type projPowInt32Int16Op struct {
	projOpBase
}

func (p projPowInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt32Int16Op) Init() {
	p.input.Init()
}

type projPowInt32Int32Op struct {
	projOpBase
}

func (p projPowInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt32Int32Op) Init() {
	p.input.Init()
}

type projPowInt32Int64Op struct {
	projOpBase
}

func (p projPowInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt32Int64Op) Init() {
	p.input.Init()
}

type projPowInt32DecimalOp struct {
	projOpBase
}

func (p projPowInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt32DecimalOp) Init() {
	p.input.Init()
}

type projPowInt64Int16Op struct {
	projOpBase
}

func (p projPowInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt64Int16Op) Init() {
	p.input.Init()
}

type projPowInt64Int32Op struct {
	projOpBase
}

func (p projPowInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt64Int32Op) Init() {
	p.input.Init()
}

type projPowInt64Int64Op struct {
	projOpBase
}

func (p projPowInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(arg1)))
					rightTmpDec.SetInt64(int64(int64(arg2)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt64Int64Op) Init() {
	p.input.Init()
}

type projPowInt64DecimalOp struct {
	projOpBase
}

func (p projPowInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg1))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt64DecimalOp) Init() {
	p.input.Init()
}

type projPowFloat64Float64Op struct {
	projOpBase
}

func (p projPowFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						projCol[i] = math.Pow(float64(arg1), float64(arg2))
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{

						projCol[i] = math.Pow(float64(arg1), float64(arg2))
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					projCol[i] = math.Pow(float64(arg1), float64(arg2))
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{

					projCol[i] = math.Pow(float64(arg1), float64(arg2))
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowFloat64Float64Op) Init() {
	p.input.Init()
}

type projConcatBytesBytesOp struct {
	projOpBase
}

func (p projConcatBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bytes()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var r = []byte{}
						r = append(r, arg1...)
						r = append(r, arg2...)
						projCol.Set(i, r)
					}

				}
			}
		} else {
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var r = []byte{}
						r = append(r, arg1...)
						r = append(r, arg2...)
						projCol.Set(i, r)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var r = []byte{}
					r = append(r, arg1...)
					r = append(r, arg2...)
					projCol.Set(i, r)
				}

			}
		} else {
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var r = []byte{}
					r = append(r, arg1...)
					r = append(r, arg2...)
					projCol.Set(i, r)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projConcatBytesBytesOp) Init() {
	p.input.Init()
}

type projConcatDatumDatumOp struct {
	projOpBase
}

func (p projConcatDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg2)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projConcatDatumDatumOp) Init() {
	p.input.Init()
}

type projLShiftInt16Int16Op struct {
	projOpBase
}

func (p projLShiftInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt16Int16Op) Init() {
	p.input.Init()
}

type projLShiftInt16Int32Op struct {
	projOpBase
}

func (p projLShiftInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt16Int32Op) Init() {
	p.input.Init()
}

type projLShiftInt16Int64Op struct {
	projOpBase
}

func (p projLShiftInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt16Int64Op) Init() {
	p.input.Init()
}

type projLShiftInt32Int16Op struct {
	projOpBase
}

func (p projLShiftInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt32Int16Op) Init() {
	p.input.Init()
}

type projLShiftInt32Int32Op struct {
	projOpBase
}

func (p projLShiftInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt32Int32Op) Init() {
	p.input.Init()
}

type projLShiftInt32Int64Op struct {
	projOpBase
}

func (p projLShiftInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt32Int64Op) Init() {
	p.input.Init()
}

type projLShiftInt64Int16Op struct {
	projOpBase
}

func (p projLShiftInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt64Int16Op) Init() {
	p.input.Init()
}

type projLShiftInt64Int32Op struct {
	projOpBase
}

func (p projLShiftInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt64Int32Op) Init() {
	p.input.Init()
}

type projLShiftInt64Int64Op struct {
	projOpBase
}

func (p projLShiftInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) << int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt64Int64Op) Init() {
	p.input.Init()
}

type projLShiftDatumInt16Op struct {
	projOpBase
}

func (p projLShiftDatumInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftDatumInt16Op) Init() {
	p.input.Init()
}

type projLShiftDatumInt32Op struct {
	projOpBase
}

func (p projLShiftDatumInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftDatumInt32Op) Init() {
	p.input.Init()
}

type projLShiftDatumInt64Op struct {
	projOpBase
}

func (p projLShiftDatumInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftDatumInt64Op) Init() {
	p.input.Init()
}

type projRShiftInt16Int16Op struct {
	projOpBase
}

func (p projRShiftInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt16Int16Op) Init() {
	p.input.Init()
}

type projRShiftInt16Int32Op struct {
	projOpBase
}

func (p projRShiftInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt16Int32Op) Init() {
	p.input.Init()
}

type projRShiftInt16Int64Op struct {
	projOpBase
}

func (p projRShiftInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt16Int64Op) Init() {
	p.input.Init()
}

type projRShiftInt32Int16Op struct {
	projOpBase
}

func (p projRShiftInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt32Int16Op) Init() {
	p.input.Init()
}

type projRShiftInt32Int32Op struct {
	projOpBase
}

func (p projRShiftInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt32Int32Op) Init() {
	p.input.Init()
}

type projRShiftInt32Int64Op struct {
	projOpBase
}

func (p projRShiftInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt32Int64Op) Init() {
	p.input.Init()
}

type projRShiftInt64Int16Op struct {
	projOpBase
}

func (p projRShiftInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt64Int16Op) Init() {
	p.input.Init()
}

type projRShiftInt64Int32Op struct {
	projOpBase
}

func (p projRShiftInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt64Int32Op) Init() {
	p.input.Init()
}

type projRShiftInt64Int64Op struct {
	projOpBase
}

func (p projRShiftInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					if int64(arg2) < 0 || int64(arg2) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(arg1) >> int64(arg2)
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt64Int64Op) Init() {
	p.input.Init()
}

type projRShiftDatumInt16Op struct {
	projOpBase
}

func (p projRShiftDatumInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftDatumInt16Op) Init() {
	p.input.Init()
}

type projRShiftDatumInt32Op struct {
	projOpBase
}

func (p projRShiftDatumInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftDatumInt32Op) Init() {
	p.input.Init()
}

type projRShiftDatumInt64Op struct {
	projOpBase
}

func (p projRShiftDatumInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftDatumInt64Op) Init() {
	p.input.Init()
}

type projJSONFetchValDatumBytesOp struct {
	projOpBase
}

func (p projJSONFetchValDatumBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DString(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DString(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DString(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DString(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projJSONFetchValDatumBytesOp) Init() {
	p.input.Init()
}

type projJSONFetchValDatumInt16Op struct {
	projOpBase
}

func (p projJSONFetchValDatumInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projJSONFetchValDatumInt16Op) Init() {
	p.input.Init()
}

type projJSONFetchValDatumInt32Op struct {
	projOpBase
}

func (p projJSONFetchValDatumInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projJSONFetchValDatumInt32Op) Init() {
	p.input.Init()
}

type projJSONFetchValDatumInt64Op struct {
	projOpBase
}

func (p projJSONFetchValDatumInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i) //gcassert:inline

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1)
			_ = col2.Get(colLen - 1) //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i) //gcassert:inline

				_convertedNativeElem := tree.DInt(arg2)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := arg1.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projJSONFetchValDatumInt64Op) Init() {
	p.input.Init()
}

type projEQBoolBoolOp struct {
	projOpBase
}

func (p projEQBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQBoolBoolOp) Init() {
	p.input.Init()
}

type projEQBytesBytesOp struct {
	projOpBase
}

func (p projEQBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQBytesBytesOp) Init() {
	p.input.Init()
}

type projEQDecimalInt16Op struct {
	projOpBase
}

func (p projEQDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalInt16Op) Init() {
	p.input.Init()
}

type projEQDecimalInt32Op struct {
	projOpBase
}

func (p projEQDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalInt32Op) Init() {
	p.input.Init()
}

type projEQDecimalInt64Op struct {
	projOpBase
}

func (p projEQDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalInt64Op) Init() {
	p.input.Init()
}

type projEQDecimalFloat64Op struct {
	projOpBase
}

func (p projEQDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalFloat64Op) Init() {
	p.input.Init()
}

type projEQDecimalDecimalOp struct {
	projOpBase
}

func (p projEQDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalDecimalOp) Init() {
	p.input.Init()
}

type projEQInt16Int16Op struct {
	projOpBase
}

func (p projEQInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16Int16Op) Init() {
	p.input.Init()
}

type projEQInt16Int32Op struct {
	projOpBase
}

func (p projEQInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16Int32Op) Init() {
	p.input.Init()
}

type projEQInt16Int64Op struct {
	projOpBase
}

func (p projEQInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16Int64Op) Init() {
	p.input.Init()
}

type projEQInt16Float64Op struct {
	projOpBase
}

func (p projEQInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16Float64Op) Init() {
	p.input.Init()
}

type projEQInt16DecimalOp struct {
	projOpBase
}

func (p projEQInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16DecimalOp) Init() {
	p.input.Init()
}

type projEQInt32Int16Op struct {
	projOpBase
}

func (p projEQInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32Int16Op) Init() {
	p.input.Init()
}

type projEQInt32Int32Op struct {
	projOpBase
}

func (p projEQInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32Int32Op) Init() {
	p.input.Init()
}

type projEQInt32Int64Op struct {
	projOpBase
}

func (p projEQInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32Int64Op) Init() {
	p.input.Init()
}

type projEQInt32Float64Op struct {
	projOpBase
}

func (p projEQInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32Float64Op) Init() {
	p.input.Init()
}

type projEQInt32DecimalOp struct {
	projOpBase
}

func (p projEQInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32DecimalOp) Init() {
	p.input.Init()
}

type projEQInt64Int16Op struct {
	projOpBase
}

func (p projEQInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64Int16Op) Init() {
	p.input.Init()
}

type projEQInt64Int32Op struct {
	projOpBase
}

func (p projEQInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64Int32Op) Init() {
	p.input.Init()
}

type projEQInt64Int64Op struct {
	projOpBase
}

func (p projEQInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64Int64Op) Init() {
	p.input.Init()
}

type projEQInt64Float64Op struct {
	projOpBase
}

func (p projEQInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64Float64Op) Init() {
	p.input.Init()
}

type projEQInt64DecimalOp struct {
	projOpBase
}

func (p projEQInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64DecimalOp) Init() {
	p.input.Init()
}

type projEQFloat64Int16Op struct {
	projOpBase
}

func (p projEQFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64Int16Op) Init() {
	p.input.Init()
}

type projEQFloat64Int32Op struct {
	projOpBase
}

func (p projEQFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64Int32Op) Init() {
	p.input.Init()
}

type projEQFloat64Int64Op struct {
	projOpBase
}

func (p projEQFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64Int64Op) Init() {
	p.input.Init()
}

type projEQFloat64Float64Op struct {
	projOpBase
}

func (p projEQFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64Float64Op) Init() {
	p.input.Init()
}

type projEQFloat64DecimalOp struct {
	projOpBase
}

func (p projEQFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64DecimalOp) Init() {
	p.input.Init()
}

type projEQTimestampTimestampOp struct {
	projOpBase
}

func (p projEQTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQTimestampTimestampOp) Init() {
	p.input.Init()
}

type projEQIntervalIntervalOp struct {
	projOpBase
}

func (p projEQIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQIntervalIntervalOp) Init() {
	p.input.Init()
}

type projEQDatumDatumOp struct {
	projOpBase
}

func (p projEQDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult == 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDatumDatumOp) Init() {
	p.input.Init()
}

type projNEBoolBoolOp struct {
	projOpBase
}

func (p projNEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEBoolBoolOp) Init() {
	p.input.Init()
}

type projNEBytesBytesOp struct {
	projOpBase
}

func (p projNEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEBytesBytesOp) Init() {
	p.input.Init()
}

type projNEDecimalInt16Op struct {
	projOpBase
}

func (p projNEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalInt16Op) Init() {
	p.input.Init()
}

type projNEDecimalInt32Op struct {
	projOpBase
}

func (p projNEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalInt32Op) Init() {
	p.input.Init()
}

type projNEDecimalInt64Op struct {
	projOpBase
}

func (p projNEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalInt64Op) Init() {
	p.input.Init()
}

type projNEDecimalFloat64Op struct {
	projOpBase
}

func (p projNEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projNEDecimalDecimalOp struct {
	projOpBase
}

func (p projNEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projNEInt16Int16Op struct {
	projOpBase
}

func (p projNEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16Int16Op) Init() {
	p.input.Init()
}

type projNEInt16Int32Op struct {
	projOpBase
}

func (p projNEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16Int32Op) Init() {
	p.input.Init()
}

type projNEInt16Int64Op struct {
	projOpBase
}

func (p projNEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16Int64Op) Init() {
	p.input.Init()
}

type projNEInt16Float64Op struct {
	projOpBase
}

func (p projNEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16Float64Op) Init() {
	p.input.Init()
}

type projNEInt16DecimalOp struct {
	projOpBase
}

func (p projNEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16DecimalOp) Init() {
	p.input.Init()
}

type projNEInt32Int16Op struct {
	projOpBase
}

func (p projNEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32Int16Op) Init() {
	p.input.Init()
}

type projNEInt32Int32Op struct {
	projOpBase
}

func (p projNEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32Int32Op) Init() {
	p.input.Init()
}

type projNEInt32Int64Op struct {
	projOpBase
}

func (p projNEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32Int64Op) Init() {
	p.input.Init()
}

type projNEInt32Float64Op struct {
	projOpBase
}

func (p projNEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32Float64Op) Init() {
	p.input.Init()
}

type projNEInt32DecimalOp struct {
	projOpBase
}

func (p projNEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32DecimalOp) Init() {
	p.input.Init()
}

type projNEInt64Int16Op struct {
	projOpBase
}

func (p projNEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64Int16Op) Init() {
	p.input.Init()
}

type projNEInt64Int32Op struct {
	projOpBase
}

func (p projNEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64Int32Op) Init() {
	p.input.Init()
}

type projNEInt64Int64Op struct {
	projOpBase
}

func (p projNEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64Int64Op) Init() {
	p.input.Init()
}

type projNEInt64Float64Op struct {
	projOpBase
}

func (p projNEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64Float64Op) Init() {
	p.input.Init()
}

type projNEInt64DecimalOp struct {
	projOpBase
}

func (p projNEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64DecimalOp) Init() {
	p.input.Init()
}

type projNEFloat64Int16Op struct {
	projOpBase
}

func (p projNEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64Int16Op) Init() {
	p.input.Init()
}

type projNEFloat64Int32Op struct {
	projOpBase
}

func (p projNEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64Int32Op) Init() {
	p.input.Init()
}

type projNEFloat64Int64Op struct {
	projOpBase
}

func (p projNEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64Int64Op) Init() {
	p.input.Init()
}

type projNEFloat64Float64Op struct {
	projOpBase
}

func (p projNEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64Float64Op) Init() {
	p.input.Init()
}

type projNEFloat64DecimalOp struct {
	projOpBase
}

func (p projNEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projNETimestampTimestampOp struct {
	projOpBase
}

func (p projNETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNETimestampTimestampOp) Init() {
	p.input.Init()
}

type projNEIntervalIntervalOp struct {
	projOpBase
}

func (p projNEIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEIntervalIntervalOp) Init() {
	p.input.Init()
}

type projNEDatumDatumOp struct {
	projOpBase
}

func (p projNEDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult != 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDatumDatumOp) Init() {
	p.input.Init()
}

type projLTBoolBoolOp struct {
	projOpBase
}

func (p projLTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTBoolBoolOp) Init() {
	p.input.Init()
}

type projLTBytesBytesOp struct {
	projOpBase
}

func (p projLTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTBytesBytesOp) Init() {
	p.input.Init()
}

type projLTDecimalInt16Op struct {
	projOpBase
}

func (p projLTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalInt16Op) Init() {
	p.input.Init()
}

type projLTDecimalInt32Op struct {
	projOpBase
}

func (p projLTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalInt32Op) Init() {
	p.input.Init()
}

type projLTDecimalInt64Op struct {
	projOpBase
}

func (p projLTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalInt64Op) Init() {
	p.input.Init()
}

type projLTDecimalFloat64Op struct {
	projOpBase
}

func (p projLTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalFloat64Op) Init() {
	p.input.Init()
}

type projLTDecimalDecimalOp struct {
	projOpBase
}

func (p projLTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalDecimalOp) Init() {
	p.input.Init()
}

type projLTInt16Int16Op struct {
	projOpBase
}

func (p projLTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16Int16Op) Init() {
	p.input.Init()
}

type projLTInt16Int32Op struct {
	projOpBase
}

func (p projLTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16Int32Op) Init() {
	p.input.Init()
}

type projLTInt16Int64Op struct {
	projOpBase
}

func (p projLTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16Int64Op) Init() {
	p.input.Init()
}

type projLTInt16Float64Op struct {
	projOpBase
}

func (p projLTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16Float64Op) Init() {
	p.input.Init()
}

type projLTInt16DecimalOp struct {
	projOpBase
}

func (p projLTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16DecimalOp) Init() {
	p.input.Init()
}

type projLTInt32Int16Op struct {
	projOpBase
}

func (p projLTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32Int16Op) Init() {
	p.input.Init()
}

type projLTInt32Int32Op struct {
	projOpBase
}

func (p projLTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32Int32Op) Init() {
	p.input.Init()
}

type projLTInt32Int64Op struct {
	projOpBase
}

func (p projLTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32Int64Op) Init() {
	p.input.Init()
}

type projLTInt32Float64Op struct {
	projOpBase
}

func (p projLTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32Float64Op) Init() {
	p.input.Init()
}

type projLTInt32DecimalOp struct {
	projOpBase
}

func (p projLTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32DecimalOp) Init() {
	p.input.Init()
}

type projLTInt64Int16Op struct {
	projOpBase
}

func (p projLTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64Int16Op) Init() {
	p.input.Init()
}

type projLTInt64Int32Op struct {
	projOpBase
}

func (p projLTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64Int32Op) Init() {
	p.input.Init()
}

type projLTInt64Int64Op struct {
	projOpBase
}

func (p projLTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64Int64Op) Init() {
	p.input.Init()
}

type projLTInt64Float64Op struct {
	projOpBase
}

func (p projLTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64Float64Op) Init() {
	p.input.Init()
}

type projLTInt64DecimalOp struct {
	projOpBase
}

func (p projLTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64DecimalOp) Init() {
	p.input.Init()
}

type projLTFloat64Int16Op struct {
	projOpBase
}

func (p projLTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64Int16Op) Init() {
	p.input.Init()
}

type projLTFloat64Int32Op struct {
	projOpBase
}

func (p projLTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64Int32Op) Init() {
	p.input.Init()
}

type projLTFloat64Int64Op struct {
	projOpBase
}

func (p projLTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64Int64Op) Init() {
	p.input.Init()
}

type projLTFloat64Float64Op struct {
	projOpBase
}

func (p projLTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64Float64Op) Init() {
	p.input.Init()
}

type projLTFloat64DecimalOp struct {
	projOpBase
}

func (p projLTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64DecimalOp) Init() {
	p.input.Init()
}

type projLTTimestampTimestampOp struct {
	projOpBase
}

func (p projLTTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTTimestampTimestampOp) Init() {
	p.input.Init()
}

type projLTIntervalIntervalOp struct {
	projOpBase
}

func (p projLTIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTIntervalIntervalOp) Init() {
	p.input.Init()
}

type projLTDatumDatumOp struct {
	projOpBase
}

func (p projLTDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult < 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDatumDatumOp) Init() {
	p.input.Init()
}

type projLEBoolBoolOp struct {
	projOpBase
}

func (p projLEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEBoolBoolOp) Init() {
	p.input.Init()
}

type projLEBytesBytesOp struct {
	projOpBase
}

func (p projLEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEBytesBytesOp) Init() {
	p.input.Init()
}

type projLEDecimalInt16Op struct {
	projOpBase
}

func (p projLEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalInt16Op) Init() {
	p.input.Init()
}

type projLEDecimalInt32Op struct {
	projOpBase
}

func (p projLEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalInt32Op) Init() {
	p.input.Init()
}

type projLEDecimalInt64Op struct {
	projOpBase
}

func (p projLEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalInt64Op) Init() {
	p.input.Init()
}

type projLEDecimalFloat64Op struct {
	projOpBase
}

func (p projLEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projLEDecimalDecimalOp struct {
	projOpBase
}

func (p projLEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projLEInt16Int16Op struct {
	projOpBase
}

func (p projLEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16Int16Op) Init() {
	p.input.Init()
}

type projLEInt16Int32Op struct {
	projOpBase
}

func (p projLEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16Int32Op) Init() {
	p.input.Init()
}

type projLEInt16Int64Op struct {
	projOpBase
}

func (p projLEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16Int64Op) Init() {
	p.input.Init()
}

type projLEInt16Float64Op struct {
	projOpBase
}

func (p projLEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16Float64Op) Init() {
	p.input.Init()
}

type projLEInt16DecimalOp struct {
	projOpBase
}

func (p projLEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16DecimalOp) Init() {
	p.input.Init()
}

type projLEInt32Int16Op struct {
	projOpBase
}

func (p projLEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32Int16Op) Init() {
	p.input.Init()
}

type projLEInt32Int32Op struct {
	projOpBase
}

func (p projLEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32Int32Op) Init() {
	p.input.Init()
}

type projLEInt32Int64Op struct {
	projOpBase
}

func (p projLEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32Int64Op) Init() {
	p.input.Init()
}

type projLEInt32Float64Op struct {
	projOpBase
}

func (p projLEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32Float64Op) Init() {
	p.input.Init()
}

type projLEInt32DecimalOp struct {
	projOpBase
}

func (p projLEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32DecimalOp) Init() {
	p.input.Init()
}

type projLEInt64Int16Op struct {
	projOpBase
}

func (p projLEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64Int16Op) Init() {
	p.input.Init()
}

type projLEInt64Int32Op struct {
	projOpBase
}

func (p projLEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64Int32Op) Init() {
	p.input.Init()
}

type projLEInt64Int64Op struct {
	projOpBase
}

func (p projLEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64Int64Op) Init() {
	p.input.Init()
}

type projLEInt64Float64Op struct {
	projOpBase
}

func (p projLEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64Float64Op) Init() {
	p.input.Init()
}

type projLEInt64DecimalOp struct {
	projOpBase
}

func (p projLEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64DecimalOp) Init() {
	p.input.Init()
}

type projLEFloat64Int16Op struct {
	projOpBase
}

func (p projLEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64Int16Op) Init() {
	p.input.Init()
}

type projLEFloat64Int32Op struct {
	projOpBase
}

func (p projLEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64Int32Op) Init() {
	p.input.Init()
}

type projLEFloat64Int64Op struct {
	projOpBase
}

func (p projLEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64Int64Op) Init() {
	p.input.Init()
}

type projLEFloat64Float64Op struct {
	projOpBase
}

func (p projLEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64Float64Op) Init() {
	p.input.Init()
}

type projLEFloat64DecimalOp struct {
	projOpBase
}

func (p projLEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projLETimestampTimestampOp struct {
	projOpBase
}

func (p projLETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLETimestampTimestampOp) Init() {
	p.input.Init()
}

type projLEIntervalIntervalOp struct {
	projOpBase
}

func (p projLEIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEIntervalIntervalOp) Init() {
	p.input.Init()
}

type projLEDatumDatumOp struct {
	projOpBase
}

func (p projLEDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDatumDatumOp) Init() {
	p.input.Init()
}

type projGTBoolBoolOp struct {
	projOpBase
}

func (p projGTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTBoolBoolOp) Init() {
	p.input.Init()
}

type projGTBytesBytesOp struct {
	projOpBase
}

func (p projGTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTBytesBytesOp) Init() {
	p.input.Init()
}

type projGTDecimalInt16Op struct {
	projOpBase
}

func (p projGTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalInt16Op) Init() {
	p.input.Init()
}

type projGTDecimalInt32Op struct {
	projOpBase
}

func (p projGTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalInt32Op) Init() {
	p.input.Init()
}

type projGTDecimalInt64Op struct {
	projOpBase
}

func (p projGTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalInt64Op) Init() {
	p.input.Init()
}

type projGTDecimalFloat64Op struct {
	projOpBase
}

func (p projGTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalFloat64Op) Init() {
	p.input.Init()
}

type projGTDecimalDecimalOp struct {
	projOpBase
}

func (p projGTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalDecimalOp) Init() {
	p.input.Init()
}

type projGTInt16Int16Op struct {
	projOpBase
}

func (p projGTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16Int16Op) Init() {
	p.input.Init()
}

type projGTInt16Int32Op struct {
	projOpBase
}

func (p projGTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16Int32Op) Init() {
	p.input.Init()
}

type projGTInt16Int64Op struct {
	projOpBase
}

func (p projGTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16Int64Op) Init() {
	p.input.Init()
}

type projGTInt16Float64Op struct {
	projOpBase
}

func (p projGTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16Float64Op) Init() {
	p.input.Init()
}

type projGTInt16DecimalOp struct {
	projOpBase
}

func (p projGTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16DecimalOp) Init() {
	p.input.Init()
}

type projGTInt32Int16Op struct {
	projOpBase
}

func (p projGTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32Int16Op) Init() {
	p.input.Init()
}

type projGTInt32Int32Op struct {
	projOpBase
}

func (p projGTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32Int32Op) Init() {
	p.input.Init()
}

type projGTInt32Int64Op struct {
	projOpBase
}

func (p projGTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32Int64Op) Init() {
	p.input.Init()
}

type projGTInt32Float64Op struct {
	projOpBase
}

func (p projGTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32Float64Op) Init() {
	p.input.Init()
}

type projGTInt32DecimalOp struct {
	projOpBase
}

func (p projGTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32DecimalOp) Init() {
	p.input.Init()
}

type projGTInt64Int16Op struct {
	projOpBase
}

func (p projGTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64Int16Op) Init() {
	p.input.Init()
}

type projGTInt64Int32Op struct {
	projOpBase
}

func (p projGTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64Int32Op) Init() {
	p.input.Init()
}

type projGTInt64Int64Op struct {
	projOpBase
}

func (p projGTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64Int64Op) Init() {
	p.input.Init()
}

type projGTInt64Float64Op struct {
	projOpBase
}

func (p projGTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64Float64Op) Init() {
	p.input.Init()
}

type projGTInt64DecimalOp struct {
	projOpBase
}

func (p projGTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64DecimalOp) Init() {
	p.input.Init()
}

type projGTFloat64Int16Op struct {
	projOpBase
}

func (p projGTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64Int16Op) Init() {
	p.input.Init()
}

type projGTFloat64Int32Op struct {
	projOpBase
}

func (p projGTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64Int32Op) Init() {
	p.input.Init()
}

type projGTFloat64Int64Op struct {
	projOpBase
}

func (p projGTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64Int64Op) Init() {
	p.input.Init()
}

type projGTFloat64Float64Op struct {
	projOpBase
}

func (p projGTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64Float64Op) Init() {
	p.input.Init()
}

type projGTFloat64DecimalOp struct {
	projOpBase
}

func (p projGTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64DecimalOp) Init() {
	p.input.Init()
}

type projGTTimestampTimestampOp struct {
	projOpBase
}

func (p projGTTimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTTimestampTimestampOp) Init() {
	p.input.Init()
}

type projGTIntervalIntervalOp struct {
	projOpBase
}

func (p projGTIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTIntervalIntervalOp) Init() {
	p.input.Init()
}

type projGTDatumDatumOp struct {
	projOpBase
}

func (p projGTDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult > 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDatumDatumOp) Init() {
	p.input.Init()
}

type projGEBoolBoolOp struct {
	projOpBase
}

func (p projGEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if !arg1 && arg2 {
						cmpResult = -1
					} else if arg1 && !arg2 {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEBoolBoolOp) Init() {
	p.input.Init()
}

type projGEBytesBytesOp struct {
	projOpBase
}

func (p projGEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = bytes.Compare(arg1, arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEBytesBytesOp) Init() {
	p.input.Init()
}

type projGEDecimalInt16Op struct {
	projOpBase
}

func (p projGEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalInt16Op) Init() {
	p.input.Init()
}

type projGEDecimalInt32Op struct {
	projOpBase
}

func (p projGEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalInt32Op) Init() {
	p.input.Init()
}

type projGEDecimalInt64Op struct {
	projOpBase
}

func (p projGEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg2))
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalInt64Op) Init() {
	p.input.Init()
}

type projGEDecimalFloat64Op struct {
	projOpBase
}

func (p projGEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&arg1, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projGEDecimalDecimalOp struct {
	projOpBase
}

func (p projGEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&arg1, &arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projGEInt16Int16Op struct {
	projOpBase
}

func (p projGEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16Int16Op) Init() {
	p.input.Init()
}

type projGEInt16Int32Op struct {
	projOpBase
}

func (p projGEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16Int32Op) Init() {
	p.input.Init()
}

type projGEInt16Int64Op struct {
	projOpBase
}

func (p projGEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16Int64Op) Init() {
	p.input.Init()
}

type projGEInt16Float64Op struct {
	projOpBase
}

func (p projGEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16Float64Op) Init() {
	p.input.Init()
}

type projGEInt16DecimalOp struct {
	projOpBase
}

func (p projGEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16DecimalOp) Init() {
	p.input.Init()
}

type projGEInt32Int16Op struct {
	projOpBase
}

func (p projGEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32Int16Op) Init() {
	p.input.Init()
}

type projGEInt32Int32Op struct {
	projOpBase
}

func (p projGEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32Int32Op) Init() {
	p.input.Init()
}

type projGEInt32Int64Op struct {
	projOpBase
}

func (p projGEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32Int64Op) Init() {
	p.input.Init()
}

type projGEInt32Float64Op struct {
	projOpBase
}

func (p projGEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32Float64Op) Init() {
	p.input.Init()
}

type projGEInt32DecimalOp struct {
	projOpBase
}

func (p projGEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32DecimalOp) Init() {
	p.input.Init()
}

type projGEInt64Int16Op struct {
	projOpBase
}

func (p projGEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64Int16Op) Init() {
	p.input.Init()
}

type projGEInt64Int32Op struct {
	projOpBase
}

func (p projGEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64Int32Op) Init() {
	p.input.Init()
}

type projGEInt64Int64Op struct {
	projOpBase
}

func (p projGEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := int64(arg1), int64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64Int64Op) Init() {
	p.input.Init()
}

type projGEInt64Float64Op struct {
	projOpBase
}

func (p projGEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64Float64Op) Init() {
	p.input.Init()
}

type projGEInt64DecimalOp struct {
	projOpBase
}

func (p projGEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg1))
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64DecimalOp) Init() {
	p.input.Init()
}

type projGEFloat64Int16Op struct {
	projOpBase
}

func (p projGEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64Int16Op) Init() {
	p.input.Init()
}

type projGEFloat64Int32Op struct {
	projOpBase
}

func (p projGEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64Int32Op) Init() {
	p.input.Init()
}

type projGEFloat64Int64Op struct {
	projOpBase
}

func (p projGEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64Int64Op) Init() {
	p.input.Init()
}

type projGEFloat64Float64Op struct {
	projOpBase
}

func (p projGEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						a, b := float64(arg1), float64(arg2)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64Float64Op) Init() {
	p.input.Init()
}

type projGEFloat64DecimalOp struct {
	projOpBase
}

func (p projGEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg2)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projGETimestampTimestampOp struct {
	projOpBase
}

func (p projGETimestampTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Timestamp()
	col2 := vec2.Timestamp()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int

					if arg1.Before(arg2) {
						cmpResult = -1
					} else if arg2.Before(arg1) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGETimestampTimestampOp) Init() {
	p.input.Init()
}

type projGEIntervalIntervalOp struct {
	projOpBase
}

func (p projGEIntervalIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Interval()
	col2 := vec2.Interval()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i) //gcassert:inline
					arg2 := col2.Get(i) //gcassert:inline

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1[0:n]
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)    //gcassert:inline
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i) //gcassert:inline
				arg2 := col2.Get(i) //gcassert:inline

				{
					var cmpResult int
					cmpResult = arg1.Compare(arg2)
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEIntervalIntervalOp) Init() {
	p.input.Init()
}

type projGEDatumDatumOp struct {
	projOpBase
}

func (p projGEDatumDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Datum()
	col2 := vec2.Datum()
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		col1Nulls := vec1.Nulls()
		col2Nulls := vec2.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
					// We only want to perform the projection operation if both values are not
					// null.
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		projVec.SetNulls(col1Nulls.Or(col2Nulls))
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col1 = col1.Slice(0, n)
			colLen := col1.Len()
			_ = projCol.Get(colLen - 1) //gcassert:inline
			_ = col2.Get(colLen - 1)
			for i := 0; i < n; i++ {
				arg1 := col1.Get(i)
				arg2 := col2.Get(i)

				{
					var cmpResult int

					cmpResult = arg1.(*coldataext.Datum).CompareDatum(col1, arg2)

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}

	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDatumDatumOp) Init() {
	p.input.Init()
}

// GetProjectionOperator returns the appropriate projection operator for the
// given left and right column types and operation.
func GetProjectionOperator(
	allocator *colmem.Allocator,
	leftType *types.T,
	rightType *types.T,
	outputType *types.T,
	op tree.Operator,
	input colexecbase.Operator,
	col1Idx int,
	col2Idx int,
	outputIdx int,
	binFn *tree.BinOp,
	evalCtx *tree.EvalContext,
) (colexecbase.Operator, error) {
	input = newVectorTypeEnforcer(allocator, input, outputType, outputIdx)
	projOpBase := projOpBase{
		OneInputNode:   NewOneInputNode(input),
		allocator:      allocator,
		col1Idx:        col1Idx,
		col2Idx:        col2Idx,
		outputIdx:      outputIdx,
		overloadHelper: overloadHelper{binFn: binFn, evalCtx: evalCtx},
	}

	switch op.(type) {
	case tree.BinaryOperator:
		switch op {
		case tree.Bitand:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitandInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitandInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitandInt16Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitandInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitandInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitandInt32Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitandInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitandInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitandInt64Int64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projBitandDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Bitor:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitorInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitorInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitorInt16Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitorInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitorInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitorInt32Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitorInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitorInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitorInt64Int64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projBitorDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Bitxor:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitxorInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitxorInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitxorInt16Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitxorInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitxorInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitxorInt32Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitxorInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projBitxorInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projBitxorInt64Int64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projBitxorDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Plus:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPlusDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPlusDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPlusInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPlusInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt16DatumOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPlusInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPlusInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt32DatumOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPlusInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPlusInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt64DatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusTimestampIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusIntervalTimestampOp{projOpBase: projOpBase}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusIntervalIntervalOp{projOpBase: projOpBase}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusIntervalDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusDatumIntervalOp{projOpBase: projOpBase}, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusDatumInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPlusDatumInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPlusDatumInt64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Minus:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMinusDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMinusDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMinusInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMinusInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt16DatumOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMinusInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMinusInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt32DatumOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMinusInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMinusInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt64DatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusTimestampTimestampOp{projOpBase: projOpBase}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusTimestampIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusIntervalIntervalOp{projOpBase: projOpBase}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusIntervalDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusDatumDatumOp{projOpBase: projOpBase}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusDatumIntervalOp{projOpBase: projOpBase}, nil
						}
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusDatumBytesOp{projOpBase: projOpBase}, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusDatumInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMinusDatumInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMinusDatumInt64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Mult:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMultDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMultDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultDecimalIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMultInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMultInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt16IntervalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMultInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMultInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt32IntervalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMultInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMultInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt64IntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultFloat64IntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultIntervalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projMultIntervalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projMultIntervalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultIntervalFloat64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultIntervalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Div:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projDivDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projDivDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projDivDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projDivInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projDivInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projDivInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projDivInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projDivInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projDivInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projDivInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projDivInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projDivInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivIntervalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivIntervalFloat64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.FloorDiv:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projFloorDivDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projFloorDivDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projFloorDivDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projFloorDivInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projFloorDivInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projFloorDivInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projFloorDivInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projFloorDivInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projFloorDivInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projFloorDivInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projFloorDivInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projFloorDivInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Mod:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projModDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projModDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projModDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projModInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projModInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projModInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projModInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projModInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projModInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projModInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projModInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projModInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Pow:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPowDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPowDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPowDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPowInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPowInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPowInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPowInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPowInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPowInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPowInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projPowInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projPowInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.Concat:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projConcatBytesBytesOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projConcatDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.LShift:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLShiftInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLShiftInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLShiftInt16Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLShiftInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLShiftInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLShiftInt32Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLShiftInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLShiftInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLShiftInt64Int64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLShiftDatumInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLShiftDatumInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLShiftDatumInt64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.RShift:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projRShiftInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projRShiftInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projRShiftInt16Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projRShiftInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projRShiftInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projRShiftInt32Int64Op{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projRShiftInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projRShiftInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projRShiftInt64Int64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projRShiftDatumInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projRShiftDatumInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projRShiftDatumInt64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.JSONFetchVal:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projJSONFetchValDatumBytesOp{projOpBase: projOpBase}, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projJSONFetchValDatumInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projJSONFetchValDatumInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projJSONFetchValDatumInt64Op{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		}
	case tree.ComparisonOperator:
		switch op {
		case tree.EQ:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQBoolBoolOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQBytesBytesOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projEQDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projEQDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQDecimalFloat64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projEQInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projEQInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt16Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projEQInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projEQInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt32Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projEQInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projEQInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQFloat64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projEQFloat64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projEQFloat64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQFloat64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQTimestampTimestampOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQIntervalIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.NE:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEBoolBoolOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEBytesBytesOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projNEDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projNEDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEDecimalFloat64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projNEInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projNEInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt16Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projNEInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projNEInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt32Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projNEInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projNEInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEFloat64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projNEFloat64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projNEFloat64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEFloat64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNETimestampTimestampOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEIntervalIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.LT:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTBoolBoolOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTBytesBytesOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLTDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLTDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTDecimalFloat64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLTInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLTInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt16Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLTInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLTInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt32Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLTInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLTInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTFloat64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLTFloat64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLTFloat64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTFloat64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTTimestampTimestampOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTIntervalIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.LE:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEBoolBoolOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEBytesBytesOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLEDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLEDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEDecimalFloat64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLEInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLEInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt16Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLEInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLEInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt32Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLEInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLEInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEFloat64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projLEFloat64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projLEFloat64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEFloat64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLETimestampTimestampOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEIntervalIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.GT:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTBoolBoolOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTBytesBytesOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGTDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGTDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTDecimalFloat64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGTInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGTInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt16Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGTInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGTInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt32Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGTInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGTInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTFloat64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGTFloat64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGTFloat64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTFloat64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTTimestampTimestampOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTIntervalIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		case tree.GE:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEBoolBoolOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEBytesBytesOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEDecimalInt16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGEDecimalInt32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGEDecimalInt64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEDecimalFloat64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEDecimalDecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEInt16Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGEInt16Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGEInt16Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt16Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt16DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEInt32Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGEInt32Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGEInt32Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt32Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt32DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEInt64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGEInt64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGEInt64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEFloat64Int16Op{projOpBase: projOpBase}, nil
						case 32:
							return &projGEFloat64Int32Op{projOpBase: projOpBase}, nil
						case -1:
						default:
							return &projGEFloat64Int64Op{projOpBase: projOpBase}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEFloat64Float64Op{projOpBase: projOpBase}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEFloat64DecimalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGETimestampTimestampOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEIntervalIntervalOp{projOpBase: projOpBase}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEDatumDatumOp{projOpBase: projOpBase}, nil
						}
					}
				}
			}
		}
	}
	return nil, errors.Errorf("couldn't find overload for %s %s %s", leftType.Name(), op, rightType.Name())
}
