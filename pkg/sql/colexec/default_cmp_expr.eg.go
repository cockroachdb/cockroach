// Code generated by execgen; DO NOT EDIT.
// Copyright 2020 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/errors"
)

// comparisonExprAdapter is a utility interface that is implemented by several
// structs that behave as an adapter from tree.ComparisonExpr to a vectorized
// friendly model.
type comparisonExprAdapter interface {
	eval(left, right tree.Datum) (tree.Datum, error)
}

func newComparisonExprAdapter(
	expr *tree.ComparisonExpr, evalCtx *tree.EvalContext,
) comparisonExprAdapter {
	base := cmpExprAdapterBase{
		fn:      expr.Fn.Fn,
		evalCtx: evalCtx,
	}
	op := expr.Operator
	if op.HasSubOperator() {
		return &cmpWithSubOperatorExprAdapter{
			cmpExprAdapterBase: base,
			expr:               expr,
		}
	}
	nullable := expr.Fn.NullableArgs
	_, _, _, flipped, negate := tree.FoldComparisonExpr(op, nil /* left */, nil /* right */)
	if nullable {
		if flipped {
			if negate {
				return &cmpNullableFlippedNegateExprAdapter{cmpExprAdapterBase: base}
			}
			return &cmpNullableFlippedExprAdapter{cmpExprAdapterBase: base}
		} else {
			if negate {
				return &cmpNullableNegateExprAdapter{cmpExprAdapterBase: base}
			}
			return &cmpNullableExprAdapter{cmpExprAdapterBase: base}
		}
	}
	if flipped {
		if negate {
			return &cmpFlippedNegateExprAdapter{cmpExprAdapterBase: base}
		}
		return &cmpFlippedExprAdapter{cmpExprAdapterBase: base}
	}
	if negate {
		return &cmpNegateExprAdapter{cmpExprAdapterBase: base}
	}
	return &cmpExprAdapter{cmpExprAdapterBase: base}
}

type cmpExprAdapterBase struct {
	fn      tree.TwoArgFn
	evalCtx *tree.EvalContext
}

type cmpExprAdapter struct {
	cmpExprAdapterBase
}

var _ comparisonExprAdapter = &cmpExprAdapter{}

func (c *cmpExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	if left == tree.DNull || right == tree.DNull {
		return tree.DNull, nil
	}
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(*b)
	return result, nil
}

type cmpNegateExprAdapter struct {
	cmpExprAdapterBase
}

var _ comparisonExprAdapter = &cmpNegateExprAdapter{}

func (c *cmpNegateExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	if left == tree.DNull || right == tree.DNull {
		return tree.DNull, nil
	}
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(!*b)
	return result, nil
}

type cmpFlippedExprAdapter struct {
	cmpExprAdapterBase
}

var _ comparisonExprAdapter = &cmpFlippedExprAdapter{}

func (c *cmpFlippedExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	if left == tree.DNull || right == tree.DNull {
		return tree.DNull, nil
	}
	left, right = right, left
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(*b)
	return result, nil
}

type cmpFlippedNegateExprAdapter struct {
	cmpExprAdapterBase
}

var _ comparisonExprAdapter = &cmpFlippedNegateExprAdapter{}

func (c *cmpFlippedNegateExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	if left == tree.DNull || right == tree.DNull {
		return tree.DNull, nil
	}
	left, right = right, left
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(!*b)
	return result, nil
}

type cmpNullableExprAdapter struct {
	cmpExprAdapterBase
}

var _ comparisonExprAdapter = &cmpNullableExprAdapter{}

func (c *cmpNullableExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(*b)
	return result, nil
}

type cmpNullableNegateExprAdapter struct {
	cmpExprAdapterBase
}

var _ comparisonExprAdapter = &cmpNullableNegateExprAdapter{}

func (c *cmpNullableNegateExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(!*b)
	return result, nil
}

type cmpNullableFlippedExprAdapter struct {
	cmpExprAdapterBase
}

var _ comparisonExprAdapter = &cmpNullableFlippedExprAdapter{}

func (c *cmpNullableFlippedExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	left, right = right, left
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(*b)
	return result, nil
}

type cmpNullableFlippedNegateExprAdapter struct {
	cmpExprAdapterBase
}

var _ comparisonExprAdapter = &cmpNullableFlippedNegateExprAdapter{}

func (c *cmpNullableFlippedNegateExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	left, right = right, left
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(!*b)
	return result, nil
}

type cmpWithSubOperatorExprAdapter struct {
	cmpExprAdapterBase
	expr *tree.ComparisonExpr
}

var _ comparisonExprAdapter = &cmpWithSubOperatorExprAdapter{}

func (c *cmpWithSubOperatorExprAdapter) eval(left, right tree.Datum) (tree.Datum, error) {
	return tree.EvalComparisonExprWithSubOperator(c.evalCtx, c.expr, left, right)
}
