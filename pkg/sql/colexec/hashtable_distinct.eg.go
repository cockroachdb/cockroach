// Code generated by execgen; DO NOT EDIT.
// Copyright 2020 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"math"

	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
)

// checkColAgainstItself is similar to checkCol, but it probes the vector
// against itself.
func (ht *hashTable) checkColAgainstItself(vec coldata.Vec, nToCheck uint64, sel []int) {
	probeVec, buildVec, probeSel := vec, vec, sel
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := ht.overloadHelper
	switch probeVec.CanonicalTypeFamily() {
	case types.BoolFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch buildVec.CanonicalTypeFamily() {
			case types.BoolFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Bool()
					buildKeys := buildVec.Bool()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													if !probeVal && buildVal {
														cmpResult = -1
													} else if probeVal && !buildVal {
														cmpResult = 1
													} else {
														cmpResult = 0
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													if !probeVal && buildVal {
														cmpResult = -1
													} else if probeVal && !buildVal {
														cmpResult = 1
													} else {
														cmpResult = 0
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													if !probeVal && buildVal {
														cmpResult = -1
													} else if probeVal && !buildVal {
														cmpResult = 1
													} else {
														cmpResult = 0
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													if !probeVal && buildVal {
														cmpResult = -1
													} else if probeVal && !buildVal {
														cmpResult = 1
													} else {
														cmpResult = 0
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case types.BytesFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch buildVec.CanonicalTypeFamily() {
			case types.BytesFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Bytes()
					buildKeys := buildVec.Bytes()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = bytes.Compare(probeVal, buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = bytes.Compare(probeVal, buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = bytes.Compare(probeVal, buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = bytes.Compare(probeVal, buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case types.DecimalFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch buildVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch buildVec.Type().Width() {
				case 16:
					probeKeys := probeVec.Decimal()
					buildKeys := buildVec.Int16()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case 32:
					probeKeys := probeVec.Decimal()
					buildKeys := buildVec.Int32()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case -1:
				default:
					probeKeys := probeVec.Decimal()
					buildKeys := buildVec.Int64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(buildVal))
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(buildVal))
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.FloatFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Decimal()
					buildKeys := buildVec.Float64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
															colexecerror.ExpectedError(err)
														}
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
															colexecerror.ExpectedError(err)
														}
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
															colexecerror.ExpectedError(err)
														}
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
															colexecerror.ExpectedError(err)
														}
														cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.DecimalFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Decimal()
					buildKeys := buildVec.Decimal()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case types.IntFamily:
		switch probeVec.Type().Width() {
		case 16:
			switch buildVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch buildVec.Type().Width() {
				case 16:
					probeKeys := probeVec.Int16()
					buildKeys := buildVec.Int16()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case 32:
					probeKeys := probeVec.Int16()
					buildKeys := buildVec.Int32()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case -1:
				default:
					probeKeys := probeVec.Int16()
					buildKeys := buildVec.Int64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.FloatFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Int16()
					buildKeys := buildVec.Float64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.DecimalFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Int16()
					buildKeys := buildVec.Decimal()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		case 32:
			switch buildVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch buildVec.Type().Width() {
				case 16:
					probeKeys := probeVec.Int32()
					buildKeys := buildVec.Int16()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case 32:
					probeKeys := probeVec.Int32()
					buildKeys := buildVec.Int32()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case -1:
				default:
					probeKeys := probeVec.Int32()
					buildKeys := buildVec.Int64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.FloatFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Int32()
					buildKeys := buildVec.Float64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.DecimalFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Int32()
					buildKeys := buildVec.Decimal()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		case -1:
		default:
			switch buildVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch buildVec.Type().Width() {
				case 16:
					probeKeys := probeVec.Int64()
					buildKeys := buildVec.Int16()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case 32:
					probeKeys := probeVec.Int64()
					buildKeys := buildVec.Int32()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case -1:
				default:
					probeKeys := probeVec.Int64()
					buildKeys := buildVec.Int64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := int64(probeVal), int64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else {
															cmpResult = 0
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.FloatFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Int64()
					buildKeys := buildVec.Float64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if false {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.DecimalFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Int64()
					buildKeys := buildVec.Decimal()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														tmpDec.SetInt64(int64(probeVal))
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													tmpDec.SetInt64(int64(probeVal))
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case types.FloatFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch buildVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch buildVec.Type().Width() {
				case 16:
					probeKeys := probeVec.Float64()
					buildKeys := buildVec.Int16()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case 32:
					probeKeys := probeVec.Float64()
					buildKeys := buildVec.Int32()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				case -1:
				default:
					probeKeys := probeVec.Float64()
					buildKeys := buildVec.Int64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if false {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.FloatFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Float64()
					buildKeys := buildVec.Float64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														a, b := float64(probeVal), float64(buildVal)
														if a < b {
															cmpResult = -1
														} else if a > b {
															cmpResult = 1
														} else if a == b {
															cmpResult = 0
														} else if math.IsNaN(a) {
															if math.IsNaN(b) {
																cmpResult = 0
															} else {
																cmpResult = -1
															}
														} else {
															cmpResult = 1
														}
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			case types.DecimalFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Float64()
					buildKeys := buildVec.Decimal()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
															colexecerror.ExpectedError(err)
														}
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
															colexecerror.ExpectedError(err)
														}
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
															colexecerror.ExpectedError(err)
														}
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													{
														tmpDec := &_overloadHelper.tmpDec1
														if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
															colexecerror.ExpectedError(err)
														}
														cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
													}

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &_overloadHelper.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														colexecerror.ExpectedError(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case types.TimestampTZFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch buildVec.CanonicalTypeFamily() {
			case types.TimestampTZFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Timestamp()
					buildKeys := buildVec.Timestamp()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													if probeVal.Before(buildVal) {
														cmpResult = -1
													} else if buildVal.Before(probeVal) {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													if probeVal.Before(buildVal) {
														cmpResult = -1
													} else if buildVal.Before(probeVal) {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													if probeVal.Before(buildVal) {
														cmpResult = -1
													} else if buildVal.Before(probeVal) {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int

													if probeVal.Before(buildVal) {
														cmpResult = -1
													} else if buildVal.Before(probeVal) {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case types.IntervalFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch buildVec.CanonicalTypeFamily() {
			case types.IntervalFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Interval()
					buildKeys := buildVec.Interval()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = probeVal.Compare(buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = probeVal.Compare(buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = probeVal.Compare(buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx) //gcassert:inline
												buildVal := buildKeys.Get(buildIdx) //gcassert:inline
												var unique bool

												{
													var cmpResult int
													cmpResult = probeVal.Compare(buildVal)
													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch buildVec.CanonicalTypeFamily() {
			case typeconv.DatumVecCanonicalTypeFamily:
				switch buildVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Datum()
					buildKeys := buildVec.Datum()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx)
												buildVal := buildKeys.Get(buildIdx)
												var unique bool

												{
													var cmpResult int

													cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = probeSel[toCheck]
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											// The vector is probed against itself, so buildVec has the same
											// selection vector as probeVec.
											buildIdx = probeSel[keyID-1]
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx)
												buildVal := buildKeys.Get(buildIdx)
												var unique bool

												{
													var cmpResult int

													cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										// The vector is probed against itself, so buildVec has the same
										// selection vector as probeVec.
										buildIdx = probeSel[keyID-1]
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								if ht.allowNullEquality {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull && buildIsNull {
												// Both values are NULLs, and since we're allowing null equality, we
												// proceed to the next value to check.
												continue
											} else if probeIsNull {
												// Only probing value is NULL, so it is different from the build value
												// (which is non-NULL). We mark it as "different" and proceed to the
												// next value to check. This behavior is special in case of allowing
												// null equality because we don't want to reset the groupID of the
												// current probing tuple.
												ht.probeScratch.differs[toCheck] = true
												continue
											}
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx)
												buildVal := buildKeys.Get(buildIdx)
												var unique bool

												{
													var cmpResult int

													cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								} else {
									var (
										probeIdx, buildIdx       int
										probeIsNull, buildIsNull bool
									)
									// Early bounds check.
									_ = ht.probeScratch.toCheck[nToCheck-1]
									for i := uint64(0); i < nToCheck; i++ {
										// keyID of 0 is reserved to represent the end of the next chain.
										toCheck := ht.probeScratch.toCheck[i]
										keyID := ht.probeScratch.groupID[toCheck]
										if keyID != 0 {
											// the build table key (calculated using keys[keyID - 1] = key) is
											// compared to the corresponding probe table to determine if a match is
											// found.

											probeIdx = int(toCheck)
											probeIsNull = probeVec.Nulls().NullAt(probeIdx)
											buildIdx = int(keyID - 1)
											buildIsNull = buildVec.Nulls().NullAt(buildIdx)
											if probeIsNull {
												ht.probeScratch.groupID[toCheck] = 0
											} else if buildIsNull {
												ht.probeScratch.differs[toCheck] = true
											} else {
												probeVal := probeKeys.Get(probeIdx)
												buildVal := buildKeys.Get(buildIdx)
												var unique bool

												{
													var cmpResult int

													cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

													unique = cmpResult != 0
												}

												ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
											}
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

func (ht *hashTable) checkColForDistinctTuples(
	probeVec, buildVec coldata.Vec, nToCheck uint64, probeSel []int,
) {
	switch probeVec.CanonicalTypeFamily() {
	case types.BoolFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch probeVec.CanonicalTypeFamily() {
			case types.BoolFamily:
				switch probeVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Bool()
					buildKeys := buildVec.Bool()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			}
		}
	case types.BytesFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch probeVec.CanonicalTypeFamily() {
			case types.BytesFamily:
				switch probeVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Bytes()
					buildKeys := buildVec.Bytes()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			}
		}
	case types.DecimalFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch probeVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch probeVec.Type().Width() {
				}
			case types.FloatFamily:
				switch probeVec.Type().Width() {
				}
			case types.DecimalFamily:
				switch probeVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Decimal()
					buildKeys := buildVec.Decimal()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			}
		}
	case types.IntFamily:
		switch probeVec.Type().Width() {
		case 16:
			switch probeVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch probeVec.Type().Width() {
				case 16:
					probeKeys := probeVec.Int16()
					buildKeys := buildVec.Int16()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			case types.FloatFamily:
				switch probeVec.Type().Width() {
				}
			case types.DecimalFamily:
				switch probeVec.Type().Width() {
				}
			}
		case 32:
			switch probeVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch probeVec.Type().Width() {
				case 32:
					probeKeys := probeVec.Int32()
					buildKeys := buildVec.Int32()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			case types.FloatFamily:
				switch probeVec.Type().Width() {
				}
			case types.DecimalFamily:
				switch probeVec.Type().Width() {
				}
			}
		case -1:
		default:
			switch probeVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch probeVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Int64()
					buildKeys := buildVec.Int64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			case types.FloatFamily:
				switch probeVec.Type().Width() {
				}
			case types.DecimalFamily:
				switch probeVec.Type().Width() {
				}
			}
		}
	case types.FloatFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch probeVec.CanonicalTypeFamily() {
			case types.IntFamily:
				switch probeVec.Type().Width() {
				}
			case types.FloatFamily:
				switch probeVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Float64()
					buildKeys := buildVec.Float64()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			case types.DecimalFamily:
				switch probeVec.Type().Width() {
				}
			}
		}
	case types.TimestampTZFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch probeVec.CanonicalTypeFamily() {
			case types.TimestampTZFamily:
				switch probeVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Timestamp()
					buildKeys := buildVec.Timestamp()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			}
		}
	case types.IntervalFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch probeVec.CanonicalTypeFamily() {
			case types.IntervalFamily:
				switch probeVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Interval()
					buildKeys := buildVec.Interval()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx) //gcassert:inline
											buildVal := buildKeys.Get(buildIdx) //gcassert:inline
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			}
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch probeVec.Type().Width() {
		case -1:
		default:
			switch probeVec.CanonicalTypeFamily() {
			case typeconv.DatumVecCanonicalTypeFamily:
				switch probeVec.Type().Width() {
				case -1:
				default:
					probeKeys := probeVec.Datum()
					buildKeys := buildVec.Datum()
					if probeSel != nil {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = probeSel[toCheck]
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					} else {
						if probeVec.MaybeHasNulls() {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						} else {
							if buildVec.MaybeHasNulls() {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										buildIsNull = buildVec.Nulls().NullAt(buildIdx)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							} else {
								var (
									probeIdx, buildIdx       int
									probeIsNull, buildIsNull bool
								)
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.
									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx = int(toCheck)
										buildIdx = int(keyID - 1)
										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int

												cmpResult = probeVal.(*coldataext.Datum).CompareDatum(probeKeys, buildVal)

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}
									if keyID == 0 {
										ht.probeScratch.distinct[toCheck] = true
									}
								}
							}
						}

					}
				}
			}
		}
	}
}

// checkBuildForDistinct finds all tuples in probeVecs that are not present in
// buffered tuples stored in ht.vals. It stores the probeVecs's distinct tuples'
// keyIDs in headID buffer.
// NOTE: It assumes that probeVecs does not contain any duplicates itself.
// NOTE: It assumes that probeSel has already been populated and it is not nil.
func (ht *hashTable) checkBuildForDistinct(
	probeVecs []coldata.Vec, nToCheck uint64, probeSel []int,
) uint64 {
	if probeSel == nil {
		colexecerror.InternalError("invalid selection vector")
	}
	copy(ht.probeScratch.distinct, zeroBoolColumn)

	ht.checkColsForDistinctTuples(probeVecs, nToCheck, probeSel)
	nDiffers := uint64(0)
	for i := uint64(0); i < nToCheck; i++ {
		if ht.probeScratch.distinct[ht.probeScratch.toCheck[i]] {
			ht.probeScratch.distinct[ht.probeScratch.toCheck[i]] = false
			// Calculated using the convention: keyID = keys.indexOf(key) + 1.
			ht.probeScratch.headID[ht.probeScratch.toCheck[i]] = ht.probeScratch.toCheck[i] + 1
		} else if ht.probeScratch.differs[ht.probeScratch.toCheck[i]] {
			// Continue probing in this next chain for the probe key.
			ht.probeScratch.differs[ht.probeScratch.toCheck[i]] = false
			ht.probeScratch.toCheck[nDiffers] = ht.probeScratch.toCheck[i]
			nDiffers++
		}
	}
	return nDiffers
}

// checkProbeForDistinct performs a column by column check for duplicated tuples
// in the probe table.
func (ht *hashTable) checkProbeForDistinct(vecs []coldata.Vec, nToCheck uint64, sel []int) uint64 {
	for i := range ht.keyCols {
		ht.checkColAgainstItself(vecs[i], nToCheck, sel)
	}
	nDiffers := uint64(0)
	for _, toCheck := range ht.probeScratch.toCheck[:nToCheck] {
		if !ht.probeScratch.differs[toCheck] {
			// If the current key matches with the probe key, we want to update headID
			// with the current key if it has not been set yet.
			keyID := ht.probeScratch.groupID[toCheck]
			if ht.probeScratch.headID[toCheck] == 0 {
				ht.probeScratch.headID[toCheck] = keyID
			}
		}
		if ht.probeScratch.differs[toCheck] {
			// Continue probing in this next chain for the probe key.
			ht.probeScratch.differs[toCheck] = false
			ht.probeScratch.toCheck[nDiffers] = toCheck
			nDiffers++
		}
	}
	return nDiffers
}

// updateSel updates the selection vector in the given batch using the headID
// buffer. For each nonzero keyID in headID, it will be translated to the actual
// key index using the convention keyID = keys.indexOf(key) + 1. If the input
// batch's selection vector is nil, the key index will be directly used to
// populate the selection vector. Otherwise, the selection vector's value at the
// key index will be used. The duplicated keyIDs will be discarded. The
// hashBuffer will also compact and discard hash values of duplicated keys.
func (ht *hashTable) updateSel(b coldata.Batch) {
	distinctCount := 0
	if sel := b.Selection(); sel != nil {
		// Reuse the buffer allocated for distinct.
		visited := ht.probeScratch.distinct
		copy(visited, zeroBoolColumn)
		for i := 0; i < b.Length(); i++ {
			if ht.probeScratch.headID[i] != 0 {
				if hasVisited := visited[ht.probeScratch.headID[i]-1]; !hasVisited {
					sel[distinctCount] = sel[ht.probeScratch.headID[i]-1]
					visited[ht.probeScratch.headID[i]-1] = true
					// Compacting and deduplicating hash buffer.
					ht.probeScratch.hashBuffer[distinctCount] = ht.probeScratch.hashBuffer[i]
					distinctCount++
				}
			}
			ht.probeScratch.headID[i] = 0
			ht.probeScratch.differs[i] = false
		}
	} else {
		b.SetSelection(true)
		sel = b.Selection()
		// Reuse the buffer allocated for distinct.
		visited := ht.probeScratch.distinct
		copy(visited, zeroBoolColumn)
		for i := 0; i < b.Length(); i++ {
			if ht.probeScratch.headID[i] != 0 {
				if hasVisited := visited[ht.probeScratch.headID[i]-1]; !hasVisited {
					sel[distinctCount] = int(ht.probeScratch.headID[i] - 1)
					visited[ht.probeScratch.headID[i]-1] = true
					// Compacting and deduplicating hash buffer.
					ht.probeScratch.hashBuffer[distinctCount] = ht.probeScratch.hashBuffer[i]
					distinctCount++
				}
			}
			ht.probeScratch.headID[i] = 0
			ht.probeScratch.differs[i] = false
		}
	}
	b.SetLength(distinctCount)
}

// distinctCheck determines if the current key in the groupID bucket matches the
// equality column key. If there is a match, then the key is removed from
// toCheck. If the bucket has reached the end, the key is rejected. The toCheck
// list is reconstructed to only hold the indices of the eqCol keys that have
// not been found. The new length of toCheck is returned by this function.
func (ht *hashTable) distinctCheck(nToCheck uint64, probeSel []int) uint64 {
	probeVecs := ht.probeScratch.keys
	buildVecs := ht.vals.ColVecs()
	buildKeyCols := ht.keyCols
	ht.checkCols(probeVecs, buildVecs, buildKeyCols, nToCheck, probeSel)
	// Select the indices that differ and put them into toCheck.
	nDiffers := uint64(0)
	for i := uint64(0); i < nToCheck; i++ {
		if ht.probeScratch.differs[ht.probeScratch.toCheck[i]] {
			ht.probeScratch.differs[ht.probeScratch.toCheck[i]] = false
			ht.probeScratch.toCheck[nDiffers] = ht.probeScratch.toCheck[i]
			nDiffers++
		}
	}
	return nDiffers
}
