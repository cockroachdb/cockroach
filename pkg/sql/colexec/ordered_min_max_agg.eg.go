// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"math"
	"time"
	"unsafe"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
)

// Remove unused warning.
var _ = colexecerror.InternalError

func newMinOrderedAggAlloc(
	allocator *colmem.Allocator, t *types.T, allocSize int64,
) aggregateFuncAlloc {
	allocBase := aggAllocBase{allocator: allocator, allocSize: allocSize}
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		return &minBoolOrderedAggAlloc{aggAllocBase: allocBase}
	case types.BytesFamily:
		return &minBytesOrderedAggAlloc{aggAllocBase: allocBase}
	case types.DecimalFamily:
		return &minDecimalOrderedAggAlloc{aggAllocBase: allocBase}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			return &minInt16OrderedAggAlloc{aggAllocBase: allocBase}
		case 32:
			return &minInt32OrderedAggAlloc{aggAllocBase: allocBase}
		default:
			return &minInt64OrderedAggAlloc{aggAllocBase: allocBase}
		}
	case types.FloatFamily:
		return &minFloat64OrderedAggAlloc{aggAllocBase: allocBase}
	case types.TimestampTZFamily:
		return &minTimestampOrderedAggAlloc{aggAllocBase: allocBase}
	case types.IntervalFamily:
		return &minIntervalOrderedAggAlloc{aggAllocBase: allocBase}
	default:
		return &minDatumOrderedAggAlloc{aggAllocBase: allocBase}
	}
}

func newMaxOrderedAggAlloc(
	allocator *colmem.Allocator, t *types.T, allocSize int64,
) aggregateFuncAlloc {
	allocBase := aggAllocBase{allocator: allocator, allocSize: allocSize}
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		return &maxBoolOrderedAggAlloc{aggAllocBase: allocBase}
	case types.BytesFamily:
		return &maxBytesOrderedAggAlloc{aggAllocBase: allocBase}
	case types.DecimalFamily:
		return &maxDecimalOrderedAggAlloc{aggAllocBase: allocBase}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			return &maxInt16OrderedAggAlloc{aggAllocBase: allocBase}
		case 32:
			return &maxInt32OrderedAggAlloc{aggAllocBase: allocBase}
		default:
			return &maxInt64OrderedAggAlloc{aggAllocBase: allocBase}
		}
	case types.FloatFamily:
		return &maxFloat64OrderedAggAlloc{aggAllocBase: allocBase}
	case types.TimestampTZFamily:
		return &maxTimestampOrderedAggAlloc{aggAllocBase: allocBase}
	case types.IntervalFamily:
		return &maxIntervalOrderedAggAlloc{aggAllocBase: allocBase}
	default:
		return &maxDatumOrderedAggAlloc{aggAllocBase: allocBase}
	}
}

type minBoolOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg bool
	// col points to the output vector we are updating.
	col coldata.Bools
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBoolOrderedAgg{}

const sizeOfminBoolOrderedAgg = int64(unsafe.Sizeof(minBoolOrderedAgg{}))

func (a *minBoolOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bool()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minBoolOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minBoolOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minBoolOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minBoolOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minBoolOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minBoolOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minBoolOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minBoolOrderedAgg
}

var _ aggregateFuncAlloc = &minBoolOrderedAggAlloc{}

func (a *minBoolOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminBoolOrderedAgg * a.allocSize)
		a.aggFuncs = make([]minBoolOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minBytesOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBytesOrderedAgg{}

const sizeOfminBytesOrderedAgg = int64(unsafe.Sizeof(minBytesOrderedAgg{}))

func (a *minBytesOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bytes()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minBytesOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minBytesOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minBytesOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minBytesOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minBytesOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *minBytesOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minBytesOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minBytesOrderedAgg
}

var _ aggregateFuncAlloc = &minBytesOrderedAggAlloc{}

func (a *minBytesOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminBytesOrderedAgg * a.allocSize)
		a.aggFuncs = make([]minBytesOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minDecimalOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col coldata.Decimals
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minDecimalOrderedAgg{}

const sizeOfminDecimalOrderedAgg = int64(unsafe.Sizeof(minDecimalOrderedAgg{}))

func (a *minDecimalOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Decimal()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minDecimalOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minDecimalOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minDecimalOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minDecimalOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minDecimalOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx].Set(&a.curAgg)
	}
	a.curIdx++
}

func (a *minDecimalOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minDecimalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minDecimalOrderedAgg
}

var _ aggregateFuncAlloc = &minDecimalOrderedAggAlloc{}

func (a *minDecimalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminDecimalOrderedAgg * a.allocSize)
		a.aggFuncs = make([]minDecimalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt16OrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col coldata.Int64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt16OrderedAgg{}

const sizeOfminInt16OrderedAgg = int64(unsafe.Sizeof(minInt16OrderedAgg{}))

func (a *minInt16OrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt16OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minInt16OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt16OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minInt16OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt16OrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minInt16OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt16OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minInt16OrderedAgg
}

var _ aggregateFuncAlloc = &minInt16OrderedAggAlloc{}

func (a *minInt16OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminInt16OrderedAgg * a.allocSize)
		a.aggFuncs = make([]minInt16OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt32OrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col coldata.Int64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt32OrderedAgg{}

const sizeOfminInt32OrderedAgg = int64(unsafe.Sizeof(minInt32OrderedAgg{}))

func (a *minInt32OrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt32OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minInt32OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt32OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minInt32OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt32OrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minInt32OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt32OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minInt32OrderedAgg
}

var _ aggregateFuncAlloc = &minInt32OrderedAggAlloc{}

func (a *minInt32OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminInt32OrderedAgg * a.allocSize)
		a.aggFuncs = make([]minInt32OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt64OrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col coldata.Int64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt64OrderedAgg{}

const sizeOfminInt64OrderedAgg = int64(unsafe.Sizeof(minInt64OrderedAgg{}))

func (a *minInt64OrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt64OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minInt64OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt64OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minInt64OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt64OrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minInt64OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minInt64OrderedAgg
}

var _ aggregateFuncAlloc = &minInt64OrderedAggAlloc{}

func (a *minInt64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminInt64OrderedAgg * a.allocSize)
		a.aggFuncs = make([]minInt64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minFloat64OrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg float64
	// col points to the output vector we are updating.
	col coldata.Float64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minFloat64OrderedAgg{}

const sizeOfminFloat64OrderedAgg = int64(unsafe.Sizeof(minFloat64OrderedAgg{}))

func (a *minFloat64OrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Float64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minFloat64OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minFloat64OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minFloat64OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minFloat64OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minFloat64OrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minFloat64OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minFloat64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minFloat64OrderedAgg
}

var _ aggregateFuncAlloc = &minFloat64OrderedAggAlloc{}

func (a *minFloat64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminFloat64OrderedAgg * a.allocSize)
		a.aggFuncs = make([]minFloat64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minTimestampOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg time.Time
	// col points to the output vector we are updating.
	col coldata.Times
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minTimestampOrderedAgg{}

const sizeOfminTimestampOrderedAgg = int64(unsafe.Sizeof(minTimestampOrderedAgg{}))

func (a *minTimestampOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Timestamp()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minTimestampOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minTimestampOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minTimestampOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minTimestampOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minTimestampOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minTimestampOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minTimestampOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minTimestampOrderedAgg
}

var _ aggregateFuncAlloc = &minTimestampOrderedAggAlloc{}

func (a *minTimestampOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminTimestampOrderedAgg * a.allocSize)
		a.aggFuncs = make([]minTimestampOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minIntervalOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg duration.Duration
	// col points to the output vector we are updating.
	col coldata.Durations
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minIntervalOrderedAgg{}

const sizeOfminIntervalOrderedAgg = int64(unsafe.Sizeof(minIntervalOrderedAgg{}))

func (a *minIntervalOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Interval()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minIntervalOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minIntervalOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minIntervalOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minIntervalOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minIntervalOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minIntervalOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minIntervalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minIntervalOrderedAgg
}

var _ aggregateFuncAlloc = &minIntervalOrderedAggAlloc{}

func (a *minIntervalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminIntervalOrderedAgg * a.allocSize)
		a.aggFuncs = make([]minIntervalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minDatumOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg interface{}
	// col points to the output vector we are updating.
	col coldata.DatumVec
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minDatumOrderedAgg{}

const sizeOfminDatumOrderedAgg = int64(unsafe.Sizeof(minDatumOrderedAgg{}))

func (a *minDatumOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Datum()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minDatumOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minDatumOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minDatumOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *minDatumOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Datum(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minDatumOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *minDatumOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minDatumOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minDatumOrderedAgg
}

var _ aggregateFuncAlloc = &minDatumOrderedAggAlloc{}

func (a *minDatumOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminDatumOrderedAgg * a.allocSize)
		a.aggFuncs = make([]minDatumOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxBoolOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg bool
	// col points to the output vector we are updating.
	col coldata.Bools
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBoolOrderedAgg{}

const sizeOfmaxBoolOrderedAgg = int64(unsafe.Sizeof(maxBoolOrderedAgg{}))

func (a *maxBoolOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bool()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxBoolOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxBoolOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxBoolOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxBoolOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxBoolOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxBoolOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxBoolOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxBoolOrderedAgg
}

var _ aggregateFuncAlloc = &maxBoolOrderedAggAlloc{}

func (a *maxBoolOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxBoolOrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxBoolOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxBytesOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBytesOrderedAgg{}

const sizeOfmaxBytesOrderedAgg = int64(unsafe.Sizeof(maxBytesOrderedAgg{}))

func (a *maxBytesOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bytes()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxBytesOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxBytesOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxBytesOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxBytesOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxBytesOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *maxBytesOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxBytesOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxBytesOrderedAgg
}

var _ aggregateFuncAlloc = &maxBytesOrderedAggAlloc{}

func (a *maxBytesOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxBytesOrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxBytesOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxDecimalOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col coldata.Decimals
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxDecimalOrderedAgg{}

const sizeOfmaxDecimalOrderedAgg = int64(unsafe.Sizeof(maxDecimalOrderedAgg{}))

func (a *maxDecimalOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Decimal()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxDecimalOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxDecimalOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxDecimalOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxDecimalOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxDecimalOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx].Set(&a.curAgg)
	}
	a.curIdx++
}

func (a *maxDecimalOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxDecimalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxDecimalOrderedAgg
}

var _ aggregateFuncAlloc = &maxDecimalOrderedAggAlloc{}

func (a *maxDecimalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxDecimalOrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxDecimalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt16OrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col coldata.Int64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt16OrderedAgg{}

const sizeOfmaxInt16OrderedAgg = int64(unsafe.Sizeof(maxInt16OrderedAgg{}))

func (a *maxInt16OrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt16OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxInt16OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt16OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxInt16OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt16OrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxInt16OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt16OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt16OrderedAgg
}

var _ aggregateFuncAlloc = &maxInt16OrderedAggAlloc{}

func (a *maxInt16OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxInt16OrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxInt16OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt32OrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col coldata.Int64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt32OrderedAgg{}

const sizeOfmaxInt32OrderedAgg = int64(unsafe.Sizeof(maxInt32OrderedAgg{}))

func (a *maxInt32OrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt32OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxInt32OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt32OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxInt32OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt32OrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxInt32OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt32OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt32OrderedAgg
}

var _ aggregateFuncAlloc = &maxInt32OrderedAggAlloc{}

func (a *maxInt32OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxInt32OrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxInt32OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt64OrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col coldata.Int64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt64OrderedAgg{}

const sizeOfmaxInt64OrderedAgg = int64(unsafe.Sizeof(maxInt64OrderedAgg{}))

func (a *maxInt64OrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt64OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxInt64OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt64OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxInt64OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt64OrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxInt64OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt64OrderedAgg
}

var _ aggregateFuncAlloc = &maxInt64OrderedAggAlloc{}

func (a *maxInt64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxInt64OrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxInt64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxFloat64OrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg float64
	// col points to the output vector we are updating.
	col coldata.Float64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxFloat64OrderedAgg{}

const sizeOfmaxFloat64OrderedAgg = int64(unsafe.Sizeof(maxFloat64OrderedAgg{}))

func (a *maxFloat64OrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Float64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxFloat64OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxFloat64OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxFloat64OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxFloat64OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxFloat64OrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxFloat64OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxFloat64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxFloat64OrderedAgg
}

var _ aggregateFuncAlloc = &maxFloat64OrderedAggAlloc{}

func (a *maxFloat64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxFloat64OrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxFloat64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxTimestampOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg time.Time
	// col points to the output vector we are updating.
	col coldata.Times
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxTimestampOrderedAgg{}

const sizeOfmaxTimestampOrderedAgg = int64(unsafe.Sizeof(maxTimestampOrderedAgg{}))

func (a *maxTimestampOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Timestamp()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxTimestampOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxTimestampOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxTimestampOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxTimestampOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxTimestampOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxTimestampOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxTimestampOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxTimestampOrderedAgg
}

var _ aggregateFuncAlloc = &maxTimestampOrderedAggAlloc{}

func (a *maxTimestampOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxTimestampOrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxTimestampOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxIntervalOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg duration.Duration
	// col points to the output vector we are updating.
	col coldata.Durations
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxIntervalOrderedAgg{}

const sizeOfmaxIntervalOrderedAgg = int64(unsafe.Sizeof(maxIntervalOrderedAgg{}))

func (a *maxIntervalOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Interval()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxIntervalOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxIntervalOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxIntervalOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxIntervalOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i) //gcassert:inline
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i) //gcassert:inline

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxIntervalOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxIntervalOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxIntervalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxIntervalOrderedAgg
}

var _ aggregateFuncAlloc = &maxIntervalOrderedAggAlloc{}

func (a *maxIntervalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxIntervalOrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxIntervalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxDatumOrderedAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg interface{}
	// col points to the output vector we are updating.
	col coldata.DatumVec
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxDatumOrderedAgg{}

const sizeOfmaxDatumOrderedAgg = int64(unsafe.Sizeof(maxDatumOrderedAgg{}))

func (a *maxDatumOrderedAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Datum()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxDatumOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxDatumOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxDatumOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *maxDatumOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Datum(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxDatumOrderedAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *maxDatumOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxDatumOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxDatumOrderedAgg
}

var _ aggregateFuncAlloc = &maxDatumOrderedAggAlloc{}

func (a *maxDatumOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxDatumOrderedAgg * a.allocSize)
		a.aggFuncs = make([]maxDatumOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}
