// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"math"
	"time"
	"unsafe"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
)

// Remove unused warning.
var _ = colexecerror.InternalError

func newMinOrderedAggAlloc(
	allocator *colmem.Allocator, t *types.T, allocSize int64,
) aggregateFuncAlloc {
	allocBase := aggAllocBase{allocator: allocator, allocSize: allocSize}
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		return &minBoolOrderedAggAlloc{aggAllocBase: allocBase}
	case types.BytesFamily:
		return &minBytesOrderedAggAlloc{aggAllocBase: allocBase}
	case types.DecimalFamily:
		return &minDecimalOrderedAggAlloc{aggAllocBase: allocBase}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			return &minInt16OrderedAggAlloc{aggAllocBase: allocBase}
		case 32:
			return &minInt32OrderedAggAlloc{aggAllocBase: allocBase}
		default:
			return &minInt64OrderedAggAlloc{aggAllocBase: allocBase}
		}
	case types.FloatFamily:
		return &minFloat64OrderedAggAlloc{aggAllocBase: allocBase}
	case types.TimestampTZFamily:
		return &minTimestampOrderedAggAlloc{aggAllocBase: allocBase}
	case types.IntervalFamily:
		return &minIntervalOrderedAggAlloc{aggAllocBase: allocBase}
	default:
		return &minDatumOrderedAggAlloc{aggAllocBase: allocBase}
	}
}

func newMaxOrderedAggAlloc(
	allocator *colmem.Allocator, t *types.T, allocSize int64,
) aggregateFuncAlloc {
	allocBase := aggAllocBase{allocator: allocator, allocSize: allocSize}
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		return &maxBoolOrderedAggAlloc{aggAllocBase: allocBase}
	case types.BytesFamily:
		return &maxBytesOrderedAggAlloc{aggAllocBase: allocBase}
	case types.DecimalFamily:
		return &maxDecimalOrderedAggAlloc{aggAllocBase: allocBase}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			return &maxInt16OrderedAggAlloc{aggAllocBase: allocBase}
		case 32:
			return &maxInt32OrderedAggAlloc{aggAllocBase: allocBase}
		default:
			return &maxInt64OrderedAggAlloc{aggAllocBase: allocBase}
		}
	case types.FloatFamily:
		return &maxFloat64OrderedAggAlloc{aggAllocBase: allocBase}
	case types.TimestampTZFamily:
		return &maxTimestampOrderedAggAlloc{aggAllocBase: allocBase}
	case types.IntervalFamily:
		return &maxIntervalOrderedAggAlloc{aggAllocBase: allocBase}
	default:
		return &maxDatumOrderedAggAlloc{aggAllocBase: allocBase}
	}
}

type minBoolOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg bool
	// col points to the output vector we are updating.
	col coldata.Bools
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBoolOrderedAgg{}

func (a *minBoolOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Bool()
	a.Reset()
}

func (a *minBoolOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minBoolOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minBoolOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type minBoolOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minBoolOrderedAgg
}

var _ aggregateFuncAlloc = &minBoolOrderedAggAlloc{}

const sizeOfminBoolOrderedAgg = int64(unsafe.Sizeof(minBoolOrderedAgg{}))
const minBoolOrderedAggSliceOverhead = int64(unsafe.Sizeof([]minBoolOrderedAgg{}))

func (a *minBoolOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minBoolOrderedAggSliceOverhead + sizeOfminBoolOrderedAgg*a.allocSize)
		a.aggFuncs = make([]minBoolOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minBytesOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBytesOrderedAgg{}

func (a *minBytesOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Bytes()
	a.Reset()
}

func (a *minBytesOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minBytesOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	oldCurAggSize := len(a.curAgg)
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Bytes(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col
				_ = 0
				_ = inputLen
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			}
		},
	)
	newCurAggSize := len(a.curAgg)
	a.allocator.AdjustMemoryUsage(int64(newCurAggSize - oldCurAggSize))
}

func (a *minBytesOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col.Set(outputIdx, a.curAgg)
	}
	// Release the reference to curAgg eagerly.
	a.allocator.AdjustMemoryUsage(-int64(len(a.curAgg)))
	a.curAgg = nil
}

type minBytesOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minBytesOrderedAgg
}

var _ aggregateFuncAlloc = &minBytesOrderedAggAlloc{}

const sizeOfminBytesOrderedAgg = int64(unsafe.Sizeof(minBytesOrderedAgg{}))
const minBytesOrderedAggSliceOverhead = int64(unsafe.Sizeof([]minBytesOrderedAgg{}))

func (a *minBytesOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minBytesOrderedAggSliceOverhead + sizeOfminBytesOrderedAgg*a.allocSize)
		a.aggFuncs = make([]minBytesOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minDecimalOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col coldata.Decimals
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minDecimalOrderedAgg{}

func (a *minDecimalOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Decimal()
	a.Reset()
}

func (a *minDecimalOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minDecimalOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minDecimalOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx].Set(&a.curAgg)
	}
}

type minDecimalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minDecimalOrderedAgg
}

var _ aggregateFuncAlloc = &minDecimalOrderedAggAlloc{}

const sizeOfminDecimalOrderedAgg = int64(unsafe.Sizeof(minDecimalOrderedAgg{}))
const minDecimalOrderedAggSliceOverhead = int64(unsafe.Sizeof([]minDecimalOrderedAgg{}))

func (a *minDecimalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minDecimalOrderedAggSliceOverhead + sizeOfminDecimalOrderedAgg*a.allocSize)
		a.aggFuncs = make([]minDecimalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt16OrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int16
	// col points to the output vector we are updating.
	col coldata.Int16s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt16OrderedAgg{}

func (a *minInt16OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Int16()
	a.Reset()
}

func (a *minInt16OrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minInt16OrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt16OrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type minInt16OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minInt16OrderedAgg
}

var _ aggregateFuncAlloc = &minInt16OrderedAggAlloc{}

const sizeOfminInt16OrderedAgg = int64(unsafe.Sizeof(minInt16OrderedAgg{}))
const minInt16OrderedAggSliceOverhead = int64(unsafe.Sizeof([]minInt16OrderedAgg{}))

func (a *minInt16OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minInt16OrderedAggSliceOverhead + sizeOfminInt16OrderedAgg*a.allocSize)
		a.aggFuncs = make([]minInt16OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt32OrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int32
	// col points to the output vector we are updating.
	col coldata.Int32s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt32OrderedAgg{}

func (a *minInt32OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Int32()
	a.Reset()
}

func (a *minInt32OrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minInt32OrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt32OrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type minInt32OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minInt32OrderedAgg
}

var _ aggregateFuncAlloc = &minInt32OrderedAggAlloc{}

const sizeOfminInt32OrderedAgg = int64(unsafe.Sizeof(minInt32OrderedAgg{}))
const minInt32OrderedAggSliceOverhead = int64(unsafe.Sizeof([]minInt32OrderedAgg{}))

func (a *minInt32OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minInt32OrderedAggSliceOverhead + sizeOfminInt32OrderedAgg*a.allocSize)
		a.aggFuncs = make([]minInt32OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt64OrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col coldata.Int64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt64OrderedAgg{}

func (a *minInt64OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Int64()
	a.Reset()
}

func (a *minInt64OrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minInt64OrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt64OrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type minInt64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minInt64OrderedAgg
}

var _ aggregateFuncAlloc = &minInt64OrderedAggAlloc{}

const sizeOfminInt64OrderedAgg = int64(unsafe.Sizeof(minInt64OrderedAgg{}))
const minInt64OrderedAggSliceOverhead = int64(unsafe.Sizeof([]minInt64OrderedAgg{}))

func (a *minInt64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minInt64OrderedAggSliceOverhead + sizeOfminInt64OrderedAgg*a.allocSize)
		a.aggFuncs = make([]minInt64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minFloat64OrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg float64
	// col points to the output vector we are updating.
	col coldata.Float64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minFloat64OrderedAgg{}

func (a *minFloat64OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Float64()
	a.Reset()
}

func (a *minFloat64OrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minFloat64OrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minFloat64OrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type minFloat64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minFloat64OrderedAgg
}

var _ aggregateFuncAlloc = &minFloat64OrderedAggAlloc{}

const sizeOfminFloat64OrderedAgg = int64(unsafe.Sizeof(minFloat64OrderedAgg{}))
const minFloat64OrderedAggSliceOverhead = int64(unsafe.Sizeof([]minFloat64OrderedAgg{}))

func (a *minFloat64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minFloat64OrderedAggSliceOverhead + sizeOfminFloat64OrderedAgg*a.allocSize)
		a.aggFuncs = make([]minFloat64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minTimestampOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg time.Time
	// col points to the output vector we are updating.
	col coldata.Times
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minTimestampOrderedAgg{}

func (a *minTimestampOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Timestamp()
	a.Reset()
}

func (a *minTimestampOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minTimestampOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minTimestampOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type minTimestampOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minTimestampOrderedAgg
}

var _ aggregateFuncAlloc = &minTimestampOrderedAggAlloc{}

const sizeOfminTimestampOrderedAgg = int64(unsafe.Sizeof(minTimestampOrderedAgg{}))
const minTimestampOrderedAggSliceOverhead = int64(unsafe.Sizeof([]minTimestampOrderedAgg{}))

func (a *minTimestampOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minTimestampOrderedAggSliceOverhead + sizeOfminTimestampOrderedAgg*a.allocSize)
		a.aggFuncs = make([]minTimestampOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minIntervalOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg duration.Duration
	// col points to the output vector we are updating.
	col coldata.Durations
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minIntervalOrderedAgg{}

func (a *minIntervalOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Interval()
	a.Reset()
}

func (a *minIntervalOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minIntervalOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minIntervalOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type minIntervalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minIntervalOrderedAgg
}

var _ aggregateFuncAlloc = &minIntervalOrderedAggAlloc{}

const sizeOfminIntervalOrderedAgg = int64(unsafe.Sizeof(minIntervalOrderedAgg{}))
const minIntervalOrderedAggSliceOverhead = int64(unsafe.Sizeof([]minIntervalOrderedAgg{}))

func (a *minIntervalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minIntervalOrderedAggSliceOverhead + sizeOfminIntervalOrderedAgg*a.allocSize)
		a.aggFuncs = make([]minIntervalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minDatumOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg interface{}
	// col points to the output vector we are updating.
	col coldata.DatumVec
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minDatumOrderedAgg{}

func (a *minDatumOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Datum()
	a.Reset()
}

func (a *minDatumOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *minDatumOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	var oldCurAggSize uintptr
	if a.curAgg != nil {
		oldCurAggSize = a.curAgg.(*coldataext.Datum).Size()
	}
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Datum(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col.Slice(0, inputLen)
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
	var newCurAggSize uintptr
	if a.curAgg != nil {
		newCurAggSize = a.curAgg.(*coldataext.Datum).Size()
	}
	a.allocator.AdjustMemoryUsage(int64(newCurAggSize - oldCurAggSize))
}

func (a *minDatumOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col.Set(outputIdx, a.curAgg)
	}
	// Release the reference to curAgg eagerly.
	if d, ok := a.curAgg.(*coldataext.Datum); ok {
		a.allocator.AdjustMemoryUsage(-int64(d.Size()))
	}
	a.curAgg = nil
}

type minDatumOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []minDatumOrderedAgg
}

var _ aggregateFuncAlloc = &minDatumOrderedAggAlloc{}

const sizeOfminDatumOrderedAgg = int64(unsafe.Sizeof(minDatumOrderedAgg{}))
const minDatumOrderedAggSliceOverhead = int64(unsafe.Sizeof([]minDatumOrderedAgg{}))

func (a *minDatumOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(minDatumOrderedAggSliceOverhead + sizeOfminDatumOrderedAgg*a.allocSize)
		a.aggFuncs = make([]minDatumOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxBoolOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg bool
	// col points to the output vector we are updating.
	col coldata.Bools
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBoolOrderedAgg{}

func (a *maxBoolOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Bool()
	a.Reset()
}

func (a *maxBoolOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxBoolOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxBoolOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type maxBoolOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxBoolOrderedAgg
}

var _ aggregateFuncAlloc = &maxBoolOrderedAggAlloc{}

const sizeOfmaxBoolOrderedAgg = int64(unsafe.Sizeof(maxBoolOrderedAgg{}))
const maxBoolOrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxBoolOrderedAgg{}))

func (a *maxBoolOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxBoolOrderedAggSliceOverhead + sizeOfmaxBoolOrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxBoolOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxBytesOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBytesOrderedAgg{}

func (a *maxBytesOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Bytes()
	a.Reset()
}

func (a *maxBytesOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxBytesOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	oldCurAggSize := len(a.curAgg)
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Bytes(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col
				_ = 0
				_ = inputLen
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			}
		},
	)
	newCurAggSize := len(a.curAgg)
	a.allocator.AdjustMemoryUsage(int64(newCurAggSize - oldCurAggSize))
}

func (a *maxBytesOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col.Set(outputIdx, a.curAgg)
	}
	// Release the reference to curAgg eagerly.
	a.allocator.AdjustMemoryUsage(-int64(len(a.curAgg)))
	a.curAgg = nil
}

type maxBytesOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxBytesOrderedAgg
}

var _ aggregateFuncAlloc = &maxBytesOrderedAggAlloc{}

const sizeOfmaxBytesOrderedAgg = int64(unsafe.Sizeof(maxBytesOrderedAgg{}))
const maxBytesOrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxBytesOrderedAgg{}))

func (a *maxBytesOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxBytesOrderedAggSliceOverhead + sizeOfmaxBytesOrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxBytesOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxDecimalOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col coldata.Decimals
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxDecimalOrderedAgg{}

func (a *maxDecimalOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Decimal()
	a.Reset()
}

func (a *maxDecimalOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxDecimalOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxDecimalOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx].Set(&a.curAgg)
	}
}

type maxDecimalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxDecimalOrderedAgg
}

var _ aggregateFuncAlloc = &maxDecimalOrderedAggAlloc{}

const sizeOfmaxDecimalOrderedAgg = int64(unsafe.Sizeof(maxDecimalOrderedAgg{}))
const maxDecimalOrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxDecimalOrderedAgg{}))

func (a *maxDecimalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxDecimalOrderedAggSliceOverhead + sizeOfmaxDecimalOrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxDecimalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt16OrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int16
	// col points to the output vector we are updating.
	col coldata.Int16s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt16OrderedAgg{}

func (a *maxInt16OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Int16()
	a.Reset()
}

func (a *maxInt16OrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxInt16OrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt16OrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type maxInt16OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt16OrderedAgg
}

var _ aggregateFuncAlloc = &maxInt16OrderedAggAlloc{}

const sizeOfmaxInt16OrderedAgg = int64(unsafe.Sizeof(maxInt16OrderedAgg{}))
const maxInt16OrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxInt16OrderedAgg{}))

func (a *maxInt16OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxInt16OrderedAggSliceOverhead + sizeOfmaxInt16OrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxInt16OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt32OrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int32
	// col points to the output vector we are updating.
	col coldata.Int32s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt32OrderedAgg{}

func (a *maxInt32OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Int32()
	a.Reset()
}

func (a *maxInt32OrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxInt32OrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt32OrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type maxInt32OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt32OrderedAgg
}

var _ aggregateFuncAlloc = &maxInt32OrderedAggAlloc{}

const sizeOfmaxInt32OrderedAgg = int64(unsafe.Sizeof(maxInt32OrderedAgg{}))
const maxInt32OrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxInt32OrderedAgg{}))

func (a *maxInt32OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxInt32OrderedAggSliceOverhead + sizeOfmaxInt32OrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxInt32OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt64OrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col coldata.Int64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt64OrderedAgg{}

func (a *maxInt64OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Int64()
	a.Reset()
}

func (a *maxInt64OrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxInt64OrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt64OrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type maxInt64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt64OrderedAgg
}

var _ aggregateFuncAlloc = &maxInt64OrderedAggAlloc{}

const sizeOfmaxInt64OrderedAgg = int64(unsafe.Sizeof(maxInt64OrderedAgg{}))
const maxInt64OrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxInt64OrderedAgg{}))

func (a *maxInt64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxInt64OrderedAggSliceOverhead + sizeOfmaxInt64OrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxInt64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxFloat64OrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg float64
	// col points to the output vector we are updating.
	col coldata.Float64s
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxFloat64OrderedAgg{}

func (a *maxFloat64OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Float64()
	a.Reset()
}

func (a *maxFloat64OrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxFloat64OrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxFloat64OrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type maxFloat64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxFloat64OrderedAgg
}

var _ aggregateFuncAlloc = &maxFloat64OrderedAggAlloc{}

const sizeOfmaxFloat64OrderedAgg = int64(unsafe.Sizeof(maxFloat64OrderedAgg{}))
const maxFloat64OrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxFloat64OrderedAgg{}))

func (a *maxFloat64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxFloat64OrderedAggSliceOverhead + sizeOfmaxFloat64OrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxFloat64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxTimestampOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg time.Time
	// col points to the output vector we are updating.
	col coldata.Times
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxTimestampOrderedAgg{}

func (a *maxTimestampOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Timestamp()
	a.Reset()
}

func (a *maxTimestampOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxTimestampOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxTimestampOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type maxTimestampOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxTimestampOrderedAgg
}

var _ aggregateFuncAlloc = &maxTimestampOrderedAggAlloc{}

const sizeOfmaxTimestampOrderedAgg = int64(unsafe.Sizeof(maxTimestampOrderedAgg{}))
const maxTimestampOrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxTimestampOrderedAgg{}))

func (a *maxTimestampOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxTimestampOrderedAggSliceOverhead + sizeOfmaxTimestampOrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxTimestampOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxIntervalOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg duration.Duration
	// col points to the output vector we are updating.
	col coldata.Durations
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxIntervalOrderedAgg{}

func (a *maxIntervalOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Interval()
	a.Reset()
}

func (a *maxIntervalOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxIntervalOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col[0:inputLen]
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxIntervalOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col[outputIdx] = a.curAgg
	}
}

type maxIntervalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxIntervalOrderedAgg
}

var _ aggregateFuncAlloc = &maxIntervalOrderedAggAlloc{}

const sizeOfmaxIntervalOrderedAgg = int64(unsafe.Sizeof(maxIntervalOrderedAgg{}))
const maxIntervalOrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxIntervalOrderedAgg{}))

func (a *maxIntervalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxIntervalOrderedAggSliceOverhead + sizeOfmaxIntervalOrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxIntervalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxDatumOrderedAgg struct {
	orderedAggregateFuncBase
	allocator *colmem.Allocator
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg interface{}
	// col points to the output vector we are updating.
	col coldata.DatumVec
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxDatumOrderedAgg{}

func (a *maxDatumOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.orderedAggregateFuncBase.Init(groups, vec)
	a.vec = vec
	a.col = vec.Datum()
	a.Reset()
}

func (a *maxDatumOrderedAgg) Reset() {
	a.orderedAggregateFuncBase.Reset()
	a.foundNonNullForCurrentGroup = false
}

func (a *maxDatumOrderedAgg) Compute(
	vecs []coldata.Vec, inputIdxs []uint32, inputLen int, sel []int,
) {
	var oldCurAggSize uintptr
	if a.curAgg != nil {
		oldCurAggSize = a.curAgg.(*coldataext.Datum).Size()
	}
	vec := vecs[inputIdxs[0]]
	col, nulls := vec.Datum(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			groups := a.groups
			if sel == nil {
				_ = groups[inputLen-1]
				col = col.Slice(0, inputLen)
				if nulls.MaybeHasNulls() {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				sel = sel[:inputLen]
				if nulls.MaybeHasNulls() {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					for _, i := range sel {

						if groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
	var newCurAggSize uintptr
	if a.curAgg != nil {
		newCurAggSize = a.curAgg.(*coldataext.Datum).Size()
	}
	a.allocator.AdjustMemoryUsage(int64(newCurAggSize - oldCurAggSize))
}

func (a *maxDatumOrderedAgg) Flush(outputIdx int) {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	// Go around "argument overwritten before first use" linter error.
	_ = outputIdx
	outputIdx = a.curIdx
	a.curIdx++
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(outputIdx)
	} else {
		a.col.Set(outputIdx, a.curAgg)
	}
	// Release the reference to curAgg eagerly.
	if d, ok := a.curAgg.(*coldataext.Datum); ok {
		a.allocator.AdjustMemoryUsage(-int64(d.Size()))
	}
	a.curAgg = nil
}

type maxDatumOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []maxDatumOrderedAgg
}

var _ aggregateFuncAlloc = &maxDatumOrderedAggAlloc{}

const sizeOfmaxDatumOrderedAgg = int64(unsafe.Sizeof(maxDatumOrderedAgg{}))
const maxDatumOrderedAggSliceOverhead = int64(unsafe.Sizeof([]maxDatumOrderedAgg{}))

func (a *maxDatumOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(maxDatumOrderedAggSliceOverhead + sizeOfmaxDatumOrderedAgg*a.allocSize)
		a.aggFuncs = make([]maxDatumOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}
