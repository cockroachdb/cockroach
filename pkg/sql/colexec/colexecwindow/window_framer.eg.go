// Code generated by execgen; DO NOT EDIT.
// Copyright 2021 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexecwindow

import (
	"context"

	"github.com/cockroachdb/cockroach/pkg/sql/colconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecutils"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/execinfrapb"
	"github.com/cockroachdb/cockroach/pkg/sql/rowenc"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/errors"
)

// windowFramer is used to calculate the window frame for each row in a
// partition.
type windowFramer interface {
	// getColsToStore is called upon initialization of the windowFramer operators
	// in order to add to the list of columns to store in the SpillingBuffer owned
	// by the parent operator.
	// getColsToStore adds column indices to the given list when the windowFramer
	// operator needs access to values in a column for each partition (for
	// example, the peer groups column). If a column to be stored is already
	// present in the list, a duplicate entry will not be created.
	getColsToStore(oldColsToStore []int) (colsToStore []int)

	// startPartition is called before each partition is processed. It initializes
	// the windowFramer operators with the size of the partition and stored
	// columns. It also resets any fields used for window frame calculation.
	startPartition(ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer)

	// next should be called for each row in the partition. It calculates the
	// window frame for the current row (starting from the zeroth) and then
	// increments the currentRow field. next should not be called beyond the end
	// of the partition - otherwise, undefined behavior will result.
	next(ctx context.Context)

	// frameStartIdx returns the index of the first row in the window frame for
	// the current row. If no such row exists, frameStartIndex returns -1.
	frameStartIdx() int

	// frameEndIdx returns the index of the last row in the window frame for
	// the current row. If no such row exists, frameEndIdx returns -1.
	frameEndIdx() int

	// frameNthIdx returns the index of the nth row (starting from one) in the
	// window frame for the current row. If no such row exists, frameNthIdx
	// returns -1. frameNthIdx expects n to be greater than zero - undefined
	// behavior will result otherwise.
	frameNthIdx(n int) int

	// close should always be called upon closing of the parent operator. It
	// releases all references to enable garbage collection.
	close()
}

func newWindowFramer(
	frame *execinfrapb.WindowerSpec_Frame,
	peersColIdx int,
	ordering execinfrapb.Ordering,
	datumAlloc *rowenc.DatumAlloc,
) windowFramer {
	startBound := frame.Bounds.Start
	endBound := frame.Bounds.End
	switch frame.Mode {
	case execinfrapb.WindowerSpec_Frame_ROWS:
		switch startBound.BoundType {
		case execinfrapb.WindowerSpec_Frame_UNBOUNDED_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsUnboundedPrecedingOffsetPreceding{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsUnboundedPrecedingOffsetPrecedingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerRowsUnboundedPrecedingCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerRowsUnboundedPrecedingCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsUnboundedPrecedingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsUnboundedPrecedingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerRowsUnboundedPrecedingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerRowsUnboundedPrecedingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetPrecedingOffsetPreceding{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetPrecedingOffsetPrecedingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetPrecedingCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetPrecedingCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetPrecedingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetPrecedingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetPrecedingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetPrecedingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerRowsCurrentRowCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerRowsCurrentRowCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsCurrentRowOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsCurrentRowOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerRowsCurrentRowUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerRowsCurrentRowUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetFollowingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetFollowingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetFollowingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRowsOffsetFollowingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			}
		}
	case execinfrapb.WindowerSpec_Frame_GROUPS:
		switch startBound.BoundType {
		case execinfrapb.WindowerSpec_Frame_UNBOUNDED_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsUnboundedPrecedingOffsetPreceding{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsUnboundedPrecedingOffsetPrecedingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerGroupsUnboundedPrecedingCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerGroupsUnboundedPrecedingCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsUnboundedPrecedingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsUnboundedPrecedingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerGroupsUnboundedPrecedingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerGroupsUnboundedPrecedingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetPrecedingOffsetPreceding{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetPrecedingOffsetPrecedingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetPrecedingCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetPrecedingCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetPrecedingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetPrecedingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetPrecedingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetPrecedingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerGroupsCurrentRowCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerGroupsCurrentRowCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsCurrentRowOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsCurrentRowOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerGroupsCurrentRowUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerGroupsCurrentRowUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetFollowingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetFollowingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetFollowingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerGroupsOffsetFollowingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			}
		}
	case execinfrapb.WindowerSpec_Frame_RANGE:
		switch startBound.BoundType {
		case execinfrapb.WindowerSpec_Frame_UNBOUNDED_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeUnboundedPrecedingOffsetPreceding{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeUnboundedPrecedingOffsetPrecedingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerRangeUnboundedPrecedingCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerRangeUnboundedPrecedingCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeUnboundedPrecedingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeUnboundedPrecedingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerRangeUnboundedPrecedingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerRangeUnboundedPrecedingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetPrecedingOffsetPreceding{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetPrecedingOffsetPrecedingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetPrecedingCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetPrecedingCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetPrecedingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetPrecedingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetPrecedingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetPrecedingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerRangeCurrentRowCurrentRow{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerRangeCurrentRowCurrentRowExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeCurrentRowOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeCurrentRowOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					return &windowFramerRangeCurrentRowUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				case true:
					return &windowFramerRangeCurrentRowUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   -1,
						},
					}
				}
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetFollowingOffsetFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					if int(endBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetFollowingOffsetFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
							endOffset:   int(endBound.IntOffset),
						},
					}
				}
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				switch frame.Exclusion != execinfrapb.WindowerSpec_Frame_NO_EXCLUSION {
				case false:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetFollowingUnboundedFollowing{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
						},
					}
				case true:
					if int(startBound.IntOffset) < 0 {
						colexecerror.ExpectedError(errors.Errorf("window frame offset out of range"))
					}
					return &windowFramerRangeOffsetFollowingUnboundedFollowingExclude{
						windowFramerBase: windowFramerBase{
							peersColIdx: peersColIdx,
							unordered:   len(ordering.Columns) == 0,
							exclusion:   frame.Exclusion,
							ordColIdx:   int(ordering.Columns[0].ColIdx),
							ordColAsc:   ordering.Columns[0].Direction == execinfrapb.Ordering_Column_ASC,
							startOffset: int(startBound.IntOffset),
						},
					}
				}
			}
		}
	}
	colexecerror.InternalError(errors.AssertionFailedf("unsupported window framer type"))
	return nil
}

// windowFramerBase extracts common fields and methods for window framer
// operators.
type windowFramerBase struct {
	// storedCols stores the columns for which any row in the partition may be
	// accessed during evaluation of the window frame. The window framer operators
	// are not responsible for handling the SpillingBuffer other than to release
	// the reference after close is called.
	storedCols *colexecutils.SpillingBuffer

	partitionSize int // The total number of tuples in the partition.
	currentRow    int // The index of the current row.
	currentGroup  int // The index of the current peer group.
	startIdx      int // Inclusive start of the window frame ignoring exclusion.
	endIdx        int // Exclusive end of the window frame ignoring exclusion.
	exStartIdx    int // Inclusive start index of the excluded rows (if any).
	exEndIdx      int // Exclusive end index of the excluded rows.
	startOffset   int // Input value when the start bound has an offset.
	endOffset     int // Input value when the end bound has an offset.

	exclusion   execinfrapb.WindowerSpec_Frame_Exclusion
	unordered   bool
	ordColAsc   bool
	ordColIdx   int
	peersColIdx int
}

type windowFramerRowsUnboundedPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsUnboundedPrecedingOffsetPreceding) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow - f.endOffset
	if f.endIdx < 0 {
		f.endIdx = 0
	}
	f.currentRow++
}

func (f *windowFramerRowsUnboundedPrecedingOffsetPreceding) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingOffsetPreceding) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingOffsetPreceding) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsUnboundedPrecedingOffsetPrecedingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingOffsetPrecedingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingOffsetPrecedingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsUnboundedPrecedingOffsetPrecedingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow - f.endOffset
	if f.endIdx < 0 {
		f.endIdx = 0
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsUnboundedPrecedingOffsetPrecedingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingOffsetPrecedingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingOffsetPrecedingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsUnboundedPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsUnboundedPrecedingCurrentRow) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	f.currentRow++
}

func (f *windowFramerRowsUnboundedPrecedingCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsUnboundedPrecedingCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsUnboundedPrecedingCurrentRowExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsUnboundedPrecedingCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsUnboundedPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsUnboundedPrecedingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow + f.startOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	f.currentRow++
}

func (f *windowFramerRowsUnboundedPrecedingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsUnboundedPrecedingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsUnboundedPrecedingOffsetFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow + f.startOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsUnboundedPrecedingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsUnboundedPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsUnboundedPrecedingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetPrecedingOffsetPreceding) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow - f.endOffset
	if f.endIdx < 0 {
		f.endIdx = 0
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetPrecedingOffsetPreceding) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingOffsetPreceding) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingOffsetPreceding) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetPrecedingOffsetPrecedingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingOffsetPrecedingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingOffsetPrecedingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetPrecedingOffsetPrecedingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow - f.endOffset
	if f.endIdx < 0 {
		f.endIdx = 0
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetPrecedingOffsetPrecedingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingOffsetPrecedingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingOffsetPrecedingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetPrecedingCurrentRow) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	f.currentRow++
}

func (f *windowFramerRowsOffsetPrecedingCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetPrecedingCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetPrecedingCurrentRowExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetPrecedingCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetPrecedingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + f.startOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetPrecedingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetPrecedingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetPrecedingOffsetFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + f.startOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetPrecedingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetPrecedingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerRowsOffsetPrecedingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetPrecedingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetPrecedingUnboundedFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetPrecedingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetPrecedingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsCurrentRowCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsCurrentRowCurrentRow) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	f.currentRow++
}

func (f *windowFramerRowsCurrentRowCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsCurrentRowCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsCurrentRowCurrentRowExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsCurrentRowCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsCurrentRowOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsCurrentRowOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.currentRow + f.startOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	f.currentRow++
}

func (f *windowFramerRowsCurrentRowOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsCurrentRowOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsCurrentRowOffsetFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.currentRow + f.startOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsCurrentRowOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsCurrentRowUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsCurrentRowUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerRowsCurrentRowUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsCurrentRowUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsCurrentRowUnboundedFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsCurrentRowUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsCurrentRowUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetFollowingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetFollowingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetFollowingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetFollowingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow + f.startOffset
	if f.startIdx > f.partitionSize {
		f.startIdx = f.partitionSize
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + f.startOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetFollowingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetFollowingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetFollowingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetFollowingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetFollowingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetFollowingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetFollowingOffsetFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow + f.startOffset
	if f.startIdx > f.partitionSize {
		f.startIdx = f.partitionSize
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + f.startOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetFollowingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetFollowingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetFollowingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetFollowingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetFollowingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetFollowingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetFollowingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow + f.startOffset
	if f.startIdx > f.partitionSize {
		f.startIdx = f.partitionSize
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerRowsOffsetFollowingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetFollowingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetFollowingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRowsOffsetFollowingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetFollowingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetFollowingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRowsOffsetFollowingUnboundedFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = f.currentRow + f.startOffset
	if f.startIdx > f.partitionSize {
		f.startIdx = f.partitionSize
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRowsOffsetFollowingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetFollowingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRowsOffsetFollowingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsUnboundedPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsUnboundedPrecedingOffsetPreceding) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart && f.currentGroup >= f.endOffset {
		// Advance the end index to the end of the next peer group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetPreceding) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetPreceding) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetPreceding) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsUnboundedPrecedingOffsetPrecedingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingOffsetPrecedingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingOffsetPrecedingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsUnboundedPrecedingOffsetPrecedingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart && f.currentGroup >= f.endOffset {
		// Advance the end index to the end of the next peer group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetPrecedingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetPrecedingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetPrecedingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsUnboundedPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsUnboundedPrecedingCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsUnboundedPrecedingCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsUnboundedPrecedingCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsUnboundedPrecedingCurrentRowExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsUnboundedPrecedingCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsUnboundedPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsUnboundedPrecedingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsUnboundedPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsUnboundedPrecedingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetPrecedingOffsetPreceding) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart && f.currentGroup >= f.endOffset {
		// Advance the end index to the end of the next peer group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetPrecedingOffsetPreceding) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingOffsetPreceding) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingOffsetPreceding) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetPrecedingOffsetPrecedingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingOffsetPrecedingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingOffsetPrecedingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetPrecedingOffsetPrecedingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart && f.currentGroup >= f.endOffset {
		// Advance the end index to the end of the next peer group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetPrecedingOffsetPrecedingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingOffsetPrecedingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingOffsetPrecedingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetPrecedingCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetPrecedingCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetPrecedingCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetPrecedingCurrentRowExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetPrecedingCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetPrecedingOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetPrecedingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetPrecedingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetPrecedingOffsetFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetPrecedingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetPrecedingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	if f.currentRow > 0 && currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsCurrentRowCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsCurrentRowCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsCurrentRowCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsCurrentRowCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsCurrentRowCurrentRowExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsCurrentRowCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsCurrentRowOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsCurrentRowOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsCurrentRowOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsCurrentRowOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsCurrentRowOffsetFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsCurrentRowOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsCurrentRowUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsCurrentRowUnboundedFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerGroupsCurrentRowUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsCurrentRowUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsCurrentRowUnboundedFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsCurrentRowUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsCurrentRowUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetFollowingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetFollowingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetFollowingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	// f.startIdx must be advanced by 'startOffset' peer groups.
	f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, f.startOffset)
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetFollowingOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentRow > 0 {
		// The start index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetFollowingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetFollowingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetFollowingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetFollowingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetFollowingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetFollowingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
	// f.startIdx must be advanced by 'startOffset' peer groups.
	f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, f.startOffset)
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetFollowingOffsetFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentRow > 0 {
		// The start index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetFollowingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetFollowingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetFollowingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetFollowingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetFollowingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetFollowingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	// f.startIdx must be advanced by 'startOffset' peer groups.
	f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, f.startOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetFollowingUnboundedFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentRow > 0 {
		// The start index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerGroupsOffsetFollowingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetFollowingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetFollowingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerGroupsOffsetFollowingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetFollowingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetFollowingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
	// f.startIdx must be advanced by 'startOffset' peer groups.
	f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, f.startOffset)
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerGroupsOffsetFollowingUnboundedFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentRow > 0 {
		// The start index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerGroupsOffsetFollowingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetFollowingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerGroupsOffsetFollowingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeUnboundedPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeUnboundedPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeUnboundedPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeUnboundedPrecedingOffsetPreceding) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	// TODO
	f.currentRow++
}

func (f *windowFramerRangeUnboundedPrecedingOffsetPreceding) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingOffsetPreceding) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingOffsetPreceding) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeUnboundedPrecedingOffsetPrecedingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeUnboundedPrecedingOffsetPrecedingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeUnboundedPrecedingOffsetPrecedingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeUnboundedPrecedingOffsetPrecedingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	// TODO
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeUnboundedPrecedingOffsetPrecedingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingOffsetPrecedingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingOffsetPrecedingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeUnboundedPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeUnboundedPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeUnboundedPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeUnboundedPrecedingCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeUnboundedPrecedingCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeUnboundedPrecedingCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeUnboundedPrecedingCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeUnboundedPrecedingCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeUnboundedPrecedingCurrentRowExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeUnboundedPrecedingCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeUnboundedPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeUnboundedPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeUnboundedPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeUnboundedPrecedingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	// TODO
	f.currentRow++
}

func (f *windowFramerRangeUnboundedPrecedingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeUnboundedPrecedingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeUnboundedPrecedingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeUnboundedPrecedingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeUnboundedPrecedingOffsetFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	// TODO
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeUnboundedPrecedingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeUnboundedPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeUnboundedPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeUnboundedPrecedingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeUnboundedPrecedingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeUnboundedPrecedingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetPrecedingOffsetPreceding) next(ctx context.Context) {
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	// TODO
	f.currentRow++
}

func (f *windowFramerRangeOffsetPrecedingOffsetPreceding) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingOffsetPreceding) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingOffsetPreceding) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetPrecedingOffsetPrecedingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetPrecedingOffsetPrecedingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetPrecedingOffsetPrecedingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetPrecedingOffsetPrecedingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	// TODO
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeOffsetPrecedingOffsetPrecedingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingOffsetPrecedingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingOffsetPrecedingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetPrecedingCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeOffsetPrecedingCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetPrecedingCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetPrecedingCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetPrecedingCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetPrecedingCurrentRowExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeOffsetPrecedingCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetPrecedingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	// TODO
	f.currentRow++
}

func (f *windowFramerRangeOffsetPrecedingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetPrecedingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetPrecedingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetPrecedingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetPrecedingOffsetFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	// TODO
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeOffsetPrecedingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetPrecedingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerRangeOffsetPrecedingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetPrecedingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetPrecedingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetPrecedingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetPrecedingUnboundedFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeOffsetPrecedingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetPrecedingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeCurrentRowCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeCurrentRowCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeCurrentRowCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeCurrentRowCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeCurrentRowCurrentRow) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowCurrentRow) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowCurrentRow) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeCurrentRowCurrentRowExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeCurrentRowCurrentRowExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeCurrentRowCurrentRowExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeCurrentRowCurrentRowExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeCurrentRowCurrentRowExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowCurrentRowExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowCurrentRowExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeCurrentRowOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeCurrentRowOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeCurrentRowOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeCurrentRowOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	// TODO
	f.currentRow++
}

func (f *windowFramerRangeCurrentRowOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeCurrentRowOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeCurrentRowOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeCurrentRowOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeCurrentRowOffsetFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	// TODO
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeCurrentRowOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeCurrentRowUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeCurrentRowUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeCurrentRowUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeCurrentRowUnboundedFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerRangeCurrentRowUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeCurrentRowUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeCurrentRowUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeCurrentRowUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeCurrentRowUnboundedFollowingExclude) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeCurrentRowUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeCurrentRowUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetFollowingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetFollowingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetFollowingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetFollowingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	// TODO
	f.currentRow++
}

func (f *windowFramerRangeOffsetFollowingOffsetFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetFollowingOffsetFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetFollowingOffsetFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetFollowingOffsetFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetFollowingOffsetFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetFollowingOffsetFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetFollowingOffsetFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	// TODO
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeOffsetFollowingOffsetFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetFollowingOffsetFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetFollowingOffsetFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetFollowingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetFollowingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetFollowingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetFollowingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

func (f *windowFramerRangeOffsetFollowingUnboundedFollowing) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetFollowingUnboundedFollowing) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetFollowingUnboundedFollowing) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

type windowFramerRangeOffsetFollowingUnboundedFollowingExclude struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRangeOffsetFollowingUnboundedFollowingExclude{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRangeOffsetFollowingUnboundedFollowingExclude) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.exStartIdx = 0
	f.exEndIdx = 0
}

// Next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row.
func (f *windowFramerRangeOffsetFollowingUnboundedFollowingExclude) next(ctx context.Context) {
	var currRowIsGroupStart bool
	if !f.excludeCurrRow() {
		currRowIsGroupStart = f.isFirstPeer(ctx, f.currentRow)
	}
	// Handle the start bound.
	// TODO
	// Handle the end bound.
	f.endIdx = f.partitionSize
	// Handle the exclusion clause.
	if f.excludeCurrRow() {
		f.exStartIdx = f.currentRow
		f.exEndIdx = f.currentRow + 1
	} else if currRowIsGroupStart {
		// The current row is the start of a new peers group. We need to update the
		// exclusion indices.
		f.exStartIdx, f.exEndIdx = f.currentRow, f.currentRow
		f.exEndIdx = f.incrementPeerGroup(ctx, f.exEndIdx, 1 /* groups */)
	}
	f.currentRow++
}

func (f *windowFramerRangeOffsetFollowingUnboundedFollowingExclude) frameStartIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	idx = f.startIdx
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the start of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exEndIdx
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no start index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetFollowingUnboundedFollowingExclude) frameEndIdx() (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	idx = f.endIdx - 1
	if f.exStartIdx <= idx && f.exEndIdx > idx {
		// The excluded rows overlap with the end of the frame, so we will have to
		// adjust the index.
		if f.excludeGroup() || f.excludeCurrRow() {
			idx = f.exStartIdx - 1
		} else {
			idx = f.currentRow
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The window frame is empty, so there is no end index.
		idx = -1
	}
	return idx
}

func (f *windowFramerRangeOffsetFollowingUnboundedFollowingExclude) frameNthIdx(n int) (idx int) {
	if f.startIdx >= f.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = f.startIdx + n
	if f.exStartIdx <= idx {
		// The index is located beyond the excluded rows.
		offset := f.exEndIdx - f.exStartIdx
		if f.exStartIdx < f.startIdx {
			// Don't include rows beyond startIdx in the offset.
			offset -= f.startIdx - f.exStartIdx
		}
		idx += offset
		if f.excludeTies() {
			// The current row is not excluded, so we have incremented the index too
			// far.
			idx--
			if idx < f.exEndIdx {
				idx = f.currentRow
			}
		}
	}
	if idx < f.startIdx || idx >= f.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

// incrementPeerGroup increments the given index by 'groups' peer groups,
// returning the resulting index. If the given offset is greater than the
// remaining number of groups, the returned index will be equal to the size of
// the partition.
func (b *windowFramerBase) incrementPeerGroup(ctx context.Context, index, groups int) int {
	for {
		if groups <= 0 || index >= b.partitionSize {
			break
		}
		groups--
		index++
		if b.isFirstPeer(ctx, index) {
			// We have reached the start of the next peer group (the end of the
			// current one).
			break
		}
	}
	return index
}

func (b *windowFramerBase) isFirstPeer(ctx context.Context, idx int) bool {
	if idx == 0 {
		// The first row in the partition is always the first in its peer group.
		return true
	}
	if b.unordered {
		// All rows are peers, so only the first is the first in its peer group.
		return false
	}
	batch, batchIdx := b.storedCols.GetBatchWithTuple(ctx, idx)
	return batch.ColVec(b.peersColIdx).Bool()[batchIdx]
}

// getColsToStore appends to the given slice of column indices whatever columns
// to which the window framer will need access. getColsToStore also remaps the
// corresponding fields in the window framer to refer to ordinal positions
// within the colsToStore slice rather than within the input batches.
func (b *windowFramerBase) getColsToStore(oldColsToStore []int) (colsToStore []int) {
	colsToStore = oldColsToStore
	storeCol := func(colIdx int) int {
		for i := range colsToStore {
			if colsToStore[i] == colIdx {
				// The column is already present in colsToStore. Do not store any column
				// more than once.
				return i
			}
		}
		colsToStore = append(colsToStore, colIdx)
		return len(colsToStore) - 1
	}
	if b.peersColIdx != -1 {
		b.peersColIdx = storeCol(b.peersColIdx)
	}
	if b.ordColIdx != -1 {
		b.ordColIdx = storeCol(b.ordColIdx)
	}
	return colsToStore
}

func decodeOffset(
	datumAlloc *rowenc.DatumAlloc, offsetType *types.T, typedOffset []byte,
) interface{} {
	datum, rem, err := rowenc.DecodeTableValue(datumAlloc, offsetType, typedOffset)
	if err != nil {
		colexecerror.InternalError(errors.NewAssertionErrorWithWrappedErrf(err,
			"error decoding %d bytes", errors.Safe(len(typedOffset))))
	}
	if len(rem) != 0 {
		colexecerror.InternalError(errors.AssertionFailedf(
			"%d trailing bytes in encoded value", errors.Safe(len(rem))))
	}
	typeConverter := colconv.GetDatumToPhysicalFn(offsetType)
	return typeConverter(datum)
}

func (b *windowFramerBase) excludeCurrRow() bool {
	return b.exclusion == execinfrapb.WindowerSpec_Frame_EXCLUDE_CURRENT_ROW
}

func (b *windowFramerBase) excludeGroup() bool {
	return b.exclusion == execinfrapb.WindowerSpec_Frame_EXCLUDE_GROUP
}

func (b *windowFramerBase) excludeTies() bool {
	return b.exclusion == execinfrapb.WindowerSpec_Frame_EXCLUDE_TIES
}

func (b *windowFramerBase) close() {
	b.storedCols = nil
}
