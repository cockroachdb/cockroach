// Code generated by execgen; DO NOT EDIT.
// Copyright 2021 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexecwindow

import (
	"context"

	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecutils"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/execinfrapb"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/errors"
)

// windowFramer is used to calculate the window frame for each row in a
// partition.
type windowFramer interface {
	// getColsToStore is called upon initialization of the windowFramer operators
	// in order to add to the list of columns to store in the SpillingBuffer owned
	// by the parent operator.
	// getColsToStore adds column indices to the given list when the windowFramer
	// operator needs access to values in a column for each partition (for
	// example, the peer groups column). If a column to be stored is already
	// present in the list, a duplicate entry will not be created.
	getColsToStore(oldColsToStore []int) (colsToStore []int)

	// startPartition is called before each partition is processed. It initializes
	// the windowFramer operators with the size of the partition and stored
	// columns. It also resets any fields used for window frame calculation.
	startPartition(ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer)

	// next should be called for each row in the partition. It calculates the
	// window frame for the current row and advances to the next row (windowFramer
	// keeps track internally of the index of the current row starting from zero).
	// next should not be called beyond the end of the partition - otherwise,
	// undefined behavior will result.
	next(ctx context.Context)

	// frameFirstIdx returns the index of the first row in the window frame for
	// the current row. If no such row exists, frameFirstIdx returns -1.
	frameFirstIdx() int

	// frameLastIdx returns the index of the last row in the window frame for
	// the current row. If no such row exists, frameLastIdx returns -1. Note that
	// this index is inclusive.
	frameLastIdx() int

	// frameNthIdx returns the index of the nth row (starting from one) in the
	// window frame for the current row. If no such row exists, frameNthIdx
	// returns -1.
	frameNthIdx(n int) int

	// close should always be called upon closing of the parent operator. It
	// releases all references to enable garbage collection.
	close()
}

func newWindowFramer(frame *execinfrapb.WindowerSpec_Frame, peersColIdx int) windowFramer {
	startBound := frame.Bounds.Start
	endBound := frame.Bounds.End
	switch frame.Mode {
	case execinfrapb.WindowerSpec_Frame_ROWS:
		switch startBound.BoundType {
		case execinfrapb.WindowerSpec_Frame_UNBOUNDED_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				op := &windowFramerRowsUnboundedPrecedingOffsetPreceding{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				op := &windowFramerRowsUnboundedPrecedingCurrentRow{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				return op
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				op := &windowFramerRowsUnboundedPrecedingOffsetFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				op := &windowFramerRowsUnboundedPrecedingUnboundedFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				return op
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				op := &windowFramerRowsOffsetPrecedingOffsetPreceding{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				op := &windowFramerRowsOffsetPrecedingCurrentRow{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				op := &windowFramerRowsOffsetPrecedingOffsetFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				op := &windowFramerRowsOffsetPrecedingUnboundedFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				return op
			}
		case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				op := &windowFramerRowsCurrentRowCurrentRow{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				return op
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				op := &windowFramerRowsCurrentRowOffsetFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				op := &windowFramerRowsCurrentRowUnboundedFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				return op
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				op := &windowFramerRowsOffsetFollowingOffsetFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				op := &windowFramerRowsOffsetFollowingUnboundedFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				return op
			}
		}
	case execinfrapb.WindowerSpec_Frame_GROUPS:
		switch startBound.BoundType {
		case execinfrapb.WindowerSpec_Frame_UNBOUNDED_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				op := &windowFramerGroupsUnboundedPrecedingOffsetPreceding{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				op := &windowFramerGroupsUnboundedPrecedingCurrentRow{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				return op
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				op := &windowFramerGroupsUnboundedPrecedingOffsetFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				op := &windowFramerGroupsUnboundedPrecedingUnboundedFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				return op
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_PRECEDING:
				op := &windowFramerGroupsOffsetPrecedingOffsetPreceding{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				op := &windowFramerGroupsOffsetPrecedingCurrentRow{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				op := &windowFramerGroupsOffsetPrecedingOffsetFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				op := &windowFramerGroupsOffsetPrecedingUnboundedFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				return op
			}
		case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_CURRENT_ROW:
				op := &windowFramerGroupsCurrentRowCurrentRow{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				return op
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				op := &windowFramerGroupsCurrentRowOffsetFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				op := &windowFramerGroupsCurrentRowUnboundedFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				return op
			}
		case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
			switch endBound.BoundType {
			case execinfrapb.WindowerSpec_Frame_OFFSET_FOLLOWING:
				op := &windowFramerGroupsOffsetFollowingOffsetFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				op.endOffset = int(endBound.IntOffset)
				return op
			case execinfrapb.WindowerSpec_Frame_UNBOUNDED_FOLLOWING:
				op := &windowFramerGroupsOffsetFollowingUnboundedFollowing{
					windowFramerBase: windowFramerBase{
						peersColIdx: peersColIdx,
					},
				}
				op.startOffset = int(startBound.IntOffset)
				return op
			}
		}
	}
	colexecerror.InternalError(errors.AssertionFailedf("unsupported window framer type"))
	return nil
}

// windowFramerBase extracts common fields and methods for window framer
// operators.
type windowFramerBase struct {
	// storedCols stores the columns for which any row in the partition may be
	// accessed during evaluation of the window frame. The window framer operators
	// are not responsible for handling the SpillingBuffer other than to release
	// the reference after close is called.
	storedCols *colexecutils.SpillingBuffer

	partitionSize int // The total number of tuples in the partition.
	currentRow    int // The index of the current row.
	currentGroup  int // The index of the current peer group, used by GROUPS mode.
	startIdx      int // Inclusive start of the window frame ignoring exclusion.
	endIdx        int // Exclusive end of the window frame ignoring exclusion.
	startOffset   int // Input value when the start bound has an offset.
	endOffset     int // Input value when the end bound has an offset.

	peersColIdx int
}

type windowFramerRowsUnboundedPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsUnboundedPrecedingOffsetPreceding) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow - f.endOffset + 1
	if f.endIdx < 0 {
		f.endIdx = 0
	}
	f.currentRow++
}

type windowFramerRowsUnboundedPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsUnboundedPrecedingCurrentRow) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	f.currentRow++
}

type windowFramerRowsUnboundedPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsUnboundedPrecedingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.currentRow + f.endOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	f.currentRow++
}

type windowFramerRowsUnboundedPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsUnboundedPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsUnboundedPrecedingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

type windowFramerRowsOffsetPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsOffsetPrecedingOffsetPreceding) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow - f.endOffset + 1
	if f.endIdx < 0 {
		f.endIdx = 0
	}
	f.currentRow++
}

type windowFramerRowsOffsetPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsOffsetPrecedingCurrentRow) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	f.currentRow++
}

type windowFramerRowsOffsetPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsOffsetPrecedingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + f.endOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	f.currentRow++
}

type windowFramerRowsOffsetPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsOffsetPrecedingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow - f.startOffset
	if f.startIdx < 0 {
		f.startIdx = 0
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

type windowFramerRowsCurrentRowCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsCurrentRowCurrentRow) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.currentRow + 1
	f.currentRow++
}

type windowFramerRowsCurrentRowOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsCurrentRowOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.currentRow + f.endOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	f.currentRow++
}

type windowFramerRowsCurrentRowUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsCurrentRowUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsCurrentRowUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsCurrentRowUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

type windowFramerRowsOffsetFollowingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetFollowingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetFollowingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsOffsetFollowingOffsetFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow + f.startOffset
	if f.startIdx > f.partitionSize {
		f.startIdx = f.partitionSize
	}
	// Handle the end bound.
	f.endIdx = f.currentRow + f.endOffset + 1
	if f.endIdx > f.partitionSize {
		f.endIdx = f.partitionSize
	}
	f.currentRow++
}

type windowFramerRowsOffsetFollowingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerRowsOffsetFollowingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerRowsOffsetFollowingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerRowsOffsetFollowingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = f.currentRow + f.startOffset
	if f.startIdx > f.partitionSize {
		f.startIdx = f.partitionSize
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

type windowFramerGroupsUnboundedPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsUnboundedPrecedingOffsetPreceding) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart && f.currentGroup >= f.endOffset {
		// Advance the end index to the end of the next peer group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	if currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

type windowFramerGroupsUnboundedPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsUnboundedPrecedingCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

type windowFramerGroupsUnboundedPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsUnboundedPrecedingOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

type windowFramerGroupsUnboundedPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsUnboundedPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsUnboundedPrecedingUnboundedFollowing) next(ctx context.Context) {
	// Handle the start bound.
	f.startIdx = 0
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

type windowFramerGroupsOffsetPrecedingOffsetPreceding struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingOffsetPreceding{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingOffsetPreceding) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsOffsetPrecedingOffsetPreceding) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart && f.currentGroup >= f.endOffset {
		// Advance the end index to the end of the next peer group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	if currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

type windowFramerGroupsOffsetPrecedingCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsOffsetPrecedingCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	if currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

type windowFramerGroupsOffsetPrecedingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsOffsetPrecedingOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	if currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

type windowFramerGroupsOffsetPrecedingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetPrecedingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	f.currentGroup = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsOffsetPrecedingUnboundedFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentGroup > f.startOffset {
		// Advance the start index to the start of the next peer group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	if currRowIsGroupStart {
		f.currentGroup++
	}
	f.currentRow++
}

type windowFramerGroupsCurrentRowCurrentRow struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowCurrentRow{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowCurrentRow) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsCurrentRowCurrentRow) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

type windowFramerGroupsCurrentRowOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsCurrentRowOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

type windowFramerGroupsCurrentRowUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsCurrentRowUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsCurrentRowUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsCurrentRowUnboundedFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart {
		f.startIdx = f.currentRow
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

type windowFramerGroupsOffsetFollowingOffsetFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetFollowingOffsetFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetFollowingOffsetFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	// f.startIdx must be advanced by 'startOffset' peer groups.
	f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, f.startOffset)
	// f.endIdx must be advanced by 'endOffset' peer groups.
	f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, f.endOffset)
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsOffsetFollowingOffsetFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentRow > 0 {
		// The start index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	if currRowIsGroupStart {
		// The end index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.endIdx = f.incrementPeerGroup(ctx, f.endIdx, 1 /* groups */)
	}
	f.currentRow++
}

type windowFramerGroupsOffsetFollowingUnboundedFollowing struct {
	windowFramerBase
}

var _ windowFramer = &windowFramerGroupsOffsetFollowingUnboundedFollowing{}

// startPartition prepares the window framer to begin iterating through a new
// partition.
func (f *windowFramerGroupsOffsetFollowingUnboundedFollowing) startPartition(
	ctx context.Context, partitionSize int, storedCols *colexecutils.SpillingBuffer,
) {
	f.partitionSize = partitionSize
	f.storedCols = storedCols
	f.currentRow = 0
	f.startIdx = 0
	f.endIdx = 0
	// f.startIdx must be advanced by 'startOffset' peer groups.
	f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, f.startOffset)
}

// next is called for each row in the partition. It calculates the window frame
// for the current row and then advances to the next row. next should not be
// called beyond the end of the partition - otherwise, undefined behavior will
// result.
func (f *windowFramerGroupsOffsetFollowingUnboundedFollowing) next(ctx context.Context) {
	currRowIsGroupStart := f.isFirstPeer(ctx, f.currentRow)
	// Handle the start bound.
	if currRowIsGroupStart && f.currentRow > 0 {
		// The start index will already have been advanced by f.startOffset rows, so
		// we only need to advance to the next adjacent peers group whenever the
		// currentRow pointer enters a new peers group.
		f.startIdx = f.incrementPeerGroup(ctx, f.startIdx, 1 /* groups */)
	}
	// Handle the end bound.
	f.endIdx = f.partitionSize
	f.currentRow++
}

// frameFirstIdx returns the index of the first row in the window frame for
// the current row. If no such row exists, frameFirstIdx returns -1.
func (b *windowFramerBase) frameFirstIdx() (idx int) {
	if b.startIdx >= b.endIdx {
		// The window frame is empty, so there is no start index.
		return -1
	}
	return b.startIdx
}

// frameLastIdx returns the index of the last row in the window frame for
// the current row. If no such row exists, frameLastIdx returns -1.
func (b *windowFramerBase) frameLastIdx() (idx int) {
	if b.startIdx >= b.endIdx {
		// The window frame is empty, so there is no end index.
		return -1
	}
	return b.endIdx - 1
}

// frameNthIdx returns the index of the nth row (starting from one) in the
// window frame for the current row. If no such row exists, frameNthIdx
// returns -1.
func (b *windowFramerBase) frameNthIdx(n int) (idx int) {
	if b.startIdx >= b.endIdx {
		// The window frame is empty, so there is no nth index.
		return -1
	}
	// Subtract from n to make it a zero-based index.
	n = n - 1
	idx = b.startIdx + n
	if idx < 0 || idx >= b.endIdx {
		// The requested index is out of range for this window frame.
		idx = -1
	}
	return idx
}

// incrementPeerGroup increments the given index by 'groups' peer groups,
// returning the resulting index. If the given offset is greater than the
// remaining number of groups, the returned index will be equal to the size of
// the partition.
func (b *windowFramerBase) incrementPeerGroup(ctx context.Context, index, groups int) int {
	for {
		if groups <= 0 {
			break
		}
		index++
		if index >= b.partitionSize {
			index = b.partitionSize
			break
		}
		if b.isFirstPeer(ctx, index) {
			// We have reached the start of the next peer group (the end of the
			// current one).
			groups--
		}
	}
	return index
}

func (b *windowFramerBase) isFirstPeer(ctx context.Context, idx int) bool {
	if idx == 0 {
		// The first row in the partition is always the first in its peer group.
		return true
	}
	if b.peersColIdx == tree.NoColumnIdx {
		// All rows are peers, so only the first is the first in its peer group.
		return false
	}
	batch, batchIdx := b.storedCols.GetBatchWithTuple(ctx, idx)
	return batch.ColVec(b.peersColIdx).Bool()[batchIdx]
}

// getColsToStore appends to the given slice of column indices whatever columns
// to which the window framer will need access. getColsToStore also remaps the
// corresponding fields in the window framer to refer to ordinal positions
// within the colsToStore slice rather than within the input batches.
func (b *windowFramerBase) getColsToStore(oldColsToStore []int) (colsToStore []int) {
	colsToStore = oldColsToStore
	storeCol := func(colIdx int) int {
		for i := range colsToStore {
			if colsToStore[i] == colIdx {
				// The column is already present in colsToStore. Do not store any column
				// more than once.
				return i
			}
		}
		colsToStore = append(colsToStore, colIdx)
		return len(colsToStore) - 1
	}
	if b.peersColIdx != tree.NoColumnIdx {
		b.peersColIdx = storeCol(b.peersColIdx)
	}
	return colsToStore
}

func (b *windowFramerBase) close() {
	b.storedCols = nil
}
