// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"fmt"
	"math"
	"reflect"
	"unsafe"

	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.UNSAFEGET

// rehash takes an element of a key (tuple representing a row of equality
// column values) at a given column and computes a new hash by applying a
// transformation to the existing hash.
func (ht *hashTable) rehash(
	ctx context.Context,
	buckets []uint64,
	keyIdx int,
	t coltypes.T,
	col coldata.Vec,
	nKeys uint64,
	sel []uint16,
) {
	switch t {
	case coltypes.Bool:
		keys, nulls := col.Bool(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Bytes:
		keys, nulls := col.Bytes(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys.Get(int(nKeys - 1))
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys.Get(int(nKeys - 1))
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Decimal:
		keys, nulls := col.Decimal(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					b := []byte(v.String())
					sh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(b)))

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					b := []byte(v.String())
					sh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(b)))

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					b := []byte(v.String())
					sh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(b)))

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					b := []byte(v.String())
					sh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(b)))

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Int16:
		keys, nulls := col.Int16(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash16(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash16(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash16(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash16(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Int32:
		keys, nulls := col.Int32(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash32(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash32(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash32(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash32(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Int64:
		keys, nulls := col.Int64(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash64(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash64(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash64(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash64(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Float64:
		keys, nulls := col.Float64(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					f := v
					if math.IsNaN(float64(f)) {
						f = 0
					}
					p = f64hash(noescape(unsafe.Pointer(&f)), p)

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					f := v
					if math.IsNaN(float64(f)) {
						f = 0
					}
					p = f64hash(noescape(unsafe.Pointer(&f)), p)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					f := v
					if math.IsNaN(float64(f)) {
						f = 0
					}
					p = f64hash(noescape(unsafe.Pointer(&f)), p)

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					f := v
					if math.IsNaN(float64(f)) {
						f = 0
					}
					p = f64hash(noescape(unsafe.Pointer(&f)), p)

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Timestamp:
		keys, nulls := col.Timestamp(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					s := v.UnixNano()
					p = memhash64(noescape(unsafe.Pointer(&s)), p)

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					s := v.UnixNano()
					p = memhash64(noescape(unsafe.Pointer(&s)), p)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					s := v.UnixNano()
					p = memhash64(noescape(unsafe.Pointer(&s)), p)

					buckets[i] = uint64(p)
				}
			} else {

				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					s := v.UnixNano()
					p = memhash64(noescape(unsafe.Pointer(&s)), p)

					buckets[i] = uint64(p)
				}
			}
		}

	default:
		execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", t))
	}
}

// checkCol determines if the current key column in the groupID buckets matches
// the specified equality column key. If there is a match, then the key is added
// to differs. If the bucket has reached the end, the key is rejected. If the
// hashTable disallows null equality, then if any element in the key is null,
// there is no match.
func (ht *hashTable) checkCol(t coltypes.T, keyColIdx int, nToCheck uint16, sel []uint16) {
	switch t {
	case coltypes.Bool:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Bool()
		probeKeys := probeVec.Bool()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if !buildVal && probeVal {
											cmpResult = -1
										} else if buildVal && !probeVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if !buildVal && probeVal {
											cmpResult = -1
										} else if buildVal && !probeVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if !buildVal && probeVal {
											cmpResult = -1
										} else if buildVal && !probeVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if !buildVal && probeVal {
											cmpResult = -1
										} else if buildVal && !probeVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		}
	case coltypes.Bytes:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Bytes()
		probeKeys := probeVec.Bytes()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys.Get(int(keyID - 1))
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(buildVal, probeVal)
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys.Get(int(keyID - 1))
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(buildVal, probeVal)
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys.Get(int(keyID - 1))
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(buildVal, probeVal)
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys.Get(int(keyID - 1))
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(buildVal, probeVal)
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		}
	case coltypes.Decimal:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Decimal()
		probeKeys := probeVec.Decimal()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		}
	case coltypes.Int16:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int16()
		probeKeys := probeVec.Int16()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		}
	case coltypes.Int32:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int32()
		probeKeys := probeVec.Int32()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		}
	case coltypes.Int64:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int64()
		probeKeys := probeVec.Int64()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		}
	case coltypes.Float64:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Float64()
		probeKeys := probeVec.Float64()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(buildVal), float64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(buildVal), float64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(buildVal), float64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(buildVal), float64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		}
	case coltypes.Timestamp:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Timestamp()
		probeKeys := probeVec.Timestamp()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if buildVal.Before(probeVal) {
											cmpResult = -1
										} else if probeVal.Before(buildVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if buildVal.Before(probeVal) {
											cmpResult = -1
										} else if probeVal.Before(buildVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if buildVal.Before(probeVal) {
											cmpResult = -1
										} else if probeVal.Before(buildVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if buildVal.Before(probeVal) {
											cmpResult = -1
										} else if probeVal.Before(buildVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									if unique {
										ht.differs[toCheck] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								if unique {
									ht.differs[toCheck] = true
								}
							}
						}
					}
				}
			}
		}
	default:
		execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", t))
	}
}

// collect prepares the buildIdx and probeIdx arrays where the buildIdx and
// probeIdx at each index are joined to make an output row. The total number of
// resulting rows is returned.
func (prober *hashJoinProber) collect(batch coldata.Batch, batchSize uint16, sel []uint16) uint16 {
	nResults := uint16(0)

	if prober.spec.outer {
		if sel != nil {

			// Early bounds checks.
			_ = prober.ht.headID[batchSize-1]
			_ = sel[batchSize-1]
			for i := uint16(0); i < batchSize; i++ {
				currentID := prober.ht.headID[i]

				for {
					if nResults >= prober.outputBatchSize {
						prober.prevBatch = batch
						return nResults
					}

					prober.probeRowUnmatched[nResults] = currentID == 0
					if currentID > 0 {
						prober.buildIdx[nResults] = currentID - 1
					} else {
						// If currentID == 0, then probeRowUnmatched will have been set - and
						// we set the corresponding buildIdx to zero so that (as long as the
						// build hash table has at least one row) we can copy the values vector
						// without paying attention to probeRowUnmatched.
						prober.buildIdx[nResults] = 0
					}
					prober.probeIdx[nResults] = sel[i]
					currentID = prober.ht.same[currentID]
					prober.ht.headID[i] = currentID
					nResults++

					if currentID == 0 {
						break
					}
				}
			}
		} else {

			// Early bounds checks.
			_ = prober.ht.headID[batchSize-1]
			for i := uint16(0); i < batchSize; i++ {
				currentID := prober.ht.headID[i]

				for {
					if nResults >= prober.outputBatchSize {
						prober.prevBatch = batch
						return nResults
					}

					prober.probeRowUnmatched[nResults] = currentID == 0
					if currentID > 0 {
						prober.buildIdx[nResults] = currentID - 1
					} else {
						// If currentID == 0, then probeRowUnmatched will have been set - and
						// we set the corresponding buildIdx to zero so that (as long as the
						// build hash table has at least one row) we can copy the values vector
						// without paying attention to probeRowUnmatched.
						prober.buildIdx[nResults] = 0
					}
					prober.probeIdx[nResults] = i
					currentID = prober.ht.same[currentID]
					prober.ht.headID[i] = currentID
					nResults++

					if currentID == 0 {
						break
					}
				}
			}
		}
	} else {
		if sel != nil {

			// Early bounds checks.
			_ = prober.ht.headID[batchSize-1]
			_ = sel[batchSize-1]
			for i := uint16(0); i < batchSize; i++ {
				currentID := prober.ht.headID[i]
				for currentID != 0 {
					if nResults >= prober.outputBatchSize {
						prober.prevBatch = batch
						return nResults
					}

					prober.buildIdx[nResults] = currentID - 1
					prober.probeIdx[nResults] = sel[i]
					currentID = prober.ht.same[currentID]
					prober.ht.headID[i] = currentID
					nResults++
				}
			}
		} else {

			// Early bounds checks.
			_ = prober.ht.headID[batchSize-1]
			for i := uint16(0); i < batchSize; i++ {
				currentID := prober.ht.headID[i]
				for currentID != 0 {
					if nResults >= prober.outputBatchSize {
						prober.prevBatch = batch
						return nResults
					}

					prober.buildIdx[nResults] = currentID - 1
					prober.probeIdx[nResults] = i
					currentID = prober.ht.same[currentID]
					prober.ht.headID[i] = currentID
					nResults++
				}
			}
		}
	}

	return nResults
}

// distinctCollect prepares the batch with the joined output columns where the build
// row index for each probe row is given in the groupID slice. This function
// requires assumes a N-1 hash join.
func (prober *hashJoinProber) distinctCollect(
	batch coldata.Batch, batchSize uint16, sel []uint16,
) uint16 {
	nResults := uint16(0)

	if prober.spec.outer {
		nResults = batchSize

		if sel != nil {

			// Early bounds checks.
			_ = prober.ht.groupID[batchSize-1]
			_ = prober.probeRowUnmatched[batchSize-1]
			_ = prober.buildIdx[batchSize-1]
			_ = prober.probeIdx[batchSize-1]
			_ = sel[batchSize-1]
			for i := uint16(0); i < batchSize; i++ {
				// Index of keys and outputs in the hash table is calculated as ID - 1.
				id := prober.ht.groupID[i]
				rowUnmatched := id == 0
				prober.probeRowUnmatched[i] = rowUnmatched
				if !rowUnmatched {
					prober.buildIdx[i] = id - 1
				}
				prober.probeIdx[i] = sel[i]
			}
		} else {

			// Early bounds checks.
			_ = prober.ht.groupID[batchSize-1]
			_ = prober.probeRowUnmatched[batchSize-1]
			_ = prober.buildIdx[batchSize-1]
			_ = prober.probeIdx[batchSize-1]
			for i := uint16(0); i < batchSize; i++ {
				// Index of keys and outputs in the hash table is calculated as ID - 1.
				id := prober.ht.groupID[i]
				rowUnmatched := id == 0
				prober.probeRowUnmatched[i] = rowUnmatched
				if !rowUnmatched {
					prober.buildIdx[i] = id - 1
				}
				prober.probeIdx[i] = i
			}
		}
	} else {
		if sel != nil {

			// Early bounds checks.
			_ = prober.ht.groupID[batchSize-1]
			_ = prober.buildIdx[batchSize-1]
			_ = prober.probeIdx[batchSize-1]
			_ = sel[batchSize-1]
			for i := uint16(0); i < batchSize; i++ {
				if prober.ht.groupID[i] != 0 {
					// Index of keys and outputs in the hash table is calculated as ID - 1.
					prober.buildIdx[nResults] = prober.ht.groupID[i] - 1
					prober.probeIdx[nResults] = sel[i]
					nResults++
				}
			}
		} else {

			// Early bounds checks.
			_ = prober.ht.groupID[batchSize-1]
			_ = prober.buildIdx[batchSize-1]
			_ = prober.probeIdx[batchSize-1]
			for i := uint16(0); i < batchSize; i++ {
				if prober.ht.groupID[i] != 0 {
					// Index of keys and outputs in the hash table is calculated as ID - 1.
					prober.buildIdx[nResults] = prober.ht.groupID[i] - 1
					prober.probeIdx[nResults] = i
					nResults++
				}
			}
		}
	}

	return nResults
}
