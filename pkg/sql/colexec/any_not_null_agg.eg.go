// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"time"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/pkg/errors"
)

func newAnyNotNullAgg(allocator *Allocator, t coltypes.T) (aggregateFunc, error) {
	switch t {
	case coltypes.Bool:
		return &anyNotNullBoolAgg{allocator: allocator}, nil
	case coltypes.Bytes:
		return &anyNotNullBytesAgg{allocator: allocator}, nil
	case coltypes.Decimal:
		return &anyNotNullDecimalAgg{allocator: allocator}, nil
	case coltypes.Int16:
		return &anyNotNullInt16Agg{allocator: allocator}, nil
	case coltypes.Int32:
		return &anyNotNullInt32Agg{allocator: allocator}, nil
	case coltypes.Int64:
		return &anyNotNullInt64Agg{allocator: allocator}, nil
	case coltypes.Float64:
		return &anyNotNullFloat64Agg{allocator: allocator}, nil
	case coltypes.Timestamp:
		return &anyNotNullTimestampAgg{allocator: allocator}, nil
	default:
		return nil, errors.Errorf("unsupported any not null agg type %s", t)
	}
}

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.UNSAFEGET

// anyNotNullBoolAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBoolAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         []bool
	nulls                       *coldata.Nulls
	curIdx                      int
	foundNonNullForCurrentGroup bool
}

func (a *anyNotNullBoolAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec.Bool()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBoolAgg) Reset() {
	for n := 0; n < len(a.vec); n += copy(a.vec[n:], zeroBoolColumn) {
	}
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.vec)
		target := a.vec[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroBoolColumn) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *anyNotNullBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()

	a.allocator.performOperation(
		[]coldata.Vec{vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullBytesAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBytesAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         *coldata.Bytes
	nulls                       *coldata.Nulls
	curIdx                      int
	foundNonNullForCurrentGroup bool
}

func (a *anyNotNullBytesAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec.Bytes()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBytesAgg) Reset() {
	a.vec.Zero()
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := a.vec.Len()
		target := a.vec.Slice(idx+1, vecLen)
		target.Zero()
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *anyNotNullBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()

	a.allocator.performOperation(
		[]coldata.Vec{vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col.Get(int(i))
							a.vec.Set(a.curIdx, v)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col.Slice(0, int(inputLen))
					for i := 0; i < col.Len(); i++ {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col.Get(int(i))
							a.vec.Set(a.curIdx, v)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col.Get(int(i))
							a.vec.Set(a.curIdx, v)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col.Slice(0, int(inputLen))
					for i := 0; i < col.Len(); i++ {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col.Get(int(i))
							a.vec.Set(a.curIdx, v)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullDecimalAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullDecimalAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         []apd.Decimal
	nulls                       *coldata.Nulls
	curIdx                      int
	foundNonNullForCurrentGroup bool
}

func (a *anyNotNullDecimalAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec.Decimal()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullDecimalAgg) Reset() {
	for n := 0; n < len(a.vec); n++ {
		a.vec[n].SetInt64(0)
	}
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.vec)
		target := a.vec[idx+1 : vecLen]
		for n := 0; n < len(target); n++ {
			target[n].SetInt64(0)
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *anyNotNullDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()

	a.allocator.performOperation(
		[]coldata.Vec{vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx].Set(&v)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx].Set(&v)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx].Set(&v)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx].Set(&v)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullInt16Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt16Agg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         []int16
	nulls                       *coldata.Nulls
	curIdx                      int
	foundNonNullForCurrentGroup bool
}

func (a *anyNotNullInt16Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec.Int16()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt16Agg) Reset() {
	for n := 0; n < len(a.vec); n += copy(a.vec[n:], zeroInt16Column) {
	}
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.vec)
		target := a.vec[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt16Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *anyNotNullInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()

	a.allocator.performOperation(
		[]coldata.Vec{vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullInt32Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt32Agg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         []int32
	nulls                       *coldata.Nulls
	curIdx                      int
	foundNonNullForCurrentGroup bool
}

func (a *anyNotNullInt32Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec.Int32()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt32Agg) Reset() {
	for n := 0; n < len(a.vec); n += copy(a.vec[n:], zeroInt32Column) {
	}
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.vec)
		target := a.vec[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt32Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *anyNotNullInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()

	a.allocator.performOperation(
		[]coldata.Vec{vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullInt64Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt64Agg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         []int64
	nulls                       *coldata.Nulls
	curIdx                      int
	foundNonNullForCurrentGroup bool
}

func (a *anyNotNullInt64Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec.Int64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt64Agg) Reset() {
	for n := 0; n < len(a.vec); n += copy(a.vec[n:], zeroInt64Column) {
	}
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.vec)
		target := a.vec[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroInt64Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *anyNotNullInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()

	a.allocator.performOperation(
		[]coldata.Vec{vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullFloat64Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullFloat64Agg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         []float64
	nulls                       *coldata.Nulls
	curIdx                      int
	foundNonNullForCurrentGroup bool
}

func (a *anyNotNullFloat64Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec.Float64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullFloat64Agg) Reset() {
	for n := 0; n < len(a.vec); n += copy(a.vec[n:], zeroFloat64Column) {
	}
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.vec)
		target := a.vec[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroFloat64Column) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *anyNotNullFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()

	a.allocator.performOperation(
		[]coldata.Vec{vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullTimestampAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullTimestampAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         []time.Time
	nulls                       *coldata.Nulls
	curIdx                      int
	foundNonNullForCurrentGroup bool
}

func (a *anyNotNullTimestampAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec.Timestamp()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullTimestampAgg) Reset() {
	for n := 0; n < len(a.vec); n += copy(a.vec[n:], zeroTimestampColumn) {
	}
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		vecLen := len(a.vec)
		target := a.vec[idx+1 : vecLen]
		for n := 0; n < len(target); n += copy(target[n:], zeroTimestampColumn) {
		}
		a.nulls.UnsetNullsAfter(uint16(idx + 1))
	}
}

func (a *anyNotNullTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(uint16(a.curIdx))
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()

	a.allocator.performOperation(
		[]coldata.Vec{vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(uint16(i))
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:int(inputLen)]
					for i := range col {

						if a.groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group. The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if !a.foundNonNullForCurrentGroup && a.curIdx >= 0 {
								a.nulls.SetNull(uint16(a.curIdx))
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							// Explicit template language is used here because the type receiver differs
							// from the rest of the template file.
							// TODO(asubiotto): Figure out a way to alias this.
							v := col[int(i)]
							a.vec[a.curIdx] = v
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}
